<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>排序</title>
      <link href="/2025/05/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/"/>
      <url>/2025/05/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>冒泡排序<br><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span> </span>&#123;  <span class="comment">// 冒泡排序法，添加数组长度参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j - <span class="number">1</span>] &gt; a[j]) &#123;</span><br><span class="line">                <span class="type">int</span> t = a[j - <span class="number">1</span>];</span><br><span class="line">                a[j - <span class="number">1</span>] = a[j];</span><br><span class="line">                a[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArr</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span> </span>&#123;    <span class="comment">// 添加数组长度参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)   <span class="comment">// 修正循环条件</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123; <span class="number">23</span>,<span class="number">54</span>,<span class="number">12</span>,<span class="number">67</span>,<span class="number">879</span>,<span class="number">567</span>,<span class="number">435</span>,<span class="number">45</span>,<span class="number">32</span>,<span class="number">4</span>,<span class="number">54</span>,<span class="number">345</span> &#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(a[<span class="number">0</span>]);  <span class="comment">// 计算数组长度</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">BubbleSort</span>(a, n);      <span class="comment">// 传递数组和长度</span></span><br><span class="line">    <span class="built_in">printArr</span>(a, n);        <span class="comment">// 传递数组和长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>快速排序<br>定义开头的[0]为left,定义[n]为right,定义[0]为标准<br>原理:<br>通过left和right与标准的不断对比和移动，最后使得标准的左侧都比标准小，右侧都比标准大<br><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FastSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> boss = a[left];       <span class="comment">// 选择基准值</span></span><br><span class="line">        <span class="type">int</span> hole = left;          <span class="comment">// 孔位初始指向第一个元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 从右向左查找小于基准值的元素</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt;= boss) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            a[hole] = a[right];</span><br><span class="line">            hole = right;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从左向右查找大于基准值的元素</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt;= boss) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            a[hole] = a[left];</span><br><span class="line">            hole = left;</span><br><span class="line">        &#125;</span><br><span class="line">        a[hole] = boss; <span class="comment">// 将基准值放到中间位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归对左右两部分排序</span></span><br><span class="line">        <span class="built_in">FastSort</span>(a, <span class="number">0</span>, hole - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">FastSort</span>(a, hole + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123; <span class="number">4</span>, <span class="number">3</span>, <span class="number">30</span>, <span class="number">45</span>, <span class="number">54</span>, <span class="number">54</span>, <span class="number">67</span>, <span class="number">213</span>, <span class="number">435</span>, <span class="number">567</span>, <span class="number">879</span>, <span class="number">345</span> &#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">FastSort</span>(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">p</span>(a, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接插入排序<br>循环开始：从数组的第二个元素（索引为1）开始，因为单个元素本身就是有序的。<br>保存当前元素：将当前元素arr[i]保存到key中。<br>比较和移动：将key与前面已排序部分的元素进行比较，如果前面的元素大于key，则将该元素向后移动一位。<br>插入位置：找到第一个小于等于key的元素位置，将key插入到该位置。<br><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%9B%B4%E6%8E%A5%E6%8E%92%E5%BA%8F.gif"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123; <span class="comment">// 从数组的第二个元素开始循环</span></span><br><span class="line">        <span class="type">int</span> key = arr[i]; <span class="comment">// 将当前元素赋值给key</span></span><br><span class="line">        j = i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将比key大的元素都依次向后移动一位</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = key; <span class="comment">// 将key插入到正确的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123; <span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span> &#125;; <span class="comment">// 定义一个数组</span></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]); <span class="comment">// 计算数组的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">insertionSort</span>(arr, n); <span class="comment">// 调用排序函数对数组进行排序</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的数组: \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printArray</span>(arr, n); <span class="comment">// 打印排序后的数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>希尔排序<br><video src="/图片/数据结构/希尔排序.mp4" controls="controls" width="100%"></video></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> gap = n / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (gap &gt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; n; i++) &#123;</span><br><span class="line"><span class="type">int</span> temp = a[i];</span><br><span class="line"><span class="type">int</span> j = i;</span><br><span class="line"><span class="keyword">while</span>(j&gt;=gap &amp;&amp; a[j - gap] &gt; temp) &#123;</span><br><span class="line">a[j] = a[j - gap];</span><br><span class="line">j -= gap;</span><br><span class="line">&#125;</span><br><span class="line">a[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">gap /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">234</span>,<span class="number">5</span>,<span class="number">5678</span>,<span class="number">54</span>,<span class="number">68</span>,<span class="number">7</span>,<span class="number">546</span>,<span class="number">3</span>,<span class="number">42</span>,<span class="number">5</span>,<span class="number">789</span>,<span class="number">0</span> &#125;; <span class="comment">// 定义一个数组</span></span><br><span class="line"><span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]); <span class="comment">// 计算数组的长度</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">insert</span>(arr, n); <span class="comment">// 调用排序函数对数组进行排序</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;排序后的数组: \n&quot;</span>);</span><br><span class="line"><span class="built_in">printArray</span>(arr, n); <span class="comment">// 打印排序后的数组</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接选择排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> temp, min;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">min = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[j] &lt; a[min]) &#123;</span><br><span class="line">min = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">temp = a[i];</span><br><span class="line">a[i] = a[min];</span><br><span class="line">a[min] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">234</span>,<span class="number">5</span>,<span class="number">5678</span>,<span class="number">54</span>,<span class="number">68</span>,<span class="number">7</span>,<span class="number">546</span>,<span class="number">3</span>,<span class="number">42</span>,<span class="number">5</span>,<span class="number">789</span>,<span class="number">0</span> &#125;; <span class="comment">// 定义一个数组</span></span><br><span class="line"><span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]); <span class="comment">// 计算数组的长度</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">insert</span>(arr, n); <span class="comment">// 调用排序函数对数组进行排序</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;排序后的数组: \n&quot;</span>);</span><br><span class="line"><span class="built_in">printArray</span>(arr, n); <span class="comment">// 打印排序后的数组</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插帽龟，他很稳（插入，冒泡，归并）<br>插帽龟喜欢选帽插，插完就慌了（慌了&#x3D;方了，n的平方）<br>快龟堆，见到n老（nlog n）</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象进阶</title>
      <link href="/2025/05/09/JAVA/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/"/>
      <url>/2025/05/09/JAVA/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<p>1.static<br>在main中调用类名的方法时，其方法的对象可能是多个对象的共同对象<br>比如说创建了s1,s2两个学生对象，他们有共同的老师t，调用方法时老师是同一个<br>但如果不加static，t就需要被定义两次<br><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/JAVA%5Cstatic.png"><br>所以要用static<br><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/JAVA%5Cstatic1.png"><br>被static修饰的变量叫做 静态变量</p><p>2.继承extends<br>啥时候用继承？<br>当类与类之间，存在共性的的内容，并满足子类是父类的一种，就可以用继承</p><p>3.多态<br><img src="/%E5%9B%BE%E7%89%87/JAVA/%E5%A4%9A%E6%80%81.png"><br><img src="/%E5%9B%BE%E7%89%87/JAVA/%E5%A4%9A%E6%80%812.png"><br><img src="/%E5%9B%BE%E7%89%87/JAVA/%E5%A4%9A%E6%80%813.png"><br>创建完对象之后用:register(s)  register(t)   register(admin)调用即可</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>集合ArrayList</title>
      <link href="/2025/05/09/JAVA/%E9%9B%86%E5%90%88ArrayList/"/>
      <url>/2025/05/09/JAVA/%E9%9B%86%E5%90%88ArrayList/</url>
      
        <content type="html"><![CDATA[<p>1.创建对象<br>ArrayList<String> list &#x3D; new ArrayList&lt;&gt;();</p><p>2.添加<br>list.add(“   “);</p><p>3.删除<br>list.remove(“   “);<br>此处可以填具体存在的值或者是索引</p><p>4.修改<br>list.set( 索引, 要修改的值)</p><p>5.查询<br>list.get( 索引)</p><p>实例：<br>import java.lang.reflect.Array;<br>import java.util.ArrayList;<br>import java.util.Scanner;</p><p>public class Main {<br>    public static void main(String[] args) {<br>        &#x2F;&#x2F;1.创建集合<br>        ArrayList<Student> list &#x3D; new ArrayList&lt;&gt;();<br>        &#x2F;&#x2F;2.创建学生对象<br>        Student s1 &#x3D; new Student(“日奈”,17);<br>        Student s2 &#x3D; new Student(“伊吹”,11);<br>        &#x2F;&#x2F;3.添加元素<br>        list.add(s1);<br>        list.add(s2);</p><pre><code>    //键盘输入    Student s3 = new Student();    Scanner sc = new Scanner(System.in);    System.out.println(&quot;输入姓名&quot;);    String name = sc.next();    System.out.println(&quot;输入年龄&quot;);    int age = sc.nextInt();    s3.setName(name);    s3.setAge(age);    list.add(s3);    //5.遍历集合    for (int i = 0; i &lt; list.size(); i++) &#123;        Student stu = list.get(i);        System.out.println(stu.getName() + &quot;,&quot; + stu.getAge());    &#125;&#125;</code></pre><p>}</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>String</title>
      <link href="/2025/05/08/JAVA/String/"/>
      <url>/2025/05/08/JAVA/String/</url>
      
        <content type="html"><![CDATA[<p>StringBuilder<br>1.创建对象<br>StringBuilder sb &#x3D; new StringBuilder();</p><p>2.添加元素append()<br>sb.append(1);<br>sb.append(dkjfak);</p><p>3.反转reverse()<br>sb.reverse();</p><p>4.获取长度length()<br>int len &#x3D; sb.length();</p><p>5.变回字符串toString()<br>(因为sb是StringBuilder类型的，并不是字符串)<br>String str &#x3D; sb.toString();</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>循环列表</title>
      <link href="/2025/05/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/"/>
      <url>/2025/05/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>#include&lt;stdio.h&gt;<br>#include&lt;stdlib.h&gt;<br>#define max 100<br>typedef int ElemType;</p><p>typedef struct QueueNode{<br>ElemType data;<br>struct QueueNode *next;<br>}QueueNode;</p><p>typedef struct{<br>QueueNode* front;<br>QueueNode* rear;<br>}Queue;</p><p>&#x2F;&#x2F;初始化<br>Queue* initQueueNode() {<br>QueueNode* node &#x3D; (QueueNode*)malloc(sizeof(QueueNode));&#x2F;&#x2F;node是头结点<br>Queue* q &#x3D; (Queue*)malloc(sizeof(Queue));<br>node-&gt;data &#x3D; 0;<br>node-&gt;next &#x3D; NULL;<br>q-&gt;front &#x3D; node;<br>q-&gt;rear &#x3D; node;<br>return q;<br>}</p><p>&#x2F;&#x2F;判断是否为空<br>int isEmpty(Queue* q) {<br>if (q-&gt;front &#x3D;&#x3D; q-&gt;rear) {<br>return 1;<br>}<br>else {<br>return 0;<br>}<br>}</p><p>&#x2F;&#x2F;入队<br>void inQueue(Queue *q, ElemType e) {<br>QueueNode <em>node &#x3D; (QueueNode</em>)malloc(sizeof(QueueNode));<br>node-&gt;data &#x3D; e;<br>node-&gt;next &#x3D; NULL;<br>q-&gt;rear-&gt;next &#x3D; node;&#x2F;&#x2F;把node赋给尾巴的下一个<br>q-&gt;rear &#x3D; node;&#x2F;&#x2F;      之后再让尾巴变成node<br>}</p><p>&#x2F;&#x2F;出队<br>int outQueue(Queue *q, ElemType *e) {<br>if (isEmpty(q)) {<br>printf(“空的”);<br>return 0;<br>}<br>QueueNode *node &#x3D; q-&gt;front-&gt;next;&#x2F;&#x2F;q-&gt;front指向头结点，node就是头结点的下一个节点<br>*e &#x3D; node-&gt;data;<br>q-&gt;front-&gt;next &#x3D; node-&gt;next;<br>if (q-&gt;rear &#x3D;&#x3D; node) {<br>q-&gt;rear &#x3D; q-&gt;front;<br>}<br>free(node);<br>return 1;<br>}</p><p>int main() {<br>Queue* q &#x3D; initQueueNode();<br>inQueue(q, 10);<br>inQueue(q, 20);<br>inQueue(q, 30);<br>ElemType e;<br>outQueue(q, &amp;e);<br>printf(“%d”, e);<br>return 0;<br>}</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>链队列</title>
      <link href="/2025/05/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E9%98%9F%E5%88%97/"/>
      <url>/2025/05/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E9%98%9F%E5%88%97.png"><br>#include&lt;stdio.h&gt;<br>#include&lt;stdlib.h&gt;<br>#define max 100<br>typedef int ElemType;</p><p>typedef struct QueueNode{<br>ElemType data;<br>struct QueueNode *next;<br>}QueueNode;</p><p>typedef struct{<br>QueueNode* front;<br>QueueNode* rear;<br>}Queue;</p><p>&#x2F;&#x2F;初始化<br>Queue* initQueueNode() {<br>QueueNode* node &#x3D; (QueueNode*)malloc(sizeof(QueueNode));&#x2F;&#x2F;node是头结点<br>Queue* q &#x3D; (Queue*)malloc(sizeof(Queue));<br>node-&gt;data &#x3D; 0;<br>node-&gt;next &#x3D; NULL;<br>q-&gt;front &#x3D; node;<br>q-&gt;rear &#x3D; node;<br>return q;<br>}</p><p>&#x2F;&#x2F;判断是否为空<br>int isEmpty(Queue* q) {<br>if (q-&gt;front &#x3D;&#x3D; q-&gt;rear) {<br>return 1;<br>}<br>else {<br>return 0;<br>}<br>}</p><p>&#x2F;&#x2F;入队<br>void inQueue(Queue *q, ElemType e) {<br>QueueNode <em>node &#x3D; (QueueNode</em>)malloc(sizeof(QueueNode));<br>node-&gt;data &#x3D; e;<br>node-&gt;next &#x3D; NULL;<br>q-&gt;rear-&gt;next &#x3D; node;&#x2F;&#x2F;把node赋给尾巴的下一个<br>q-&gt;rear &#x3D; node;&#x2F;&#x2F;      之后再让尾巴变成node<br>}</p><p>&#x2F;&#x2F;出队<br>int outQueue(Queue *q, ElemType *e) {<br>if (isEmpty(q)) {<br>printf(“空的”);<br>return 0;<br>}<br>QueueNode *node &#x3D; q-&gt;front-&gt;next;&#x2F;&#x2F;q-&gt;front指向头结点，node就是头结点的下一个节点<br>*e &#x3D; node-&gt;data;<br>q-&gt;front-&gt;next &#x3D; node-&gt;next;<br>if (q-&gt;rear &#x3D;&#x3D; node) {<br>q-&gt;rear &#x3D; q-&gt;front;<br>}<br>free(node);<br>return 1;<br>}</p><p>int main() {<br>Queue* q &#x3D; initQueueNode();<br>inQueue(q, 10);<br>inQueue(q, 20);<br>inQueue(q, 30);<br>ElemType e;<br>outQueue(q, &amp;e);<br>printf(“%d”, e);<br>return 0;<br>}</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>队列</title>
      <link href="/2025/05/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/"/>
      <url>/2025/05/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97.png"><br>队列是先进先出,像排队一样</p><p>#include&lt;stdio.h&gt;<br>#include&lt;stdlib.h&gt;<br>#define max 100<br>typedef int ElemType;</p><p>typedef struct {<br>ElemType* data;<br>int front;<br>int rear;<br>}Queue;</p><p>&#x2F;&#x2F;初始化<br>Queue* initQueue() {<br>Queue* q &#x3D; (Queue*)malloc(sizeof(Queue));<br>q-&gt;data &#x3D; (ElemType*)malloc(sizeof(ElemType));<br>q-&gt;front &#x3D; 0;<br>q-&gt;rear &#x3D; 0;<br>return q;<br>}</p><p>&#x2F;&#x2F;出队<br>ElemType outQueue(Queue* q) {<br>if (q-&gt;front &#x3D;&#x3D; q-&gt;rear) {<br>printf(“空的”);<br>return 0;<br>}<br>ElemType e &#x3D; q-&gt;data[q-&gt;front];<br>q-&gt;front++;<br>return e;<br>}</p><p>&#x2F;&#x2F;判断是否为满<br>int queueFull(Queue* q) {<br>if (q-&gt;front &gt; 0) {<br>int step &#x3D; q-&gt;front;<br>for (int i &#x3D; q-&gt;front; i &lt; q-&gt;rear; i++)<br>{<br>q-&gt;data[i - step] &#x3D; q-&gt;data[i];<br>}<br>q-&gt;front &#x3D; 0;<br>q-&gt;rear &#x3D; q-&gt;rear - step;<br>return 1;<br>}<br><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%85%A5%E9%98%9F.png"><br>else {<br>printf(“真的满了”);<br>return 0;<br>}<br>}</p><p>&#x2F;&#x2F;入队<br>int inQueue(Queue* q, ElemType e) {<br>if (q-&gt;rear &gt;&#x3D; max) {<br>if (!(queueFull))&#x2F;&#x2F;这时候判断是否真的满了<br>{<br>return 0;<br>}<br>}<br>q-&gt;data[q-&gt;rear] &#x3D; e;<br>q-&gt;rear++;<br>return 1;<br>}</p><p>&#x2F;&#x2F;循环队列-入队<br>int cycleIn(Queue* q, ElemType e) {<br>if ((q-&gt;rear + 1) % max &#x3D;&#x3D; q-&gt;front) {<br>printf(“满了”);<br>return 0;<br>}<br>q-&gt;rear &#x3D; (q-&gt;rear + 1) % max;<br>return 1;<br>}</p><p>int main() {<br>Queue* q &#x3D; initQueue();<br>inQueue(q, 10);<br>inQueue(q, 20);<br>inQueue(q, 30);<br>printf(“%d”, outQueue(q));<br>printf(“%d”, outQueue(q));</p><pre><code>return 0;</code></pre><p>}</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>栈</title>
      <link href="/2025/05/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/"/>
      <url>/2025/05/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88.png"><br>栈是后进先出，像弹夹一样</p><p>#include&lt;stdio.h&gt;<br>#include&lt;stdlib.h&gt;<br>#define max 100<br>typedef int ElemType;</p><p>typedef struct {<br>ElemType data[max];<br>int top;<br>}Stack;</p><p>&#x2F;&#x2F;初始化<br>void initStack(Stack* s) {<br>s-&gt;top &#x3D; -1;<br>}</p><p>&#x2F;&#x2F;压栈&#x2F;进栈<br>int push(Stack* s, ElemType e) {<br>if (s-&gt;top &gt;&#x3D; max - 1) {<br>printf(“满了\n”);<br>return 0;<br>}<br>s-&gt;top++;<br>s-&gt;data[s-&gt;top] &#x3D; e;<br>return 1;<br>}</p><p>&#x2F;&#x2F;出栈<br>int pop(Stack <em>s, ElemType</em> e){<br>if (s-&gt;top &#x3D;&#x3D; -1) {<br>printf(“空的”);<br>return 0;<br>}<br>*e &#x3D; s-&gt;data[s-&gt;top];<br>s-&gt;top–;<br>return 1;<br>}</p><p>int main() {<br>Stack s;<br>initStack(&amp;s);<br>push(&amp;s, 10);<br>push(&amp;s, 20);<br>push(&amp;s, 30);<br>ElemType e;<br>pop(&amp;s, &amp;e);<br>printf(“%d\n”, e);<br>return 0;<br>}</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>韩语基础篇</title>
      <link href="/2025/05/06/%E9%9F%A9%E8%AF%AD/%E9%9F%A9%E8%AF%AD%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
      <url>/2025/05/06/%E9%9F%A9%E8%AF%AD/%E9%9F%A9%E8%AF%AD%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>日常生活<br>单词:</p>]]></content>
      
      
      <categories>
          
          <category> 韩语 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>双向链表</title>
      <link href="/2025/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
      <url>/2025/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>#include&lt;stdio.h&gt;<br>#include&lt;stdlib.h&gt;<br>typedef int ElemType;</p><p>typedef struct node{<br>ElemType data;<br>struct node *prev, *next;</p><p>}Node;</p><p>&#x2F;&#x2F;初始化双向链表<br>Node* initNode() {<br>Node* head &#x3D; (Node*)malloc(sizeof(Node));<br>head-&gt;data &#x3D; 0;<br>head-&gt;prev &#x3D; NULL;<br>head-&gt;next &#x3D; NULL;<br>return head;<br>}</p><p>&#x2F;&#x2F;头插法<br>int insertHead(Node* L, ElemType e) {<br>Node* p &#x3D; (Node*)malloc(sizeof(Node));<br>p-&gt;data &#x3D; e;<br>p-&gt;prev &#x3D; L;<br>p-&gt;next &#x3D; L-&gt;next;<br>if (L-&gt;next !&#x3D; NULL) {<br>L-&gt;next-&gt;prev &#x3D; p;<br>}<br>L-&gt;next &#x3D; p;<br>return 1;<br>}</p><p>&#x2F;&#x2F;遍历<br>int listNode(Node* L) {<br>Node* p &#x3D; L-&gt;next;<br>while (p !&#x3D; NULL) {<br>printf(“%d  “, p-&gt;data);<br>p &#x3D; p-&gt;next;<br>}<br>printf(“\n”);<br>return 1;<br>}</p><p>&#x2F;&#x2F;获取尾部节点<br>Node* getTail(Node* L) {<br>Node* p &#x3D; L;<br>while (p-&gt;next !&#x3D; NULL) {<br>p &#x3D; p-&gt;next;<br>}<br>return p;<br>}</p><p>&#x2F;&#x2F;尾插法<br>Node* insertTail(Node* tail, ElemType e) {<br>Node* p &#x3D; (Node*)malloc(sizeof(Node));<br>p-&gt;data &#x3D; e;<br>p-&gt;prev &#x3D; tail;<br>tail-&gt;next &#x3D; p;<br>p-&gt;next &#x3D; NULL;<br>return p;<br>}</p><p>&#x2F;&#x2F;指定位置插入<br>void insertNode(Node* L, int pos, ElemType e) {<br>Node* p &#x3D; L;<br>int i &#x3D; 0;<br>while (i &lt; pos - 1) {<br>p &#x3D; p-&gt;next;<br>i++;<br>}<br>Node* q &#x3D; (Node*)malloc(sizeof(Node));<br>q-&gt;data &#x3D; e;<br>q-&gt;prev &#x3D; p;<br>q-&gt;next &#x3D; p-&gt;next;<br>p-&gt;next &#x3D; q;<br>p-&gt;next-&gt;prev &#x3D; q;<br>}</p><p>&#x2F;&#x2F;删除节点<br>int deleteNode(Node* L, int pos) {<br>Node* p &#x3D; L;<br>int i &#x3D; 0;<br>while (i &lt; pos - 1) {<br>p &#x3D; p-&gt;next;<br>i++;<br>if (p &#x3D;&#x3D; NULL){<br>return 0;<br>}<br>}<br>Node* q &#x3D; p-&gt;next;<br>p-&gt;next &#x3D; q-&gt;next;<br>q-&gt;next-&gt;prev &#x3D; p;<br>free(q);<br>return 1;<br>}</p><p>int main() {<br>Node* list &#x3D; initNode();<br>&#x2F;<em>insertHead(list, 1);<br>insertHead(list, 2);<br>insertHead(list, 3);</em>&#x2F;<br>Node* tail &#x3D; getTail(list);<br>tail &#x3D; insertTail(tail, 1);<br>tail &#x3D; insertTail(tail, 2);<br>tail &#x3D; insertTail(tail, 3);<br>listNode(list);<br>insertNode(list, 2, 6);<br>listNode(list);<br>deleteNode(list, 3);<br>listNode(list);<br>return 0;<br>}</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2025/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/"/>
      <url>/2025/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>#include&lt;stdio.h&gt;<br>#include&lt;stdlib.h&gt;<br>typedef int ElemType;<br>typedef struct node {<br>ElemType data;<br>struct node* next;<br>}Node;</p><p>Node* initList() {<br>Node* head &#x3D; (Node*)malloc(sizeof(Node));<br>head-&gt;data &#x3D; 0;<br>head-&gt;next &#x3D; NULL;<br>return head;<br>}</p><p>&#x2F;&#x2F;头插法<br>int insertHead(Node* L, ElemType e)&#x2F;&#x2F;L为头结点<br>{<br>Node* p &#x3D; (Node*)malloc(sizeof(Node));<br>p-&gt;data &#x3D; e;<br>p-&gt;next &#x3D; L-&gt;next;<br>L-&gt;next &#x3D; p;<br>return 1;<br>}</p><p>&#x2F;&#x2F;遍历<br>int listNode(Node* L) {<br>Node* p &#x3D; L-&gt;next;<br>while (p !&#x3D; NULL) {<br>printf(“%d  “, p-&gt;data);<br>p &#x3D; p-&gt;next;<br>}<br>printf(“\n”);<br>return 1;<br>}</p><p>&#x2F;&#x2F;获取尾部节点<br>Node* getTail(Node* L) {<br>Node* p &#x3D; L;<br>while (p-&gt;next !&#x3D; NULL) {<br>p &#x3D; p-&gt;next;<br>}<br>return p;<br>}</p><p>&#x2F;&#x2F;尾插法<br>Node* insertTail(Node* tail, ElemType e) {<br>Node* p &#x3D; (Node*)malloc(sizeof(Node));<br>p-&gt;data &#x3D; e;<br>tail-&gt;next &#x3D; p;<br>p-&gt;next &#x3D; NULL;<br>return p;<br>}</p><p>&#x2F;&#x2F;在指定位置插入<br>int insertNode(Node* L, int pos, ElemType e) {<br>Node* p &#x3D; L;<br>int i &#x3D; 0;<br>while (i &lt; pos - 1) {<br>p &#x3D; p-&gt;next;<br>i++;<br>if (p &#x3D;&#x3D; NULL) {<br>return 0;<br>}<br>}&#x2F;&#x2F;此时p为指定位置的前一个位置<br>Node* q &#x3D; (Node*)malloc(sizeof(Node));<br>q-&gt;data &#x3D; e;<br>q-&gt;next &#x3D; p-&gt;next;<br>p-&gt;next &#x3D; q;<br>return 1;<br>}</p><p>&#x2F;&#x2F;删除节点<br>int deleteNode(Node* L, int pos) {<br>Node* p &#x3D; L;<br>int i &#x3D; 0;<br>while (i &lt; pos - 1) {<br>p &#x3D; p-&gt;next;<br>i++;<br>if (p &#x3D;&#x3D; NULL) {<br>return 0;<br>}<br>}<br>Node* q &#x3D; p-&gt;next;<br>p-&gt;next &#x3D; q-&gt;next;<br>free(q);<br>return 1;<br>}</p><p>int main() {<br>Node* list &#x3D; initList();<br>Node* tail &#x3D; getTail(list);&#x2F;&#x2F;先找到尾结点<br>&#x2F;<em>insertHead(list, 10);<br>insertHead(list, 20);<br>insertHead(list, 30);</em>&#x2F;<br>tail &#x3D; insertTail(tail, 10);&#x2F;&#x2F;通过更新尾结点来持续进行尾插法<br>tail &#x3D; insertTail(tail, 20);<br>tail &#x3D; insertTail(tail, 30);<br>listNode(list);<br>insertNode(list, 2, 100);<br>listNode(list);<br>deleteNode(list, 3);<br>listNode(list);<br>return 0;<br>}</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>顺序表</title>
      <link href="/2025/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
      <url>/2025/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>#include&lt;stdio.h&gt;<br>#include&lt;stdlib.h&gt;<br>#define max 100<br>typedef int ElemType;</p><p>typedef struct {<br>    ElemType <em>data;<br>    int length;<br>}SeqList<br>;<br>&#x2F;&#x2F;初始化<br>SeqList</em> initList()<br>{<br>    SeqList* L &#x3D; (SeqList*)malloc(sizeof(SeqList));<br>    L-&gt;data &#x3D; (ElemType*)malloc(sizeof(ElemType) * max);<br>    L-&gt;length &#x3D; 0;<br>    return L;<br>}</p><p>&#x2F;&#x2F;在尾部添加数据<br>int appendElem(SeqList* L, ElemType e) {<br>    if (L-&gt;length &gt;&#x3D; max) {<br>        printf(“顺序表已满”);<br>        return 0;<br>    }<br>    L-&gt;data[L-&gt;length] &#x3D; e;<br>    L-&gt;length++;<br>    return 1;<br>}</p><p>&#x2F;&#x2F;遍历<br>void listElem(SeqList* L) {<br>    for (int i &#x3D; 0; i &lt; L-&gt;length; i++)<br>    {<br>        printf(“%d\t”, L-&gt;data[i]);<br>    }<br>    printf(“\n”);</p><p>}</p><p>&#x2F;&#x2F;插入数据<br>int insertElem(SeqList* L, int pos, ElemType e) {<br>    if (pos &lt;&#x3D; L-&gt;length - 1) {<br>        for (int i &#x3D; L-&gt;length - 1; i &gt;&#x3D; pos - 1; i–) {&#x2F;&#x2F;pos-1 就是要插入的位置<br>            L-&gt;data[i + 1] &#x3D; L-&gt;data[i];&#x2F;&#x2F;pos-1之后的数都往后挪一个位置，把pos-1的位置空出来<br>        }<br>        L-&gt;data[pos - 1] &#x3D; e;<br>        L-&gt;length++;<br>    }<br>    return 1;<br>}</p><p>&#x2F;&#x2F;删除数据<br>int deleteElem(SeqList* L, int pos, ElemType* e) {<br>    *e &#x3D; L-&gt;data[pos - 1];<br>    if (pos &lt; L-&gt;length) {<br>        for (int i &#x3D; pos; i &lt; L-&gt;length; i++)<br>        {<br>            L-&gt;data[i - 1] &#x3D; L-&gt;data[i];&#x2F;&#x2F;把要删除的位置后的数往前挪<br>        }<br>    }<br>    L-&gt;length–;<br>    return 1;<br>}</p><p>int main() {</p><pre><code>SeqList *list = initList();appendElem(list, 1);appendElem(list, 2);appendElem(list, 3);appendElem(list, 4);insertElem(list, 2, 6);listElem(list);ElemType delData;deleteElem(list, 2, &amp;delData);listElem(list);return 0;</code></pre><p>}</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>时间复杂度</title>
      <link href="/2025/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2025/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png"><br><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.png"><br>2的(t-1)次方 &gt; n  是因为只有这时候循环结束(即这是判定条件)</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/2025/05/01/JAVA/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2025/05/01/JAVA/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>一.对象代表什么,就得封装对应的数据，并提供数据对应的行为<br>比如“画圆”的对象是“圆”本身，因为画圆需要半径等等，并不是人画的<br>再比如“关门”是门自己关的，人不过是给了个作用力</p><p>二.private<br><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/JAVA%5Cprivate.png"><br>(忘了的时候看一眼吧)<br>直接用javabean插件就可以了嘻嘻<br>当然也可以用快捷键 alt+insert</p><p>三.this<br><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/JAVA/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F.png"><br>这是成员变量和局部变量</p><p><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/JAVA/%E5%B0%B1%E8%BF%91%E5%8E%9F%E5%88%99.png"><br>此为就近原则，如果不加this，谁离age近值就是谁，加上this，则会调用成员变量</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>像素画</title>
      <link href="/2025/05/01/%E5%83%8F%E7%B4%A0%E7%94%BB/%E5%83%8F%E7%B4%A0%E7%94%BB/"/>
      <url>/2025/05/01/%E5%83%8F%E7%B4%A0%E7%94%BB/%E5%83%8F%E7%B4%A0%E7%94%BB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 像素画 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>碎碎念</title>
      <link href="/2025/05/01/%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
      <url>/2025/05/01/%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>无语啦，累死我了&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
