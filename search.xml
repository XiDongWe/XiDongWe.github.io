<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>IO流</title>
      <link href="/2025/07/22/IO%E6%B5%81/"/>
      <url>/2025/07/22/IO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>IO流就是读取和存储数据的解决方案</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250722194923088.png" alt="image-20250722194923088"></p><p><code>结构：</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250722201616381.png" alt="image-20250722201616381"></p><h1 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250722201704545.png" alt="image-20250722201704545"></p><h2 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h2><p>可以把程序中的数据写到本地文件中</p><p><code>步骤：</code></p><ul><li>创建对象</li></ul><p>FileOutputStream f1 &#x3D; new FileOutputStream(“Test7\bb.txt”);         </p><ul><li>写数据</li></ul><p>f1.write(97);         </p><ul><li>释放资源</li></ul><p>f1.close();</p><p><code>一定要释放</code></p><h2 id="FileOutputStream写数据的3种方法"><a href="#FileOutputStream写数据的3种方法" class="headerlink" title="FileOutputStream写数据的3种方法"></a>FileOutputStream写数据的3种方法</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250727183210188.png" alt="image-20250727183210188"></p><ul><li>换行写</li></ul><p>只需加个换行符就行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">w</span> <span class="operator">=</span> <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] bytes1 = w.getBytes();</span><br><span class="line">f1.write(bytes1);</span><br></pre></td></tr></table></figure><ul><li>续写</li></ul><p>如果想要续写而不是清空原文件，只需在创建文件时的第二个参数选择true或false即可</p><p>FileOutputStream f1 &#x3D; new FileOutputStream(“Test7\bb.txt”，true&#x2F;false);   </p><ul><li>循环读取</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="keyword">while</span>((b = f2.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println((<span class="type">char</span>)b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h1><p><code>特点</code></p><p>一次读一个字节，遇到中文时，一次读多个字节</p><h2 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h2>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>File</title>
      <link href="/2025/07/22/JAVA/File/"/>
      <url>/2025/07/22/JAVA/File/</url>
      
        <content type="html"><![CDATA[<p>创建文件对象</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250721194605559.png" alt="image-20250721194605559"></p><p>String 名 &#x3D; new File(…);</p><h1 id="判断-获取"><a href="#判断-获取" class="headerlink" title="判断&#x2F;获取"></a>判断&#x2F;获取</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250722104048942.png" alt="image-20250722104048942"></p><h1 id="创建-删除"><a href="#创建-删除" class="headerlink" title="创建&#x2F;删除"></a>创建&#x2F;删除</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250722105753121.png" alt="image-20250722105753121"></p><p>一般用mkdirs就可以了</p><h1 id="获取并遍历"><a href="#获取并遍历" class="headerlink" title="获取并遍历"></a>获取并遍历</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250722192810107.png" alt="image-20250722192810107"></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>十大建模操作</title>
      <link href="/2025/07/21/%E5%BB%BA%E6%A8%A1/%E5%8D%81%E5%A4%A7%E5%BB%BA%E6%A8%A1%E6%93%8D%E4%BD%9C/"/>
      <url>/2025/07/21/%E5%BB%BA%E6%A8%A1/%E5%8D%81%E5%A4%A7%E5%BB%BA%E6%A8%A1%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="点线面"><a href="#点线面" class="headerlink" title="点线面"></a>点线面</h1><p>tap进入编辑模式</p><p>1,2,3，各对应点，线，面</p><p>选中一个点按alt可以选横向纵向</p><p>选中一个线按ctrl+alt可以选横向</p><h1 id="四大"><a href="#四大" class="headerlink" title="四大"></a>四大</h1><h2 id="向外挤出"><a href="#向外挤出" class="headerlink" title="向外挤出"></a>向外挤出</h2><p>打开编辑模式，选择面，按<code>E</code>即可挤出</p><p>按<code>shift</code>可以选择坐标方向</p><p>按<code>S</code>放大缩小</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250718133733442.png" alt="image-20250718133733442"></p><p>点模式下<code>ctrl+右键</code>可以挤出一条线</p><p>线模式下<code>E</code>可以从线中拉出面</p><h2 id="向内挤出"><a href="#向内挤出" class="headerlink" title="向内挤出"></a>向内挤出</h2><p>按<code>I</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250718134604000.png" alt="image-20250718134604000"></p><h2 id="倒角"><a href="#倒角" class="headerlink" title="倒角"></a>倒角</h2><p><code>ctrl+B</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250718134756037.png" alt="image-20250718134756037"></p><p>按鼠标滚轮可以增加段数</p><p>选面也可以</p><h2 id="循环切割"><a href="#循环切割" class="headerlink" title="循环切割"></a>循环切割</h2><p><code>ctrl+R</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250718135123416.png" alt="image-20250718135123416"></p><p>选择挤出各个面可以将切割的面分开，这样可以分开移动，而不会整体移动</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250718140212819.png" alt="image-20250718140212819"></p><h1 id="六小"><a href="#六小" class="headerlink" title="六小"></a>六小</h1><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p><code>M</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250718140556986.png" alt="image-20250718140556986"></p><h2 id="断开"><a href="#断开" class="headerlink" title="断开"></a>断开</h2><p><code>V</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250718140901193.png" alt="image-20250718140901193"></p><h2 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h2><p><code>F</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250718141050986.png" alt="image-20250718141050986"></p><p>先alt全选在填充</p><h2 id="切刀"><a href="#切刀" class="headerlink" title="切刀"></a>切刀</h2><p><code>K</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250718142041601.png" alt="image-20250718142041601"></p><h2 id="桥接"><a href="#桥接" class="headerlink" title="桥接"></a>桥接</h2><p><code>ctrl+E</code></p><ol><li>把想要拼接的两个物体对应的面删掉</li><li>在把两物体连接为一个整体(shift选择，ctrl+j连接)</li><li>alt双击选择两物体对应的线，如图</li><li>右键<code>桥接循环边</code>连接即可<br><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250718143308595.png" alt="image-20250718143308595"></li></ol><h2 id="分离"><a href="#分离" class="headerlink" title="分离"></a>分离</h2><p><code>P</code></p><p>字面意思</p>]]></content>
      
      
      <categories>
          
          <category> 建模 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>方法引用</title>
      <link href="/2025/07/21/JAVA/%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"/>
      <url>/2025/07/21/JAVA/%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250719135946701.png" alt="image-20250719135946701"></p><h1 id="引用静态方法"><a href="#引用静态方法" class="headerlink" title="引用静态方法"></a>引用静态方法</h1><p>其中的方法如果是静态static，就要用 <code>类名::静态方法方法</code> 的格式写</p><p><code>::</code>是方法引用符</p><h1 id="引用成员方法"><a href="#引用成员方法" class="headerlink" title="引用成员方法"></a>引用成员方法</h1><p><code>格式：</code>对象::成员方法</p><ol><li><code>其他类：</code>其他类对象::方法名</li><li><code>本类：</code>this::方法名</li><li><code>父类：</code>super::方法名</li></ol><h1 id="引用构造方法"><a href="#引用构造方法" class="headerlink" title="引用构造方法"></a>引用构造方法</h1><p><code>格式：</code>类名::new</p><h1 id="使用类名引用成员方法"><a href="#使用类名引用成员方法" class="headerlink" title="使用类名引用成员方法"></a>使用类名引用成员方法</h1><p><code>格式：</code>类名::成员方法</p><h1 id="引用数组的构造方法"><a href="#引用数组的构造方法" class="headerlink" title="引用数组的构造方法"></a>引用数组的构造方法</h1><p><code>格式：</code>数据类型[]::new</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stream流</title>
      <link href="/2025/07/18/JAVA/Stream%E6%B5%81/"/>
      <url>/2025/07/18/JAVA/Stream%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><p>​就像工厂流水线一样，通过对产品的一系列改造，最后得出商品</p><h1 id="1-先获取一条Stream流，并把数据放上去"><a href="#1-先获取一条Stream流，并把数据放上去" class="headerlink" title="1.先获取一条Stream流，并把数据放上去"></a>1.先获取一条Stream流，并把数据放上去</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250715145212013.png" alt="image-20250715145212013"></p><h1 id="2-Stream流中间方法"><a href="#2-Stream流中间方法" class="headerlink" title="2.Stream流中间方法"></a>2.Stream流中间方法</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250715151404682.png" alt="image-20250715151404682"></p><ul><li>filter过滤</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.addAll(list,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; stream1 = list.stream();</span><br><span class="line">stream1.filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.equals(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure><p>return 如果是true，则返回，false，则不返回</p><p>也可以接上自己想要的条件</p><p><code>建议使用链式方程</code>，代码更简洁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream1.filter(s -&gt; s.equals(<span class="string">&quot;a&quot;</span>)).forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure><ul><li>limit</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream1.limit(<span class="number">2</span>).forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure><ul><li>skip</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream1.skip(<span class="number">2</span>).forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure><ul><li>distinct</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream1.distinct().forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure><ul><li><p>contact</p></li><li><p>map</p></li></ul><h1 id="3-Stream流中的终结方法"><a href="#3-Stream流中的终结方法" class="headerlink" title="3.Stream流中的终结方法"></a>3.Stream流中的终结方法</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250715155911140.png" alt="image-20250715155911140"></p><p>其中collect要用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.collect(Collectors.类型)</span><br></pre></td></tr></table></figure><p>如果是双列集合map的话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.collec(Collectors.toMap(键的规则,值的规则))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中键和值的规则的格式为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.collect(Collectors.toMap(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;流当中数据的类型, 键的类型&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(String s)</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="keyword">new</span> <span class="title class_">Function</span>&lt;流当中数据的类型, 值的类型&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(String s)</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br></pre></td></tr></table></figure><p>最后华为lambda表达式即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.collect(Collectors.toMap(s -&gt; s., s -&gt; s.));</span><br></pre></td></tr></table></figure><p>或者在复习一下<a href="https://www.bilibili.com/video/BV1yW4y1Y7Ms?spm_id_from=333.788.videopod.episodes&vd_source=b0dff9885c076f5f4c78c1f99505a0cf&p=39">收集方法collect超详解</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快捷键</title>
      <link href="/2025/07/07/%E5%BB%BA%E6%A8%A1/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2025/07/07/%E5%BB%BA%E6%A8%A1/%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><p><code>中键</code>  旋转</p><p><code>shift+中键</code>  平移</p><p><code>shift+a</code>  新建图形</p><p><code>x / delete</code> 删除</p><p><code>g</code>  对着模型按，会跟着鼠标移动</p><p>再按 x, y, z, 会在对应坐标轴上移动</p><p><code>r</code>  旋转</p><p><code>s</code>  缩放</p><p><code>shift+z</code>  透视</p><p><code>h</code>  隐藏</p><p><code>shift+d</code>  复制</p><p><code>/</code> 选中拉进</p><p>小键盘中</p><p><code>1</code> 正视图 <code>3</code> 左视图<code>7</code> 俯视图 <code>9</code> 反向 <code>0</code> 摄像机视角</p><p><code>gz</code> 切换局部坐标(物体自己的xyz，是可变的)，再按xyz，切换全局坐标(整个界面的xyz，是规定的)</p>]]></content>
      
      
      <categories>
          
          <category> 建模 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL</title>
      <link href="/2025/07/06/Python/SQL/"/>
      <url>/2025/07/06/Python/SQL/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL语法特征"><a href="#SQL语法特征" class="headerlink" title="SQL语法特征"></a>SQL语法特征</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250705163608687.png" alt="image-20250705163608687"></p><h1 id="库管理"><a href="#库管理" class="headerlink" title="库管理"></a>库管理</h1><ul><li>查看数据库</li></ul><p>show databases;</p><ul><li>使用数据库</li></ul><p>use 数据库名称;</p><ul><li>创建数据库</li></ul><p>create database 数据库名称 [charset utf8]; &#x2F;&#x2F; []可写可不写</p><ul><li>删除数据库</li></ul><p>drop database 数据库名称;</p><ul><li>查看当前使用的数据库</li></ul><p>select database();</p><h1 id="DDL-表管理"><a href="#DDL-表管理" class="headerlink" title="DDL-表管理"></a>DDL-表管理</h1><ul><li>查看有哪些表</li></ul><p>show tables;    <code>需要先选择数据库</code></p><ul><li>创建表</li></ul><p>create table 表名称(</p><p>​列名称  列类型,</p><p>​……</p><p>);</p><p><code>类型</code></p><p>int           – 整数</p><p>float         – 浮点型</p><p>varchar(长度)  – 文本，长度为数字，做最大长度限制</p><p>date          – 日期类型</p><p>timestamp     – 时间戳类型</p><ul><li>删除表</li></ul><p>drop table 表名称;</p><p>drop table if exists 表名称;</p><h1 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h1><p>用来对数据库中表的数据记录进行更新</p><h2 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h2><p>语法:</p><p>insert into 表[(列1，列2，……，列n)] values(值1，值2，……，值n),[(值1，值2，……，值n),(值1，值2，……，值n),……]</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">use world;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> tables;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create table</span> animal(</span><br><span class="line"></span><br><span class="line">​age <span class="type">int</span>,</span><br><span class="line"></span><br><span class="line">​nam <span class="type">varchar</span>(<span class="number">10</span>) </span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert into</span> animal(age) <span class="keyword">values</span>(<span class="number">1</span>),(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>其中13行的animal(age)中的元素age等可以省略</p><h2 id="数据删除"><a href="#数据删除" class="headerlink" title="数据删除"></a>数据删除</h2><p>语法：</p><p>delete from 表名称 [where 条件判断]；</p><p>条件格式：列  操作符  值</p><p>操作符：&#x3D; &lt; &gt; &lt;&#x3D; &gt;&#x3D; !&#x3D;  等等</p><h2 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h2><p>updata 表名 set 列&#x3D;值 [where 条件判断];</p><h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><p> select 字段列表|* from 表;        &#x2F;&#x2F;*代表全部</p><p>如：select id,name from Student;</p><ul><li>过滤</li></ul><p> select 字段列表|* from 表 where 条件判断;  </p><h2 id="分组聚合"><a href="#分组聚合" class="headerlink" title="分组聚合"></a>分组聚合</h2><p>select 字段|聚合函数 from 表 [where 条件] group by 列</p><p><code>聚合函数</code>：</p><p>sun(列)    求和</p><p>avg(列)    求平均值</p><p>min(列)    求最小值</p><p>max()      求最大值</p><p>count()    求数量</p><h2 id="结果排序"><a href="#结果排序" class="headerlink" title="结果排序"></a>结果排序</h2><p>select 列|聚合函数|* from 表</p><p>where ……</p><p>group by ……</p><p>order by … [asc(从小到大) | desc(从大到小)]</p><ul><li>结果分页</li></ul><p>用limit关键字，对查询结果进行数量限制或分页显示</p><p>select 列|聚合函数|* from 表</p><p>where ……</p><p>group by ……</p><p>order by … [asc(从小到大) | desc(从大到小)]</p><p>limit n,[ m ]   &#x2F;&#x2F;如果只有n，意思是输出前n条，</p><p>​&#x2F;&#x2F;如果有n，m，意思是跳过前n条，再往后输出m条</p><h1 id="Python操作MySQL操作"><a href="#Python操作MySQL操作" class="headerlink" title="Python操作MySQL操作"></a>Python操作MySQL操作</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pymysql <span class="keyword">import</span> Connection</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建到MySQL数据库的链接</span></span><br><span class="line">conn = Connection(</span><br><span class="line">    host=<span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    port=<span class="number">3306</span>,</span><br><span class="line">    user=<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    password=<span class="string">&#x27;shenentao520&#x27;</span>,</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(conn.get_server_info())</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="执行非查询性质的sql语句"><a href="#执行非查询性质的sql语句" class="headerlink" title="执行非查询性质的sql语句"></a>执行非查询性质的sql语句</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取游标对象</span></span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"><span class="comment"># 先选择数据库</span></span><br><span class="line">conn.select_db(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"><span class="comment"># 使用游标对象，执行sql语句</span></span><br><span class="line">cursor.execute(<span class="string">&#x27;create table test (id int, name varchar(20))&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="执行查询性质的sql语句"><a href="#执行查询性质的sql语句" class="headerlink" title="执行查询性质的sql语句"></a>执行查询性质的sql语句</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用游标对象，执行sql语句</span></span><br><span class="line">cursor.execute(<span class="string">&#x27;select * from country&#x27;</span>)</span><br><span class="line">result: <span class="built_in">tuple</span> = cursor.fetchall()</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭连接</span></span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure><h2 id="执行插入性质的sql语句"><a href="#执行插入性质的sql语句" class="headerlink" title="执行插入性质的sql语句"></a>执行插入性质的sql语句</h2><p>执行插入语句的时候，并不会直接完成，而是要我们进行一个确认</p><p>通过连接对象.commit()进行确认即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cursor.execute(<span class="string">&quot;insert into animal(nam) values(&#x27;猫&#x27;)&quot;</span>)</span><br><span class="line"></span><br><span class="line">conn.commit()</span><br></pre></td></tr></table></figure><ul><li>自动commit</li></ul><p>autocommit&#x3D;True</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">conn = Connection(</span><br><span class="line">    host=<span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    port=<span class="number">3306</span>,</span><br><span class="line">    user=<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    password=<span class="string">&#x27;shenentao520&#x27;</span>,</span><br><span class="line">    autocommit=<span class="literal">True</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/2025/07/05/Python/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2025/07/05/Python/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><ul><li>设计一个类</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class student:</span><br><span class="line">    name = None</span><br><span class="line">    age = None</span><br></pre></td></tr></table></figure><ul><li>创建一个对象</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stu1 = student()</span><br></pre></td></tr></table></figure><ul><li>对对象进行赋值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stu1.name = &quot;日奈&quot;</span><br><span class="line">stu1.age = 17</span><br></pre></td></tr></table></figure><ul><li>类里面也可以添加函数</li></ul><p>class xxx:</p><p>​def xxxx(self):    &#x2F;&#x2F;self必须存在用来表示类对象自身的意思</p><p>​xxx       &#x2F;&#x2F;不过在传入参数时不用理它</p><p>如果有成员变量要传入到成员方法，要加self.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>:</span><br><span class="line">    name = None</span><br><span class="line">    def <span class="title function_">s</span><span class="params">(self)</span>:</span><br><span class="line">    print(f<span class="string">&quot;我是&#123;slef.name&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>成员方法也可以继续添加元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>:</span><br><span class="line">    name = None</span><br><span class="line">    def <span class="title function_">s</span><span class="params">(self,str)</span>:</span><br><span class="line">    print(f<span class="string">&quot;我是&#123;slef.name&#125;,&#123;str&#125;&quot;</span>) <span class="comment">//其中str因为是全局变量，所以不用加self.</span></span><br><span class="line">stu1 = stu()</span><br><span class="line">stu1.str(<span class="string">&quot;你好你好&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>因为一个个定义变量太麻烦，所以可以在函数中添加构造方法解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>:</span><br><span class="line">    name = <span class="type">None</span></span><br><span class="line">    <span class="variable">age</span> <span class="operator">=</span> None</span><br><span class="line">    def <span class="title function_">__init__</span><span class="params">(self,name,age)</span>:</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = <span class="type">age</span></span><br><span class="line"><span class="variable">student1</span> <span class="operator">=</span> student(<span class="string">&quot;日奈&quot;</span>,<span class="number">17</span>)</span><br></pre></td></tr></table></figure><p>因为构造方法里已经有属性了，所以name之类的可以不写了，直接写构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>:</span><br><span class="line">    def <span class="title function_">__init__</span><span class="params">(self,name,age)</span>:</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = <span class="type">age</span></span><br><span class="line"><span class="variable">student1</span> <span class="operator">=</span> student(<span class="string">&quot;日奈&quot;</span>,<span class="number">17</span>)</span><br></pre></td></tr></table></figure><h1 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h1><p>魔术方法也就是python的内置方法，__ init __就是其中一种</p><h2 id="str"><a href="#str" class="headerlink" title="__ str __"></a>__ str __</h2><p>当类对象需要转为字符串时，用print(str(xxx))的话，结果会输出内存地址，但我们并不需要这个，所以要用魔术方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>:</span><br><span class="line">    name = <span class="type">None</span></span><br><span class="line">    <span class="variable">age</span> <span class="operator">=</span> None</span><br><span class="line"> def <span class="title function_">__str__</span><span class="params">(self)</span>:</span><br><span class="line">        <span class="keyword">return</span> f<span class="string">&#x27;&#123;self.name&#125; is &#123;self.age&#125; years old&#x27;</span></span><br><span class="line">student1 = student(<span class="string">&quot;日奈&quot;</span>,<span class="number">17</span>)</span><br><span class="line">print(student1)</span><br></pre></td></tr></table></figure><p>print之后会按照__ str __的格式输出</p><h2 id="lt"><a href="#lt" class="headerlink" title="__ lt __"></a>__ lt __</h2><p>可同时完成<code>&lt;</code>,<code>&gt;</code>的比较</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>:</span><br><span class="line">    def <span class="title function_">__init__</span>(self,name,age):</span><br><span class="line">        self.<span class="property">name</span> = name</span><br><span class="line">        self.<span class="property">age</span> = age</span><br><span class="line">    def <span class="title function_">__lt__</span>(self,other):</span><br><span class="line">        <span class="keyword">return</span> self.<span class="property">age</span> &lt; other.<span class="property">age</span></span><br><span class="line"></span><br><span class="line">student1 = <span class="title function_">student</span>(<span class="string">&quot;日奈&quot;</span>,<span class="number">17</span>)</span><br><span class="line">student2 = <span class="title function_">student</span>(<span class="string">&quot;佳代子&quot;</span>,<span class="number">18</span>)</span><br><span class="line"><span class="title function_">print</span>(student1 &lt; student2)</span><br></pre></td></tr></table></figure><h2 id="le"><a href="#le" class="headerlink" title="__ le __"></a>__ le __</h2><p>可同时完成<code>&lt;=</code>,<code>&gt;=</code>的比较</p><p>逻辑跟lt一样</p><h2 id="eq"><a href="#eq" class="headerlink" title="__ eq __"></a>__ eq __</h2><p>可用于<code>==</code>的判断</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><h2 id="私有成员"><a href="#私有成员" class="headerlink" title="私有成员"></a>私有成员</h2><p>私有成员变量和方法只要在前面加上<code>__</code>即可</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">phone</span>:</span><br><span class="line">    __is_5g_enable = False</span><br><span class="line">    def <span class="title function_">__check_5g</span><span class="params">(self)</span>:</span><br><span class="line">        <span class="keyword">if</span> self.__is_5g_enable:</span><br><span class="line">            print(f<span class="string">&quot;5g开启&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(f<span class="string">&quot;5g关闭，用4g网络&quot;</span>)</span><br><span class="line">    def <span class="title function_">call_by_5g</span><span class="params">(self)</span>:</span><br><span class="line">        self.__check_5g()</span><br><span class="line">        print(<span class="string">&quot;正在通话中&quot;</span>)<span class="type">a</span></span><br><span class="line"></span><br><span class="line"><span class="variable">p</span> <span class="operator">=</span> phone()</span><br><span class="line">p.call_by_5g()</span><br></pre></td></tr></table></figure><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h2><p>格式：</p><p>class 类名(父类名):</p><p>​类内容体</p><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>格式：</p><p>class 类名(父类名1,父类名2,…):</p><p>​类内容体</p><p>如果继承后也不想在添加什么，那么可以写上pass来替代，保证语法不报错</p><h2 id="复写"><a href="#复写" class="headerlink" title="复写"></a>复写</h2><p>跟java的重写一样，继承之后def重写即可</p><p>变量和方法都能复写</p><h2 id="调用父类同名成员"><a href="#调用父类同名成员" class="headerlink" title="调用父类同名成员"></a>调用父类同名成员</h2><p>如果想调用被复写的父类的原有形式，有两种方法</p><ol><li><p>父类名.成员变量</p><p>父类名.成员方法(self)</p></li><li><p>super().成员变量</p></li></ol><p>​     super().成员方法()</p><h1 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h1><p>可以在写代码时理解某个变量的类型</p><p>格式：</p><p>变量名： 类型</p><p>如：  name: str &#x3D; “xxx”</p><p>​     stu: Student &#x3D; Student()</p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;wang&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;miao&quot;</span>)</span><br><span class="line"></span><br><span class="line">cat = Cat()</span><br><span class="line">cat.speak()</span><br><span class="line">dog = Dog()</span><br><span class="line">dog.speak()</span><br></pre></td></tr></table></figure><p>其中speak方法也叫做<code>抽象类</code>或<code>接口</code>，带有pass，子类必须重写接口才能使用</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pyecharts入门</title>
      <link href="/2025/07/03/Python/pyecharts/"/>
      <url>/2025/07/03/Python/pyecharts/</url>
      
        <content type="html"><![CDATA[<h1 id="pyecharts基础入门"><a href="#pyecharts基础入门" class="headerlink" title="pyecharts基础入门"></a>pyecharts基础入门</h1><h2 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h2><p>from pyecharts.charts import Line<br>from pyecharts.options import TitleOpts</p><h2 id="创建一个折线图对象"><a href="#创建一个折线图对象" class="headerlink" title="创建一个折线图对象"></a>创建一个折线图对象</h2><p>line &#x3D; Line()<br>#给折线图添加x轴数据<br>line.add_xaxis([“中国”,”美国”,”英国”])<br>#给折线图添加y轴数据<br>line.add_yaxis(“GDP”,[30,20,10])<br>#通过render方法，将代码变为图像<br>line.render()<br>#通过全局配置项set_global_opts来设置，TitleOpts导包<br>line.set_global_opts(<br>    title_opts&#x3D;TitleOpts(title&#x3D;”GDP展示”)<br>)</p><p>#通过render方法，将代码变为图像<br>line.render()</p><p>具体的设置可以到网站去寻找<a href="https://pyecharts.org/#/">pyecharts</a></p><h2 id="创建一个地图"><a href="#创建一个地图" class="headerlink" title="创建一个地图"></a>创建一个地图</h2><p>from pyecharts.charts import Map</p><h2 id="准备地图对象"><a href="#准备地图对象" class="headerlink" title="准备地图对象"></a>准备地图对象</h2><p>map &#x3D; Map()</p><h2 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h2><p>data &#x3D; [</p><p>​    (“湖南”,1),<br>​    (“吉林省”,3),<br>​    (“湖北省”,4),<br>​    (“广西壮族自治区”,5),<br>​    (“广东省”,6)<br>]</p><h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><p>map.add(“测试地图”,data,”china”)</p><h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><p>map.render()</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>异常 &amp; 模块</title>
      <link href="/2025/07/03/Python/%E5%BC%82%E5%B8%B8%20&amp;%20%E6%A8%A1%E5%9D%97/"/>
      <url>/2025/07/03/Python/%E5%BC%82%E5%B8%B8%20&amp;%20%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="基本捕获语法"><a href="#基本捕获语法" class="headerlink" title="基本捕获语法"></a>基本捕获语法</h2><p>try：</p><p>​    可能发生错误的代码</p><p>expect：</p><p>​    如果出现异常执行的代码</p><h2 id="捕获指定异常"><a href="#捕获指定异常" class="headerlink" title="捕获指定异常"></a>捕获指定异常</h2><p>try：</p><p>​    可能发生错误的代码</p><p>expect 异常名 as 变量名(任意，如a，c)：</p><p>​    如果出现异常执行的代码</p><h2 id="获取多个异常"><a href="#获取多个异常" class="headerlink" title="获取多个异常"></a>获取多个异常</h2><p>try：</p><p>​    可能发生错误的代码</p><p>expect (异常名1,异常名2) as 变量名(任意，如a，c)：</p><p>​    如果出现异常执行的代码</p><h2 id="获取全部异常"><a href="#获取全部异常" class="headerlink" title="获取全部异常"></a>获取全部异常</h2><p>try：</p><p>​    可能发生错误的代码</p><p>expect Exception as 变量名(任意，如a，c)：</p><p>​    如果出现异常执行的代码</p><h2 id="else-finally"><a href="#else-finally" class="headerlink" title="else &amp; finally"></a>else &amp; finally</h2><p><code>else</code>：如果没有异常时要执行的代码</p><p><code>finally</code>：有没有异常都会执行的代码</p><p>try：</p><p>​    可能发生错误的代码</p><p>expect Exception as 变量名(任意，如a，c)：</p><p>​    如果出现异常执行的代码</p><p>else:</p><p>​    ……</p><p>finally:</p><p>​    ……</p><h1 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h1><p><code>模块</code>就是一个python文件以.py结尾，里面有类，函数，变量等，可以直接拿过来用</p><p><code>格式</code>: </p><p>[from 模块名] import [模块 &#x2F; 类 &#x2F; 变量 &#x2F; 函数 &#x2F; *] [as 别名]  (“[]”为可写可不写)</p><h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p>如import time 可以引用time模块，其中有sleep可以让代码延时运行</p><p>如time.sleep(5)让代码睡5秒后在运行</p><h2 id="from-模块名-import-功能名"><a href="#from-模块名-import-功能名" class="headerlink" title="from 模块名 import 功能名"></a>from 模块名 import 功能名</h2><p>因为模块中不是所有的方法都会用到，所以用from来提取想要的功能</p><p>功能名()，这样即可使用</p><p>from 模块名 import *</p><p>意思是把模块中的所有功能都导进来</p><h2 id="import-功能名-as-别名"><a href="#import-功能名-as-别名" class="headerlink" title="import 功能名 as 别名"></a>import 功能名 as 别名</h2><p>给模块起别名的效果</p><p>如 import time as qq</p><p>qq.time(5)</p><h1 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h1><ol><li>新建一个.py文件，命个名，并定义方法</li><li>在另一个文件中import该文件即可使用</li></ol><p>不过当引用自定义模块的时候，会直接运行自定义模块，对于测试类是不需要的，但是又想测试自定义模块，那么可以在自定义模块中输入<code>main</code>加回车 生成“if __ name __ &#x3D;&#x3D; ‘__ main __ ’”:</p><p>再把需要测试的代码放在后面，这样既不影响自定义模块的测试，也不会干扰测试类</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250703100410459.png" alt="image-20250703100410459"></p><p><code>原理</code></p><p>__ name __其实是一个内置变量，当运行自定义模块时，name会变成main，满足if条件后运行后续代码</p><p>而在import自定义模块时，name不变，便运行不了</p><h2 id="all"><a href="#all" class="headerlink" title="__ all __"></a>__ all __</h2><p>如果模块中有__ all __变量，当使用from xxx import **</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>文件</title>
      <link href="/2025/07/03/Python/%E6%96%87%E4%BB%B6/"/>
      <url>/2025/07/03/Python/%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="open-函数"><a href="#open-函数" class="headerlink" title="open()函数"></a>open()函数</h1><p>open(name,mode,encoding)</p><p><code>name</code>：打开的目标文件名的字符串，也可以是具体路径</p><p><code>mode</code>：设置打开文件的模式</p><p><code>encoding</code>：编码格式(建议用UTF-8)</p><p>如：</p><p>f &#x3D; open(“D:&#x2F;测试.txt”,“r”,encoding&#x3D;“UTF-8”)</p><p><code>r</code>:以只读方式打开文件，文件的指针会放在文件的开头</p><p><code>w</code>:打开一个文件只用于写入</p><ul><li>如果该文件已存在则打开文件，并从开头开始编辑，原有内容会被删除</li><li>如果该文件不存在，创建新文件</li></ul><p><code>a</code>:打开一个文件用于追加</p><ul><li>如果该文件已存在，新的内容会写入已有文件之后</li><li>如果文件不存在，创建新文件写入</li></ul><h1 id="read-方法"><a href="#read-方法" class="headerlink" title="read()方法"></a>read()方法</h1><p>文件对象.read(num)</p><p>num表示要从文件中读取的数据的长度(单位是字节)，如果没传入num，那么表示读取文件中所有的数据</p><p>如果之前已经调用一次，下次调用的起点为上次调用的终点</p><h1 id="readlines-方法"><a href="#readlines-方法" class="headerlink" title="readlines()方法"></a>readlines()方法</h1><p>readlines可以按照行的方式把文件中的内容进行一次性的读取，并且返回的是一个列表，每一行的数据为一个元素</p><h1 id="readline-方法"><a href="#readline-方法" class="headerlink" title="readline()方法"></a>readline()方法</h1><p>一次只读取一行内容</p><h1 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h1><p>for line in open(“.txt”,”r):</p><p>​print(line)</p><h1 id="文件关闭"><a href="#文件关闭" class="headerlink" title="文件关闭"></a>文件关闭</h1><p>sleep()</p><p>让文件暂停执行，单位为秒</p><p>close()</p><p>关闭文件</p><h1 id="with-open"><a href="#with-open" class="headerlink" title="with open"></a>with open</h1><p>格式</p><p>with open() as 文件名</p><p>​行为</p><p>结尾会自动执行close来防止遗忘</p><h1 id="写出操作"><a href="#写出操作" class="headerlink" title="写出操作"></a>写出操作</h1><p>f &#x3D; open(“D:&#x2F;测试.txt”,“<code>w</code>”,encoding&#x3D;“UTF-8”)</p><h2 id="write"><a href="#write" class="headerlink" title="write()"></a>write()</h2><p>f.write()</p><p>这个并不算真正的写入，而是把要写入的内容放到一块内存中，下面的flush()才算真正写入</p><h2 id="flush"><a href="#flush" class="headerlink" title="flush()"></a>flush()</h2><p>f.flush()</p><h1 id="追加写入操作"><a href="#追加写入操作" class="headerlink" title="追加写入操作"></a>追加写入操作</h1><p>f &#x3D; open(“D:&#x2F;测试.txt”,“<code>a</code>”,encoding&#x3D;“UTF-8”)</p><p>操作同写出操作</p><p>s</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据容器</title>
      <link href="/2025/07/01/Python/%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8/"/>
      <url>/2025/07/01/Python/%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="list列表"><a href="#list列表" class="headerlink" title="list列表"></a>list列表</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>变量名 &#x3D; [ 元素 ]</p><p>也可以嵌套</p><p>[ [ 123 ] , [ 456 ] ]</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>跟java一样，从0开始</p><p>也可以反向索引：-5 -4 -3 -2 -1</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>列表.index(查找元素)，会返回其下标</p><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>列表[下标] &#x3D; 值</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>列表.insert(下标，元素)，在指定的下标插入指定的元素</p><h2 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h2><ol><li><p>列表.append(元素)，将指定元素追加到列表的尾部</p></li><li><p>列表.extend(其他数据容器)，将其他数据容器中的元素取出，依次追加到列表尾部</p></li></ol><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><ol><li>del 列表[下标]</li><li>列表.pop(下标)，可以返回被删除的元素</li><li>列表.remove(元素),删除某元素在列表中的第一个匹配项</li></ol><h2 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h2><p>列表.clear()</p><h2 id="统计某元素在列表中的数量"><a href="#统计某元素在列表中的数量" class="headerlink" title="统计某元素在列表中的数量"></a>统计某元素在列表中的数量</h2><p>列表.count(元素)</p><h2 id="统计列表中有多少个元素"><a href="#统计列表中有多少个元素" class="headerlink" title="统计列表中有多少个元素"></a>统计列表中有多少个元素</h2><p>len(列表)</p><h1 id="tuple元组"><a href="#tuple元组" class="headerlink" title="tuple元组"></a>tuple元组</h1><p>元组用<code>()</code>，用<code>,</code>隔开，可以收集不同类型的数据</p><p>也可以嵌套</p><p>方法 index(),len(),count()同list</p><p><code>注</code>：元组的元素无法修改，但嵌套一个list则可以修改</p><h1 id="str字符串"><a href="#str字符串" class="headerlink" title="str字符串"></a>str字符串</h1><h2 id="索引-同list"><a href="#索引-同list" class="headerlink" title="索引(同list)"></a>索引(同list)</h2><p>跟java一样，从0开始</p><p>也可以反向索引：-5 -4 -3 -2 -1</p><p><code>注</code>：字符串的元素无法修改</p><h2 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h2><p>字符串.index(查找的字符串)，会返回其起始下标</p><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>字符串.replace(字符串1，字符串2)</p><p>把<code>所有的</code>字符串1替换为字符串2(无论有多少个)</p><p><code>注</code>：不是修改字符串，而是创建了一个新的字符串</p><h2 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h2><p>字符串.split(分隔符字符串)</p><p>按照指定的分隔符字符串，将字符串分为多个字符串，并返回一个list</p><h2 id="规整"><a href="#规整" class="headerlink" title="规整"></a>规整</h2><ul><li>字符串.strip() 去前后空格</li><li>字符串.strip(字符串) 去前后指定字符串( 此字符串不按顺序，例如传入‘12’，会判定为1和2)</li></ul><h2 id="字符串出现的次数"><a href="#字符串出现的次数" class="headerlink" title="字符串出现的次数"></a>字符串出现的次数</h2><p>字符串.count()</p><h2 id="字符串的长度"><a href="#字符串的长度" class="headerlink" title="字符串的长度"></a>字符串的长度</h2><p>len(字符串)</p><h1 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h1><p>是指内容有序，连续，可使用下标索引的一类数据容器</p><p>如list，tuple，str都是</p><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>序列[起始下标：结束下标：步长]</p><p>从一个序列中，取出一个子序列</p><p><code>注</code>：序列本身不会受影响，而是生成新的序列</p><h1 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>用<code>&#123;&#125;</code>表示</p><p>不允许重复</p><h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><p>set.add()</p><h2 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h2><p>ser.remove()</p><h2 id="随机取出一个元素"><a href="#随机取出一个元素" class="headerlink" title="随机取出一个元素"></a>随机取出一个元素</h2><p>set.pop()</p><h2 id="清空集合"><a href="#清空集合" class="headerlink" title="清空集合"></a>清空集合</h2><p>set.clear()</p><h2 id="取两个集合的差集"><a href="#取两个集合的差集" class="headerlink" title="取两个集合的差集"></a>取两个集合的差集</h2><p>set1.difference(set2)</p><p>也就是set1有而set2没有的</p><h2 id="消除两个集合的差集"><a href="#消除两个集合的差集" class="headerlink" title="消除两个集合的差集"></a>消除两个集合的差集</h2><p>set1.difference_update(set2)</p><p>在set1内删除与set2相同的元素</p><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>set1.union(set2)</p><p><code>注</code>：有重复的元素会去重</p><h2 id="统计数量"><a href="#统计数量" class="headerlink" title="统计数量"></a>统计数量</h2><p>len(set)</p><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>就跟java中的双列集合差不多，由key和value组成，元素是一个个键值对</p><p><code>定义</code></p><ol><li>my_dict &#x3D; {}</li><li>my_dict &#x3D; dict()</li></ol><h2 id="基于key获得value"><a href="#基于key获得value" class="headerlink" title="基于key获得value"></a>基于key获得value</h2><p>mydict[“key”]</p><p>当然也可以嵌套，格式为：mydict【】【】…</p><h2 id="添加-更新"><a href="#添加-更新" class="headerlink" title="添加&#x2F;更新"></a>添加&#x2F;更新</h2><p>字典[key] &#x3D; value</p><h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><p>字典pop(key)</p><h2 id="清空-1"><a href="#清空-1" class="headerlink" title="清空"></a>清空</h2><p>mydict.clear()</p><h2 id="获取所有的key"><a href="#获取所有的key" class="headerlink" title="获取所有的key"></a>获取所有的key</h2><p>字典.keys()</p><h2 id="获取元素数量"><a href="#获取元素数量" class="headerlink" title="获取元素数量"></a>获取元素数量</h2><p>len(mydict)</p><h1 id="通用功能"><a href="#通用功能" class="headerlink" title="通用功能"></a>通用功能</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/picture%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8.png" alt="image-20250701172245025"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>函数</title>
      <link href="/2025/06/30/Python/%E5%87%BD%E6%95%B0/"/>
      <url>/2025/06/30/Python/%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>格式</p><p>def 函数名(传入参数):</p><p>​函数体</p><p>​return 返回值</p><p>若想把真假互换，可以用<code>not</code></p><h1 id="说明文档"><a href="#说明文档" class="headerlink" title="说明文档"></a>说明文档</h1><p>用“”“</p><p>  ”“”</p><p>可以显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def p(x,y):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    :param x:1111</span><br><span class="line">    :param y:1111</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    print(f&quot;&#123;x&#125;,&#123;y&#125;&quot;)</span><br></pre></td></tr></table></figure><h1 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h1><h2 id="多种返回值"><a href="#多种返回值" class="headerlink" title="多种返回值"></a>多种返回值</h2><p>def test():</p><p>​return 1,2,3</p><p>i,j,k &#x3D; test()</p><h2 id="关键字传参"><a href="#关键字传参" class="headerlink" title="关键字传参"></a>关键字传参</h2><p>def test(name,age,gender):</p><p>​……</p><p>test(name&#x3D;“…”,age&#x3D;…,gender&#x3D;“…”)</p><p>也可以打乱顺序</p><p>test(age&#x3D;…,name&#x3D;“…”,gender&#x3D;“…”)</p><h2 id="位置传递"><a href="#位置传递" class="headerlink" title="位置传递"></a>位置传递</h2><p>def test(*args):</p><p>​print(args)</p><p>传递的参数会被args收集，并合并为tuple </p><h2 id="关键字传递"><a href="#关键字传递" class="headerlink" title="关键字传递"></a>关键字传递</h2><p>def test(**kwargs):</p><p>​print(kwargs)</p><p>参数是<code>键=值</code>的情况下，会被kwargs接受，并合并为dict</p><h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><p>lambda 传入参数： 函数体(一行代码)</p><p>可以让只使用一次的函数写法更简便</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>循环</title>
      <link href="/2025/06/29/Python/%E5%BE%AA%E7%8E%AF/"/>
      <url>/2025/06/29/Python/%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h1><p>格式：</p><p>while 条件：</p><p>​条件满足时做的事情</p><h1 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h1><p>for 临时变量 in 待处理数据集：</p><p>​条件满足时做的事情</p><p>意思是：获取待处理数据集中的每个字符赋值给临时变量，由临时变量输出</p><h1 id="range语法"><a href="#range语法" class="headerlink" title="range语法"></a>range语法</h1><h2 id="range-num"><a href="#range-num" class="headerlink" title="range(num)"></a>range(num)</h2><p>获取从零开始，到num结束的数字序列(不包含num本身)</p><p>如：range(3) 输出 –[0，1,2]</p><h2 id="range-num1-num2"><a href="#range-num1-num2" class="headerlink" title="range(num1,num2)"></a>range(num1,num2)</h2><p>获取从num1开始，到num2结束的数字序列(不包含num2本身)</p><h2 id="range-num1-num2-step"><a href="#range-num1-num2-step" class="headerlink" title="range(num1,num2,step)"></a>range(num1,num2,step)</h2><p>获取从num1开始，到num2结束的数字序列(不包含num2本身)</p><p>数据的步长由step决定</p><p>如：range(5,10,2) 输出 –[5,7,9]</p><p>​</p><h1 id="comtinue-break"><a href="#comtinue-break" class="headerlink" title="comtinue &amp; break"></a>comtinue &amp; break</h1><p><code>continue</code>：中断本次循环，直接进入下一个循环</p><p><code>break</code>: 直接结束循环</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法讲解</title>
      <link href="/2025/06/23/Markdown/%E8%AF%AD%E6%B3%95%E8%AE%B2%E8%A7%A3/"/>
      <url>/2025/06/23/Markdown/%E8%AF%AD%E6%B3%95%E8%AE%B2%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><p><img src="https://github.com/XiDongWe/Picture/blob/5d842e80de17913ec81efa81b4df2fe509f7fdf3/picture%E9%A3%8E%E6%99%AF-%E4%BA%912.jpg"></p><h1 id="2-强调"><a href="#2-强调" class="headerlink" title="2.强调"></a>2.强调</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*斜体*  或   _斜体_</span><br><span class="line">**加粗**  或   __加粗__</span><br><span class="line">***斜体加加粗***  或   ___斜体加加粗___</span><br></pre></td></tr></table></figure><p>效果</p><p><em>斜体</em><br><strong>加粗</strong><br><em><strong>斜体加加粗</strong></em>  </p><h1 id="3-列表"><a href="#3-列表" class="headerlink" title="3.列表"></a>3.列表</h1><p><strong>无序列表</strong>：用 - * +作为标识符</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-标题一</span><br><span class="line"> -1</span><br><span class="line"> -2</span><br><span class="line">-标题二</span><br></pre></td></tr></table></figure><ul><li><p>标题一</p><ul><li>1<ul><li>2</li></ul></li></ul></li><li><p>标题二</p></li></ul><p><strong>有序列表</strong>:数字加.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. qqq</span><br><span class="line"> 1. eee</span><br><span class="line"> 2. fdg</span><br><span class="line">2. afd</span><br></pre></td></tr></table></figure><ol><li><p>qqq</p><ol><li>ee</li><li>fdg</li></ol></li><li><p>afd</p></li></ol><h1 id="4-链接"><a href="#4-链接" class="headerlink" title="4.链接"></a>4.链接</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[链接文本](链接地址)</span><br><span class="line">[bilbil](https://www.bilibili.com/)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果加提示词的话</span><br><span class="line">[链接文本](链接地址 &quot;提示词&quot;)</span><br><span class="line">[bilbil](https://www.bilibili.com/ &quot;哔哩哔哩&quot;) </span><br></pre></td></tr></table></figure><p>效果</p><p><a href="https://www.bilibili.com/">bilbil</a></p><p><a href="https://www.bilibili.com/" title="哔哩哔哩">bilbil</a> </p><h1 id="5-图片"><a href="#5-图片" class="headerlink" title="5.图片"></a>5.图片</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![图片描述](图片地址)</span><br><span class="line">或者直接粘贴也行  </span><br></pre></td></tr></table></figure><p><img src="/%E5%9B%BE%E7%89%87/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E6%97%A5%E5%A5%88.webp"></p><h1 id="6-引用"><a href="#6-引用" class="headerlink" title="6.引用"></a>6.引用</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是引用</span><br><span class="line">&gt;&gt;这是嵌套引用</span><br></pre></td></tr></table></figure><blockquote><p>这是引用</p><blockquote><p>这是嵌套引用</p></blockquote></blockquote><h1 id="7-代码块"><a href="#7-代码块" class="headerlink" title="7.代码块"></a>7.代码块</h1><p><strong>行内代码</strong>用(&#96;&#96;)表示</p><p>演示：<code>111</code></p><p><strong>代码块</strong>用(&#96;&#96;&#96;)表示</p><h1 id="8-表格-idea用不了"><a href="#8-表格-idea用不了" class="headerlink" title="8.表格(idea用不了)"></a>8.表格(idea用不了)</h1><p>用 <code>|</code> 和 <code>-</code> 表示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">| 1.1 | 1.2 | 1.3 |</span><br><span class="line">|————|————|————|</span><br><span class="line">| 1.1 | 1.2 | 1.3 |</span><br><span class="line">| 1.1 | 1.2 | 1.3 |</span><br><span class="line">或者直接右键创建</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="9-分割线-idea用不了"><a href="#9-分割线-idea用不了" class="headerlink" title="9.分割线(idea用不了)"></a>9.分割线(idea用不了)</h1><p>使用三个或更多的 <code>-</code> <code>*</code> <code>__</code></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>逻辑判断</title>
      <link href="/2025/06/17/Python/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/"/>
      <url>/2025/06/17/Python/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="布尔bool"><a href="#布尔bool" class="headerlink" title="布尔bool"></a>布尔bool</h1><p>字面量</p><ul><li>True</li><li>Flase</li></ul><h1 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/picture95.png" alt="image-20250629161640995"></p><h1 id="if判断语句"><a href="#if判断语句" class="headerlink" title="if判断语句"></a>if判断语句</h1><p><code>格式</code></p><p>if 要判断的条件：</p><p>   条件成立时要做的事情</p><h2 id="if-lese语句"><a href="#if-lese语句" class="headerlink" title="if-lese语句"></a>if-lese语句</h2><p>if 要判断的条件：</p><p>   条件成立时要做的事情</p><p>else ：</p><p>   条件成立时要做的事情</p><h2 id="if-elif-else语句"><a href="#if-elif-else语句" class="headerlink" title="if-elif-else语句"></a>if-elif-else语句</h2><p>if 条件1：</p><p>   条件成立时要做的事情</p><p>elif 条件2：</p><p>   条件成立时要做的事情</p><p>else ：</p><p>   条件成立时要做的事情</p><h1 id="random"><a href="#random" class="headerlink" title="random"></a>random</h1><p>import random</p><p>num &#x3D; random.randint(e1,e2)</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python初学</title>
      <link href="/2025/06/17/Python/%E8%87%AA%E5%8F%98%E9%87%8F/"/>
      <url>/2025/06/17/Python/%E8%87%AA%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="自变量"><a href="#自变量" class="headerlink" title="自变量"></a>自变量</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/picture%E8%87%AA%E5%8F%98%E9%87%8F1" alt="image-20250627092001380"></p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><ul><li>单行注释</li></ul><p>以<code>#</code>开头（建议#与注释的内容空一格）</p><ul><li>多行注释</li></ul><p>以<code>&quot;&quot;&quot;</code>开头和结尾</p><h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><p>print(“”,数字等自变量,“”)</p><p>(<code>不用引号居然</code>)</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>print(type(想要知道数据类型的数据))</p><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/picture%E8%87%AA%E5%8F%98%E9%87%8F2" alt="image-20250627100012737"></p><h1 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h1><ul><li>内容限定</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/picture%E8%87%AA%E5%8F%98%E9%87%8F3" alt="image-20250627100731539"></p><ul><li>大小写敏感</li><li>不可使用关键字</li></ul><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/picture%E8%87%AA%E5%8F%98%E9%87%8F4.0" alt="image-20250627203436072"></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/picture%E8%87%AA%E5%8F%98%E9%87%8F5" alt="image-20250627204007157"></p><h1 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h1><p>我们输出print时候，可以用<code>+</code>把字符串连接起来输出，但是字符串不能跟其他类型的相连，并且当有很多变量时也很麻烦，所以可以用<code>字符串格式化</code>来解决</p><p>name &#x3D; “日奈”</p><p>teacher &#x3D; “永远喜欢 %s” % name</p><p>其中<code>%</code>表示我要占位，<code>S</code>表示将变量变成字符串放入占位的位置</p><p>这个方法可以将数字和其他类型的变量跟字符串一起连接</p><p>age &#x3D; 17</p><p>teacher &#x3D; “为师永远喜欢%s岁的 %s” % (age,name)&#x2F;&#x2F;顺序不能乱</p><p>当然也有其他类型的,例如<code>%d</code>对应整数,<code>%f</code>对应浮点型</p><h2 id="精度控制"><a href="#精度控制" class="headerlink" title="精度控制"></a>精度控制</h2><p><code>m</code>控制宽度,要求是数字，如%5d</p><p><code>.n</code>控制小数点精度，要求是数字，会对小数进行四舍五入，如%5.2d</p><h2 id="快速格式化"><a href="#快速格式化" class="headerlink" title="快速格式化"></a>快速格式化</h2><p>通过f“内容{变量}”实现</p><p>如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 4.572</span><br><span class="line">b = 8</span><br><span class="line">print(f&quot;&#123;a&#125;+&#123;b&#125; = &#123;a + b&#125;&quot;)</span><br></pre></td></tr></table></figure><h1 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h1><p>put &#x3D; input()</p><p>print(put)</p><p>其中在input的()中可以添加字符串，此字符串会出现在键盘输入的前面</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合进阶</title>
      <link href="/2025/06/17/JAVA/%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6/"/>
      <url>/2025/06/17/JAVA/%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><ol><li>创建对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt; String &gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><ol start="2"><li>添加</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.add(<span class="string">&quot;   &quot;</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>删除</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.remove(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">此处可以填具体存在的值或者是索引</span><br></pre></td></tr></table></figure><ol start="4"><li>修改</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.set( 索引, 要修改的值)</span><br></pre></td></tr></table></figure><ol start="5"><li>查询</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.get(索引)</span><br></pre></td></tr></table></figure><p>其中，如果想让另一个ArrayList复制一份，可以用ArrayList<E> newlist &#x3D; new ArrayList&lt;&gt;(list)实现</p><p><img src="/%E5%9B%BE%E7%89%87/JAVA/%E5%8D%95%E5%88%97%E9%9B%86%E5%90%881.png"></p><p>List系列集合:添加的元素是有序，可重复，有索引<br>有序：输入的和输出的是一样(即输入1,2,3，就输出1,2,3)<br>可重复：元素可重复<br>有索引：可以通过索引获取每个元素</p><p>Set系列集合：无序，不重复，没索引<br>无序：存和取的顺序有可能不同</p><h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p>因为Collection是一个接口，所以不能直接创建它的对象，因此只能创建实现类的对象ArrayList<br>Collection&lt; String &gt; coll &#x3D; new ArrayList&lt;&gt;();</p><h2 id="1-添加元素"><a href="#1-添加元素" class="headerlink" title="1.添加元素"></a>1.添加元素</h2><p>coll.add(“aaa”);</p><h2 id="2-清空元素"><a href="#2-清空元素" class="headerlink" title="2.清空元素"></a>2.清空元素</h2><p>coll.clear();</p><h2 id="3-删除元素"><a href="#3-删除元素" class="headerlink" title="3.删除元素"></a>3.删除元素</h2><p>coll.remove(“aaa”);</p><h2 id="4-判断元素是否包含"><a href="#4-判断元素是否包含" class="headerlink" title="4.判断元素是否包含"></a>4.判断元素是否包含</h2><p>boolean result &#x3D; coll.contains(“bbb”);</p><h2 id="5-判断是否为空"><a href="#5-判断是否为空" class="headerlink" title="5.判断是否为空"></a>5.判断是否为空</h2><p>boolean result2 &#x3D; coll.isEmpty();</p><h2 id="6-获取集合长度"><a href="#6-获取集合长度" class="headerlink" title="6.获取集合长度"></a>6.获取集合长度</h2><p>int s &#x3D; coll.size();</p><h1 id="通用遍历方式"><a href="#通用遍历方式" class="headerlink" title="通用遍历方式"></a>通用遍历方式</h1><h2 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a>迭代器遍历</h2><p>Iterator&lt; String &gt; it &#x3D; list.iterator();&#x2F;&#x2F;获取集合的零索引<br>boolean flag &#x3D; it.hasNext();&#x2F;&#x2F;判断当前位置是否有元素<br>String str &#x3D; it.next();&#x2F;&#x2F;获取当前元素，并把指针移到下一个位置</p><p>可以做出一个循环<br>Iterator&lt; String &gt; it &#x3D; list.iterator();<br>while(it.hasNext()){<br>  String str &#x3D; it.next();<br>  System.out.println(str);<br>}</p><h2 id="List特有的列表迭代器"><a href="#List特有的列表迭代器" class="headerlink" title="List特有的列表迭代器"></a>List特有的列表迭代器</h2><p>就是在原有的基础上可以添加和删除元素<br>ListIterator&lt; String &gt; it &#x3D; list.ListIterator&lt;&gt;();<br>while(it.hasNext()){<br>  String str &#x3D; it.next();<br>  if(“bbb”.equals(str)){<br>    it.add(“qqq”);<br>  }<br>  System.out.println(str);<br>}</p><h2 id="增强for"><a href="#增强for" class="headerlink" title="增强for"></a>增强for</h2><p>只有单列集合和数组才能用<br>格式：<br>for(元素的数据类型 变量名 ：数组或集合){</p><p>}</p><p>例如<br>for(String s : list){<br>  System.out.println(s);<br>}</p><p>快捷键：coll.for</p><h2 id="lambda表达式遍历"><a href="#lambda表达式遍历" class="headerlink" title="lambda表达式遍历"></a>lambda表达式遍历</h2><p>格式(采用匿名内部类的方法)：<br> coll.forEach(new Consumer&lt; String &gt;() {<br>           @Override<br>           public void accept(String s) {<br>               System.out.println(s);<br>           }<br>       });</p><p>其中源码为：<br><img src="/%E5%9B%BE%E7%89%87/JAVA/%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF1.png"><br>也就是说foreach就是普通的for循环，而通过重写accept来规定循环的内容</p><p>而lambda表达式遍历为：<br>coll.foreach(s -&gt; System.out.println(s));</p><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>格式：<br>() -&gt; {</p><p>}</p><p>例如：<br>Integer[] a &#x3D; {2,1,4,6,7,8,56,4,3};</p><pre><code>    Arrays.sort(a, new Comparator&lt;Integer&gt;() &#123;        @Override        public int compare(Integer o1, Integer o2) &#123;            return o1 - o2;        &#125;    &#125;);</code></pre><p>其中的匿名内部类可以简化成<br>Arrays.sort(a, (Integer o1, Integer o2) -&gt; {<br>                return o1 - o2;<br>            }<br>        );</p><p>注意：<br>lambda表达式只能用于匿名内部类和函数式接口(有且仅有一个抽象方法的接口)</p><h1 id="List特有的方法"><a href="#List特有的方法" class="headerlink" title="List特有的方法"></a>List特有的方法</h1><h2 id="1-创建集合"><a href="#1-创建集合" class="headerlink" title="1.创建集合"></a>1.创建集合</h2><p>List&lt; String &gt; list &#x3D; new ArrayList&lt;&gt;();</p><h2 id="2-添加元素"><a href="#2-添加元素" class="headerlink" title="2.添加元素"></a>2.添加元素</h2><p>list.add(“aaa”);<br>list.add(“bbb”);<br>list.add(“ccc”);</p><h2 id="3-在指定索引处添加元素"><a href="#3-在指定索引处添加元素" class="headerlink" title="3.在指定索引处添加元素"></a>3.在指定索引处添加元素</h2><p>void add(int index, E element)</p><p>list.add( 1, “qqq”);<br>会输出  aaa , qqq , bbb , ccc<br>也就是说在指定位置添加元素不会覆盖掉原来的元素，而是会往后挪</p><h2 id="4-删除指定索引处的元素，返回被删除的元素"><a href="#4-删除指定索引处的元素，返回被删除的元素" class="headerlink" title="4.删除指定索引处的元素，返回被删除的元素"></a>4.删除指定索引处的元素，返回被删除的元素</h2><p>E remove(int index) </p><p>String s &#x3D; ist.remove(0);</p><p>如果是Integer类型的，如<br>List&lt; Integer &gt; list &#x3D; new ArrayList&lt;&gt;();<br>list.add(1);<br>list.add(2);<br>list.add(3);</p><p>此时想把’1’去掉，我们可以想到用 list.remove(1);<br>但这个’1’在此代码的作用是去掉索引为1的元素，也就是2<br>原因：<br>当方法发生重载时，会优先调用实参和形参类型相同的那个<br>1是int类型，而index也是int类型，所以此处的1是索引</p><p>所以应该：<br>Integer i &#x3D; Integer.valueOf(1);<br>list.remove(i);</p><p>也就是把’1’转化为Integer类型</p><h2 id="5-修改索引处的元素，返回被修改的元素"><a href="#5-修改索引处的元素，返回被修改的元素" class="headerlink" title="5.修改索引处的元素，返回被修改的元素"></a>5.修改索引处的元素，返回被修改的元素</h2><p>E set(int index, E element)</p><h2 id="6-返回索引处的元素"><a href="#6-返回索引处的元素" class="headerlink" title="6.返回索引处的元素"></a>6.返回索引处的元素</h2><p>E get(int index)</p><h1 id="ArrayList底层逻辑"><a href="#ArrayList底层逻辑" class="headerlink" title="ArrayList底层逻辑"></a>ArrayList底层逻辑</h1><p><img src="/%E5%9B%BE%E7%89%87/JAVA/ArrayList%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%911.png"></p><h1 id="泛型深入"><a href="#泛型深入" class="headerlink" title="泛型深入"></a>泛型深入</h1><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>修饰符 class 类名 &lt;类型&gt;{</p><p>}</p><p>如：<br>public class ArrayList<E>{</p><p>}<br>其中“E”为任意字母，但通常是E</p><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>修饰符 &lt;类型&gt; 返回值类型 方法名 (类型 变量名){</p><p>}<br>如<br>public &lt; T &gt; void move(T t){</p><p>}</p><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>修饰符 interfere 接口名 &lt; E &gt;{</p><p>}</p><h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p>就是？<br>其中包含:<br>？extends E  表示传递E或E所有的子类型<br>？super   E  表示传递E或E所有的父类型</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p><a href="https://xidongwe.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></p><h1 id="Set系列"><a href="#Set系列" class="headerlink" title="Set系列"></a>Set系列</h1><p><code>特点</code></p><p>Set系列集合：无序，不重复，无索引</p><p>无序：存和取的顺序有可能不同</p><p>不重复：元素不可重复</p><p>无索引：不可以通过索引获取每个元素</p><ul><li>创建一个Set集合的对象</li></ul><p>Set&lt; String &gt; s &#x3D; new HashSet&lt;&gt;();</p><ul><li>添加元素</li></ul><p>s.add(“sss”);  &#x2F;&#x2F;第一次添加的时候成功，返回true</p><p>s.add(“sss”);  &#x2F;&#x2F;第二次添加的时候失败（因为元素不可重复），返回false</p><ul><li>打印元素（同List）<ul><li>迭代器遍历</li><li>增强for</li><li>lambda</li></ul></li></ul><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p><code>特点</code></p><p>无序，不重复，无索引</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/picture%E5%93%88%E5%B8%8C%E5%80%BC" alt="image-20250624195148210"></p><ul><li>创建对象</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student s1 = new Student(&quot;1&quot;,1);</span><br><span class="line">Student s2 = new Student(&quot;1&quot;,1);</span><br></pre></td></tr></table></figure><ul><li>如果没有重写hashCode方法的话，不同对象计算出的哈希值就不一样</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(s1.hashCode());</span><br><span class="line">System.out.println(s2.hashCode());</span><br></pre></td></tr></table></figure><p>重写的话就在Student类中按<code>alt</code>+<code>ins</code>，选择图上所示，之后next即可</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/picture%E5%93%88%E5%B8%8C%E5%80%BC2" alt="image-20250624200410429"></p><p>哈希碰撞的话<code>abc</code>和<code>acD</code>会出现</p><ul><li>HashSet底层逻辑</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureHashSet4" alt="image-20250624202533085"></p><ol><li>第一点中的<code>0.75</code>意思是：当数组中有16X0.75&#x3D;12个元素时，数组将扩容为原来的两倍，即变为24</li><li>第二点中数据的位置的计算公式为<code>int index = (数组长度 - 1) &amp; 哈希值;</code></li></ol><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><ul><li>LinkedHashSet底层逻辑</li></ul><p><code>特点</code></p><p>有序，不重复，无索引</p><p>（有序是因为有双链表）</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/picture%E5%93%88%E5%B8%8C%E5%80%BC5" alt="image-20250624204322908"></p><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p><code>规则</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureRedBlack2" alt="image-20250625101732136"></p><p>默认节点是红色的（效率高，因为调整的地方要少）</p><p>具体讲解跳转<a href="https://www.bilibili.com/video/BV17F411T7Ao?spm_id_from=333.788.videopod.episodes&vd_source=b0dff9885c076f5f4c78c1f99505a0cf&p=196">黑马</a></p><h1 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h1><p><code>特点</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureTreeSet1" alt="image-20250625090223814"></p><ul><li>创建TreeSet对象</li></ul><p>TreeSet&lt; Integer &gt; st &#x3D; new TreeSet&lt;&gt;();</p><ul><li>添加元素</li></ul><p>ts.add(3);</p><p>ts.add(1);</p><p>ts.add(2);</p><p>最后还是会按大小排序输出</p><ul><li><code>规则</code></li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureTreeSet2" alt="image-20250625092252732"></p><h2 id="比较方法"><a href="#比较方法" class="headerlink" title="比较方法"></a>比较方法</h2><ol><li><p>自然排序</p><p>在类（比如Student）实现Comparable接口，重写里面的抽象方法，在指定比较规则</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int compareTo(Student o) &#123;</span><br><span class="line">    return this.getAge() - o.getAge();（举的例子）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>比较器排序</p><p>创建TreeSet对象时，传递Comparator制定规则</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;String&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;String&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(String o1, String o2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其中<code>o1</code>表示当前要添加的元素，<code>o2</code>表示红黑树中已经存在都在的元素</p><h1 id="单列集合总结"><a href="#单列集合总结" class="headerlink" title="单列集合总结"></a>单列集合总结</h1><p>(<img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureRedBlack6" alt="image-20250625135242615">)</p><h1 id="双列集合"><a href="#双列集合" class="headerlink" title="双列集合"></a>双列集合</h1><ul><li>特点</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/picture%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%881" alt="image-20250626105055472"></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/picture%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%882" alt="image-20250626105249137"></p><h2 id="Map的常见API"><a href="#Map的常见API" class="headerlink" title="Map的常见API"></a>Map的常见API</h2><p>Map是双列集合的顶层接口，他的功能是双列集合都可以继承使用的</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/picture%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%883" alt="image-20250626105738348"></p><ul><li>创建Map集合对象Map&lt;String,String&gt; m &#x3D; new HashMap&lt;&gt;();</li></ul><p>其中添加元素时</p><ol><li>如果键不存在,会直接把键值对对象添加到Map集合当中</li><li>如果键存在，会把原有的键值对对象覆盖，把被覆盖的键值对对象返回</li></ol><h1 id="Map的遍历方法"><a href="#Map的遍历方法" class="headerlink" title="Map的遍历方法"></a>Map的遍历方法</h1><h2 id="键找值"><a href="#键找值" class="headerlink" title="键找值"></a>键找值</h2><ul><li>获取所有的键，把这些键放到一个单列集合当中</li></ul><p>Set<String> keys &#x3D; m.keySet();</p><ul><li>遍历单列集合，获取每一个键</li></ul><p>for (String key : keys) {<br>    System.out.println(key);</p><p>​    &#x2F;&#x2F;利用Map集合的键获取对应的值</p><p>​    String value &#x3D; m.get(key);</p><p>​    System.out.println(key+”&#x3D;”+value);</p><p>}</p><h2 id="键值对对象遍历"><a href="#键值对对象遍历" class="headerlink" title="键值对对象遍历"></a>键值对对象遍历</h2><ul><li>通过一个方法获取所有的键值对对象，返回一个Set集合</li></ul><p>Set&lt;Map.Entry&lt;String, String&gt;&gt; e &#x3D; m.entrySet();</p><ul><li>遍历e这个集合，获取每一个键值对对象</li></ul><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><ul><li>匿名内部类为</li></ul><p>m.forEach(new BiConsumer&lt;String, String&gt;() {<br>    @Override<br>    public void accept(String s, String s2) {<br>        System.out.println(s+s2);<br>    }<br>})；</p><ul><li>Lambda表达式为</li></ul><p>m.forEach((s,s2) -&gt; System.out.println(s+s2));</p><p><code>foreach底层</code></p><p>其实就是调用第二种方法，获取每一个key和value，在调用accept方法</p><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p><code>特点</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/picture%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%884" alt="image-20250626140802961"></p><h1 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h1><ul><li>由键决定：有序，不重复，无索引</li><li><code>原理</code>：底层数据结构依然是哈希表，只是多了个双链表</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250707110520535.png" alt="image-20250707110520535"></p><h1 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h1><ul><li>与TreeSet一样，都是红黑树结构</li><li>对键进行排序，默认从小到大，也可以自己修改排序规则</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;Character,Integer&gt; tm = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Character&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Character o1, Character o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>或者</p><p>在类中传入接口Comparable</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250707145132266.png" alt="image-20250707145132266"></p><p>再alt+enter修改</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250707145327692.png" alt="image-20250707145327692"></p><h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><p>当执行某个函数的时候，因为不清楚所需参数的多少，所以可以用可变参数</p><p><code>格式</code>:</p><p>public static 类型 函数名(E…参数名(一般为args)){</p><p>}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">        System.out.println(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>...i)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum_</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : i) &#123;</span><br><span class="line">            sum_ += j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>细节</code>：</p><ol><li>方法中的形参中可变参数只能有一个</li><li>如果有其他的参数，可变参数要写在最后</li></ol><h1 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h1><p>Collections不是集合，而是集合的工具类</p><p>工具类的特点：直接<code>名称.</code>即可调用方法</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250707173047469.png" alt="image-20250707173047469"></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2025/06/16/JAVA/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2025/06/16/JAVA/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="1-正则表达式"><a href="#1-正则表达式" class="headerlink" title="1.正则表达式"></a>1.正则表达式</h1><p>用.matches，返回boolean<br><img src="/%E5%9B%BE%E7%89%87/JAVA/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F1.png"><br><img src="/%E5%9B%BE%E7%89%87/JAVA/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F2.png"><br><img src="/%E5%9B%BE%E7%89%87/JAVA/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F3.png"></p><p>正则表达式是从左往右检查的，且一个[]只对应一个字符<br>如:   “a”.matches(“[abc]”)   为 true, 但”ab”.matches(“[abc]”)为false，因为”b”无法判断</p><h1 id="2-爬虫"><a href="#2-爬虫" class="headerlink" title="2.爬虫"></a>2.爬虫</h1><p>假如有一段字符串<br>String str &#x3D; “ Java自从95年问世以来，经历了很多版本，目前企业中用的最多的是Java8和Java11, “ +<br>“因为这两个是长期支持版本，下一个长期支持版本是Java17，相信在未来不久Java17也会逐渐登上历史舞台“；”<br>要找出里面所有的JAVAXX</p><p>方法:<br>&#x2F;&#x2F;获取正则表达式的对象<br>Pattern p &#x3D; Pattern.compile(“JAVA\d{0,2}”);</p><p>&#x2F;&#x2F;再获取文本匹配器的对象<br>Matcher m &#x3D; p.matcher(str);</p><p>&#x2F;&#x2F;之后文本匹配器会从头开始检查时候符合，符合的话返回true，反之返回false】<br>boolean b &#x3D; m.find();</p><p>&#x2F;&#x2F;find会把符合的字符串进行截取<br>String s &#x3D; m.group();</p><p>&#x2F;&#x2F;但这样只能返回一次，所以我们可以用循环<br>while(m.fine()) {<br>    String s &#x3D; m.group();<br>    System.out.println(s);<br>}</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2025/05/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/"/>
      <url>/2025/05/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>冒泡排序<br><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span> </span>&#123;  <span class="comment">// 冒泡排序法，添加数组长度参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j - <span class="number">1</span>] &gt; a[j]) &#123;</span><br><span class="line">                <span class="type">int</span> t = a[j - <span class="number">1</span>];</span><br><span class="line">                a[j - <span class="number">1</span>] = a[j];</span><br><span class="line">                a[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArr</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span> </span>&#123;    <span class="comment">// 添加数组长度参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)   <span class="comment">// 修正循环条件</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123; <span class="number">23</span>,<span class="number">54</span>,<span class="number">12</span>,<span class="number">67</span>,<span class="number">879</span>,<span class="number">567</span>,<span class="number">435</span>,<span class="number">45</span>,<span class="number">32</span>,<span class="number">4</span>,<span class="number">54</span>,<span class="number">345</span> &#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(a[<span class="number">0</span>]);  <span class="comment">// 计算数组长度</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">BubbleSort</span>(a, n);      <span class="comment">// 传递数组和长度</span></span><br><span class="line">    <span class="built_in">printArr</span>(a, n);        <span class="comment">// 传递数组和长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>快速排序<br>定义开头的[0]为left,定义[n]为right,定义[0]为标准<br>原理:<br>通过left和right与标准的不断对比和移动，最后使得标准的左侧都比标准小，右侧都比标准大<br><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FastSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> boss = a[left];       <span class="comment">// 选择基准值</span></span><br><span class="line">        <span class="type">int</span> hole = left;          <span class="comment">// 孔位初始指向第一个元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 从右向左查找小于基准值的元素</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt;= boss) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            a[hole] = a[right];</span><br><span class="line">            hole = right;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从左向右查找大于基准值的元素</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt;= boss) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            a[hole] = a[left];</span><br><span class="line">            hole = left;</span><br><span class="line">        &#125;</span><br><span class="line">        a[hole] = boss; <span class="comment">// 将基准值放到中间位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归对左右两部分排序</span></span><br><span class="line">        <span class="built_in">FastSort</span>(a, <span class="number">0</span>, hole - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">FastSort</span>(a, hole + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123; <span class="number">4</span>, <span class="number">3</span>, <span class="number">30</span>, <span class="number">45</span>, <span class="number">54</span>, <span class="number">54</span>, <span class="number">67</span>, <span class="number">213</span>, <span class="number">435</span>, <span class="number">567</span>, <span class="number">879</span>, <span class="number">345</span> &#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">FastSort</span>(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">p</span>(a, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接插入排序<br>循环开始：从数组的第二个元素（索引为1）开始，因为单个元素本身就是有序的。<br>保存当前元素：将当前元素arr[i]保存到key中。<br>比较和移动：将key与前面已排序部分的元素进行比较，如果前面的元素大于key，则将该元素向后移动一位。<br>插入位置：找到第一个小于等于key的元素位置，将key插入到该位置。<br><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%9B%B4%E6%8E%A5%E6%8E%92%E5%BA%8F.gif"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123; <span class="comment">// 从数组的第二个元素开始循环</span></span><br><span class="line">        <span class="type">int</span> key = arr[i]; <span class="comment">// 将当前元素赋值给key</span></span><br><span class="line">        j = i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将比key大的元素都依次向后移动一位</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = key; <span class="comment">// 将key插入到正确的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123; <span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span> &#125;; <span class="comment">// 定义一个数组</span></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]); <span class="comment">// 计算数组的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">insertionSort</span>(arr, n); <span class="comment">// 调用排序函数对数组进行排序</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的数组: \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printArray</span>(arr, n); <span class="comment">// 打印排序后的数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>希尔排序<br><video src="/图片/数据结构/希尔排序.mp4" controls="controls" width="100%"></video></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> gap = n / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (gap &gt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; n; i++) &#123;</span><br><span class="line"><span class="type">int</span> temp = a[i];</span><br><span class="line"><span class="type">int</span> j = i;</span><br><span class="line"><span class="keyword">while</span>(j&gt;=gap &amp;&amp; a[j - gap] &gt; temp) &#123;</span><br><span class="line">a[j] = a[j - gap];</span><br><span class="line">j -= gap;</span><br><span class="line">&#125;</span><br><span class="line">a[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">gap /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">234</span>,<span class="number">5</span>,<span class="number">5678</span>,<span class="number">54</span>,<span class="number">68</span>,<span class="number">7</span>,<span class="number">546</span>,<span class="number">3</span>,<span class="number">42</span>,<span class="number">5</span>,<span class="number">789</span>,<span class="number">0</span> &#125;; <span class="comment">// 定义一个数组</span></span><br><span class="line"><span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]); <span class="comment">// 计算数组的长度</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">insert</span>(arr, n); <span class="comment">// 调用排序函数对数组进行排序</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;排序后的数组: \n&quot;</span>);</span><br><span class="line"><span class="built_in">printArray</span>(arr, n); <span class="comment">// 打印排序后的数组</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接选择排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> temp, min;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">min = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[j] &lt; a[min]) &#123;</span><br><span class="line">min = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">temp = a[i];</span><br><span class="line">a[i] = a[min];</span><br><span class="line">a[min] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">234</span>,<span class="number">5</span>,<span class="number">5678</span>,<span class="number">54</span>,<span class="number">68</span>,<span class="number">7</span>,<span class="number">546</span>,<span class="number">3</span>,<span class="number">42</span>,<span class="number">5</span>,<span class="number">789</span>,<span class="number">0</span> &#125;; <span class="comment">// 定义一个数组</span></span><br><span class="line"><span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]); <span class="comment">// 计算数组的长度</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">insert</span>(arr, n); <span class="comment">// 调用排序函数对数组进行排序</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;排序后的数组: \n&quot;</span>);</span><br><span class="line"><span class="built_in">printArray</span>(arr, n); <span class="comment">// 打印排序后的数组</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插帽龟，他很稳（插入，冒泡，归并）<br>插帽龟喜欢选帽插，插完就慌了（慌了&#x3D;方了，n的平方）<br>快龟堆，见到n老（nlog n）</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象进阶</title>
      <link href="/2025/05/09/JAVA/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/"/>
      <url>/2025/05/09/JAVA/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-static"><a href="#1-static" class="headerlink" title="1.static"></a>1.static</h1><p>在main中调用类名的方法时，其方法的对象可能是多个对象的共同对象<br>比如说创建了s1,s2两个学生对象，他们有共同的老师t，调用方法时老师是同一个<br>但如果不加static，t就需要被定义两次<br><img src="/%E5%9B%BE%E7%89%87/JAVA/static.png"><br>所以要用static<br><img src="/%E5%9B%BE%E7%89%87/JAVA/static1.png"><br>被static修饰的变量叫做 静态变量</p><h1 id="2-继承extends"><a href="#2-继承extends" class="headerlink" title="2.继承extends"></a>2.继承extends</h1><p>啥时候用继承？<br>当类与类之间，存在共性的的内容，并满足子类是父类的一种，就可以用继承</p><h1 id="3-多态"><a href="#3-多态" class="headerlink" title="3.多态"></a>3.多态</h1><p><img src="/%E5%9B%BE%E7%89%87/JAVA/%E5%A4%9A%E6%80%81.png"><br><img src="/%E5%9B%BE%E7%89%87/JAVA/%E5%A4%9A%E6%80%812.png"><br><img src="/%E5%9B%BE%E7%89%87/JAVA/%E5%A4%9A%E6%80%813.png"><br>创建完对象之后用:register(s)  register(t)   register(admin)调用即可</p><h1 id="4-包"><a href="#4-包" class="headerlink" title="4.包"></a>4.包</h1><p><img src="/%E5%9B%BE%E7%89%87/JAVA/%E5%8C%851.png"><br><img src="/%E5%9B%BE%E7%89%87/JAVA/%E5%8C%852.png"></p><h1 id="5-final"><a href="#5-final" class="headerlink" title="5.final"></a>5.final</h1><p><img src="/%E5%9B%BE%E7%89%87/JAVA/final1.png"><br>例子：<br>class Fu{<br>  public final void show(){<br>    ……<br>  }<br>}</p><h1 id="6-权限修饰符"><a href="#6-权限修饰符" class="headerlink" title="6.权限修饰符"></a>6.权限修饰符</h1><p><img src="/%E5%9B%BE%E7%89%87/JAVA/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A61.png"><br>(protected如同私生子)</p><h1 id="7-抽象类"><a href="#7-抽象类" class="headerlink" title="7.抽象类"></a>7.抽象类</h1><p>使用abstract后，必须重写</p><p>继承抽象类的解决方案：</p><ol><li>重写里面所有的方法</li><li>其子类也需要时抽象的，子类重写所有方法</li></ol><p><img src="/%E5%9B%BE%E7%89%87/JAVA/%E6%8A%BD%E8%B1%A1%E7%B1%BB1%C2%B7.png"></p><h1 id="8-接口"><a href="#8-接口" class="headerlink" title="8.接口"></a>8.接口</h1><p><img src="/%E5%9B%BE%E7%89%87/JAVA/%E6%8E%A5%E5%8F%A3.png"></p><h1 id="9-匿名内部类"><a href="#9-匿名内部类" class="headerlink" title="9.匿名内部类"></a>9.匿名内部类</h1><p>比如有个方法<br>public static void method(Animal a){<br>  a.eat;<br>}<br>按之前的方法，首先要创建一个Dog类，再在测试类中创建一个新的dog对象，再method(d)<br>但是如果只是用一次的话，中间的过程太过麻烦，所以可以用匿名内部类</p><p>method(<br>      new Animal() {<br>        public void eat() {<br>          System.out.println(“狗吃骨头”);<br>        }<br>      }</p><p>);</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>String</title>
      <link href="/2025/05/08/JAVA/String/"/>
      <url>/2025/05/08/JAVA/String/</url>
      
        <content type="html"><![CDATA[<h1 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h1><ol><li><p>创建对象<br>StringBuilder sb &#x3D; new StringBuilder();</p></li><li><p>添加元素append()<br>sb.append(1);<br>sb.append(dkjfak);</p></li><li><p>反转reverse()<br>sb.reverse();</p></li><li><p>获取长度length()<br>int len &#x3D; sb.length();</p></li><li><p>变回字符串toString()<br>(因为sb是StringBuilder类型的，并不是字符串)<br>String str &#x3D; sb.toString();</p></li></ol><h1 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a>StringJoiner</h1><p>可以拼接字符串<br>StringJoiner sj &#x3D; new StringJoiner(中间部分，起始部分，结尾部分);<br>sj.add(对象)</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>循环列表</title>
      <link href="/2025/05/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/"/>
      <url>/2025/05/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>#include&lt;stdio.h&gt;<br>#include&lt;stdlib.h&gt;<br>#define max 100<br>typedef int ElemType;</p><p>typedef struct QueueNode{<br>ElemType data;<br>struct QueueNode *next;<br>}QueueNode;</p><p>typedef struct{<br>QueueNode* front;<br>QueueNode* rear;<br>}Queue;</p><p>&#x2F;&#x2F;初始化<br>Queue* initQueueNode() {<br>QueueNode* node &#x3D; (QueueNode*)malloc(sizeof(QueueNode));&#x2F;&#x2F;node是头结点<br>Queue* q &#x3D; (Queue*)malloc(sizeof(Queue));<br>node-&gt;data &#x3D; 0;<br>node-&gt;next &#x3D; NULL;<br>q-&gt;front &#x3D; node;<br>q-&gt;rear &#x3D; node;<br>return q;<br>}</p><p>&#x2F;&#x2F;判断是否为空<br>int isEmpty(Queue* q) {<br>if (q-&gt;front &#x3D;&#x3D; q-&gt;rear) {<br>return 1;<br>}<br>else {<br>return 0;<br>}<br>}</p><p>&#x2F;&#x2F;入队<br>void inQueue(Queue *q, ElemType e) {<br>QueueNode <em>node &#x3D; (QueueNode</em>)malloc(sizeof(QueueNode));<br>node-&gt;data &#x3D; e;<br>node-&gt;next &#x3D; NULL;<br>q-&gt;rear-&gt;next &#x3D; node;&#x2F;&#x2F;把node赋给尾巴的下一个<br>q-&gt;rear &#x3D; node;&#x2F;&#x2F;      之后再让尾巴变成node<br>}</p><p>&#x2F;&#x2F;出队<br>int outQueue(Queue *q, ElemType *e) {<br>if (isEmpty(q)) {<br>printf(“空的”);<br>return 0;<br>}<br>QueueNode *node &#x3D; q-&gt;front-&gt;next;&#x2F;&#x2F;q-&gt;front指向头结点，node就是头结点的下一个节点<br>*e &#x3D; node-&gt;data;<br>q-&gt;front-&gt;next &#x3D; node-&gt;next;<br>if (q-&gt;rear &#x3D;&#x3D; node) {<br>q-&gt;rear &#x3D; q-&gt;front;<br>}<br>free(node);<br>return 1;<br>}</p><p>int main() {<br>Queue* q &#x3D; initQueueNode();<br>inQueue(q, 10);<br>inQueue(q, 20);<br>inQueue(q, 30);<br>ElemType e;<br>outQueue(q, &amp;e);<br>printf(“%d”, e);<br>return 0;<br>}</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>链队列</title>
      <link href="/2025/05/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E9%98%9F%E5%88%97/"/>
      <url>/2025/05/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E9%98%9F%E5%88%97.png"><br>#include&lt;stdio.h&gt;<br>#include&lt;stdlib.h&gt;<br>#define max 100<br>typedef int ElemType;</p><p>typedef struct QueueNode{<br>ElemType data;<br>struct QueueNode *next;<br>}QueueNode;</p><p>typedef struct{<br>QueueNode* front;<br>QueueNode* rear;<br>}Queue;</p><p>&#x2F;&#x2F;初始化<br>Queue* initQueueNode() {<br>QueueNode* node &#x3D; (QueueNode*)malloc(sizeof(QueueNode));&#x2F;&#x2F;node是头结点<br>Queue* q &#x3D; (Queue*)malloc(sizeof(Queue));<br>node-&gt;data &#x3D; 0;<br>node-&gt;next &#x3D; NULL;<br>q-&gt;front &#x3D; node;<br>q-&gt;rear &#x3D; node;<br>return q;<br>}</p><p>&#x2F;&#x2F;判断是否为空<br>int isEmpty(Queue* q) {<br>if (q-&gt;front &#x3D;&#x3D; q-&gt;rear) {<br>return 1;<br>}<br>else {<br>return 0;<br>}<br>}</p><p>&#x2F;&#x2F;入队<br>void inQueue(Queue *q, ElemType e) {<br>QueueNode <em>node &#x3D; (QueueNode</em>)malloc(sizeof(QueueNode));<br>node-&gt;data &#x3D; e;<br>node-&gt;next &#x3D; NULL;<br>q-&gt;rear-&gt;next &#x3D; node;&#x2F;&#x2F;把node赋给尾巴的下一个<br>q-&gt;rear &#x3D; node;&#x2F;&#x2F;      之后再让尾巴变成node<br>}</p><p>&#x2F;&#x2F;出队<br>int outQueue(Queue *q, ElemType *e) {<br>if (isEmpty(q)) {<br>printf(“空的”);<br>return 0;<br>}<br>QueueNode *node &#x3D; q-&gt;front-&gt;next;&#x2F;&#x2F;q-&gt;front指向头结点，node就是头结点的下一个节点<br>*e &#x3D; node-&gt;data;<br>q-&gt;front-&gt;next &#x3D; node-&gt;next;<br>if (q-&gt;rear &#x3D;&#x3D; node) {<br>q-&gt;rear &#x3D; q-&gt;front;<br>}<br>free(node);<br>return 1;<br>}</p><p>int main() {<br>Queue* q &#x3D; initQueueNode();<br>inQueue(q, 10);<br>inQueue(q, 20);<br>inQueue(q, 30);<br>ElemType e;<br>outQueue(q, &amp;e);<br>printf(“%d”, e);<br>return 0;<br>}</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>队列</title>
      <link href="/2025/05/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/"/>
      <url>/2025/05/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97.png"><br>队列是先进先出,像排队一样</p><p>#include&lt;stdio.h&gt;<br>#include&lt;stdlib.h&gt;<br>#define max 100<br>typedef int ElemType;</p><p>typedef struct {<br>ElemType* data;<br>int front;<br>int rear;<br>}Queue;</p><p>&#x2F;&#x2F;初始化<br>Queue* initQueue() {<br>Queue* q &#x3D; (Queue*)malloc(sizeof(Queue));<br>q-&gt;data &#x3D; (ElemType*)malloc(sizeof(ElemType));<br>q-&gt;front &#x3D; 0;<br>q-&gt;rear &#x3D; 0;<br>return q;<br>}</p><p>&#x2F;&#x2F;出队<br>ElemType outQueue(Queue* q) {<br>if (q-&gt;front &#x3D;&#x3D; q-&gt;rear) {<br>printf(“空的”);<br>return 0;<br>}<br>ElemType e &#x3D; q-&gt;data[q-&gt;front];<br>q-&gt;front++;<br>return e;<br>}</p><p>&#x2F;&#x2F;判断是否为满<br>int queueFull(Queue* q) {<br>if (q-&gt;front &gt; 0) {<br>int step &#x3D; q-&gt;front;<br>for (int i &#x3D; q-&gt;front; i &lt; q-&gt;rear; i++)<br>{<br>q-&gt;data[i - step] &#x3D; q-&gt;data[i];<br>}<br>q-&gt;front &#x3D; 0;<br>q-&gt;rear &#x3D; q-&gt;rear - step;<br>return 1;<br>}<br><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%85%A5%E9%98%9F.png"><br>else {<br>printf(“真的满了”);<br>return 0;<br>}<br>}</p><p>&#x2F;&#x2F;入队<br>int inQueue(Queue* q, ElemType e) {<br>if (q-&gt;rear &gt;&#x3D; max) {<br>if (!(queueFull))&#x2F;&#x2F;这时候判断是否真的满了<br>{<br>return 0;<br>}<br>}<br>q-&gt;data[q-&gt;rear] &#x3D; e;<br>q-&gt;rear++;<br>return 1;<br>}</p><p>&#x2F;&#x2F;循环队列-入队<br>int cycleIn(Queue* q, ElemType e) {<br>if ((q-&gt;rear + 1) % max &#x3D;&#x3D; q-&gt;front) {<br>printf(“满了”);<br>return 0;<br>}<br>q-&gt;rear &#x3D; (q-&gt;rear + 1) % max;<br>return 1;<br>}</p><p>int main() {<br>Queue* q &#x3D; initQueue();<br>inQueue(q, 10);<br>inQueue(q, 20);<br>inQueue(q, 30);<br>printf(“%d”, outQueue(q));<br>printf(“%d”, outQueue(q));</p><pre><code>return 0;</code></pre><p>}</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>栈</title>
      <link href="/2025/05/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/"/>
      <url>/2025/05/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88.png"><br>栈是后进先出，像弹夹一样</p><p>#include&lt;stdio.h&gt;<br>#include&lt;stdlib.h&gt;<br>#define max 100<br>typedef int ElemType;</p><p>typedef struct {<br>ElemType data[max];<br>int top;<br>}Stack;</p><p>&#x2F;&#x2F;初始化<br>void initStack(Stack* s) {<br>s-&gt;top &#x3D; -1;<br>}</p><p>&#x2F;&#x2F;压栈&#x2F;进栈<br>int push(Stack* s, ElemType e) {<br>if (s-&gt;top &gt;&#x3D; max - 1) {<br>printf(“满了\n”);<br>return 0;<br>}<br>s-&gt;top++;<br>s-&gt;data[s-&gt;top] &#x3D; e;<br>return 1;<br>}</p><p>&#x2F;&#x2F;出栈<br>int pop(Stack <em>s, ElemType</em> e){<br>if (s-&gt;top &#x3D;&#x3D; -1) {<br>printf(“空的”);<br>return 0;<br>}<br>*e &#x3D; s-&gt;data[s-&gt;top];<br>s-&gt;top–;<br>return 1;<br>}</p><p>int main() {<br>Stack s;<br>initStack(&amp;s);<br>push(&amp;s, 10);<br>push(&amp;s, 20);<br>push(&amp;s, 30);<br>ElemType e;<br>pop(&amp;s, &amp;e);<br>printf(“%d\n”, e);<br>return 0;<br>}</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>韩语基础篇</title>
      <link href="/2025/05/06/%E9%9F%A9%E8%AF%AD/%E9%9F%A9%E8%AF%AD%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
      <url>/2025/05/06/%E9%9F%A9%E8%AF%AD/%E9%9F%A9%E8%AF%AD%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>日常生活<br>单词:</p>]]></content>
      
      
      <categories>
          
          <category> 韩语 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>双向链表</title>
      <link href="/2025/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
      <url>/2025/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>#include&lt;stdio.h&gt;<br>#include&lt;stdlib.h&gt;<br>typedef int ElemType;</p><p>typedef struct node{<br>ElemType data;<br>struct node *prev, *next;</p><p>}Node;</p><p>&#x2F;&#x2F;初始化双向链表<br>Node* initNode() {<br>Node* head &#x3D; (Node*)malloc(sizeof(Node));<br>head-&gt;data &#x3D; 0;<br>head-&gt;prev &#x3D; NULL;<br>head-&gt;next &#x3D; NULL;<br>return head;<br>}</p><p>&#x2F;&#x2F;头插法<br>int insertHead(Node* L, ElemType e) {<br>Node* p &#x3D; (Node*)malloc(sizeof(Node));<br>p-&gt;data &#x3D; e;<br>p-&gt;prev &#x3D; L;<br>p-&gt;next &#x3D; L-&gt;next;<br>if (L-&gt;next !&#x3D; NULL) {<br>L-&gt;next-&gt;prev &#x3D; p;<br>}<br>L-&gt;next &#x3D; p;<br>return 1;<br>}</p><p>&#x2F;&#x2F;遍历<br>int listNode(Node* L) {<br>Node* p &#x3D; L-&gt;next;<br>while (p !&#x3D; NULL) {<br>printf(“%d  “, p-&gt;data);<br>p &#x3D; p-&gt;next;<br>}<br>printf(“\n”);<br>return 1;<br>}</p><p>&#x2F;&#x2F;获取尾部节点<br>Node* getTail(Node* L) {<br>Node* p &#x3D; L;<br>while (p-&gt;next !&#x3D; NULL) {<br>p &#x3D; p-&gt;next;<br>}<br>return p;<br>}</p><p>&#x2F;&#x2F;尾插法<br>Node* insertTail(Node* tail, ElemType e) {<br>Node* p &#x3D; (Node*)malloc(sizeof(Node));<br>p-&gt;data &#x3D; e;<br>p-&gt;prev &#x3D; tail;<br>tail-&gt;next &#x3D; p;<br>p-&gt;next &#x3D; NULL;<br>return p;<br>}</p><p>&#x2F;&#x2F;指定位置插入<br>void insertNode(Node* L, int pos, ElemType e) {<br>Node* p &#x3D; L;<br>int i &#x3D; 0;<br>while (i &lt; pos - 1) {<br>p &#x3D; p-&gt;next;<br>i++;<br>}<br>Node* q &#x3D; (Node*)malloc(sizeof(Node));<br>q-&gt;data &#x3D; e;<br>q-&gt;prev &#x3D; p;<br>q-&gt;next &#x3D; p-&gt;next;<br>p-&gt;next &#x3D; q;<br>p-&gt;next-&gt;prev &#x3D; q;<br>}</p><p>&#x2F;&#x2F;删除节点<br>int deleteNode(Node* L, int pos) {<br>Node* p &#x3D; L;<br>int i &#x3D; 0;<br>while (i &lt; pos - 1) {<br>p &#x3D; p-&gt;next;<br>i++;<br>if (p &#x3D;&#x3D; NULL){<br>return 0;<br>}<br>}<br>Node* q &#x3D; p-&gt;next;<br>p-&gt;next &#x3D; q-&gt;next;<br>q-&gt;next-&gt;prev &#x3D; p;<br>free(q);<br>return 1;<br>}</p><p>int main() {<br>Node* list &#x3D; initNode();<br>&#x2F;<em>insertHead(list, 1);<br>insertHead(list, 2);<br>insertHead(list, 3);</em>&#x2F;<br>Node* tail &#x3D; getTail(list);<br>tail &#x3D; insertTail(tail, 1);<br>tail &#x3D; insertTail(tail, 2);<br>tail &#x3D; insertTail(tail, 3);<br>listNode(list);<br>insertNode(list, 2, 6);<br>listNode(list);<br>deleteNode(list, 3);<br>listNode(list);<br>return 0;<br>}</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2025/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/"/>
      <url>/2025/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>#include&lt;stdio.h&gt;<br>#include&lt;stdlib.h&gt;<br>typedef int ElemType;<br>typedef struct node {<br>ElemType data;<br>struct node* next;<br>}Node;</p><p>Node* initList() {<br>Node* head &#x3D; (Node*)malloc(sizeof(Node));<br>head-&gt;data &#x3D; 0;<br>head-&gt;next &#x3D; NULL;<br>return head;<br>}</p><p>&#x2F;&#x2F;头插法<br>int insertHead(Node* L, ElemType e)&#x2F;&#x2F;L为头结点<br>{<br>Node* p &#x3D; (Node*)malloc(sizeof(Node));<br>p-&gt;data &#x3D; e;<br>p-&gt;next &#x3D; L-&gt;next;<br>L-&gt;next &#x3D; p;<br>return 1;<br>}</p><p>&#x2F;&#x2F;遍历<br>int listNode(Node* L) {<br>Node* p &#x3D; L-&gt;next;<br>while (p !&#x3D; NULL) {<br>printf(“%d  “, p-&gt;data);<br>p &#x3D; p-&gt;next;<br>}<br>printf(“\n”);<br>return 1;<br>}</p><p>&#x2F;&#x2F;获取尾部节点<br>Node* getTail(Node* L) {<br>Node* p &#x3D; L;<br>while (p-&gt;next !&#x3D; NULL) {<br>p &#x3D; p-&gt;next;<br>}<br>return p;<br>}</p><p>&#x2F;&#x2F;尾插法<br>Node* insertTail(Node* tail, ElemType e) {<br>Node* p &#x3D; (Node*)malloc(sizeof(Node));<br>p-&gt;data &#x3D; e;<br>tail-&gt;next &#x3D; p;<br>p-&gt;next &#x3D; NULL;<br>return p;<br>}</p><p>&#x2F;&#x2F;在指定位置插入<br>int insertNode(Node* L, int pos, ElemType e) {<br>Node* p &#x3D; L;<br>int i &#x3D; 0;<br>while (i &lt; pos - 1) {<br>p &#x3D; p-&gt;next;<br>i++;<br>if (p &#x3D;&#x3D; NULL) {<br>return 0;<br>}<br>}&#x2F;&#x2F;此时p为指定位置的前一个位置<br>Node* q &#x3D; (Node*)malloc(sizeof(Node));<br>q-&gt;data &#x3D; e;<br>q-&gt;next &#x3D; p-&gt;next;<br>p-&gt;next &#x3D; q;<br>return 1;<br>}</p><p>&#x2F;&#x2F;删除节点<br>int deleteNode(Node* L, int pos) {<br>Node* p &#x3D; L;<br>int i &#x3D; 0;<br>while (i &lt; pos - 1) {<br>p &#x3D; p-&gt;next;<br>i++;<br>if (p &#x3D;&#x3D; NULL) {<br>return 0;<br>}<br>}<br>Node* q &#x3D; p-&gt;next;<br>p-&gt;next &#x3D; q-&gt;next;<br>free(q);<br>return 1;<br>}</p><p>int main() {<br>Node* list &#x3D; initList();<br>Node* tail &#x3D; getTail(list);&#x2F;&#x2F;先找到尾结点<br>&#x2F;<em>insertHead(list, 10);<br>insertHead(list, 20);<br>insertHead(list, 30);</em>&#x2F;<br>tail &#x3D; insertTail(tail, 10);&#x2F;&#x2F;通过更新尾结点来持续进行尾插法<br>tail &#x3D; insertTail(tail, 20);<br>tail &#x3D; insertTail(tail, 30);<br>listNode(list);<br>insertNode(list, 2, 100);<br>listNode(list);<br>deleteNode(list, 3);<br>listNode(list);<br>return 0;<br>}</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>顺序表</title>
      <link href="/2025/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
      <url>/2025/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>#include&lt;stdio.h&gt;<br>#include&lt;stdlib.h&gt;<br>#define max 100<br>typedef int ElemType;</p><p>typedef struct {<br>    ElemType <em>data;<br>    int length;<br>}SeqList<br>;<br>&#x2F;&#x2F;初始化<br>SeqList</em> initList()<br>{<br>    SeqList* L &#x3D; (SeqList*)malloc(sizeof(SeqList));<br>    L-&gt;data &#x3D; (ElemType*)malloc(sizeof(ElemType) * max);<br>    L-&gt;length &#x3D; 0;<br>    return L;<br>}</p><p>&#x2F;&#x2F;在尾部添加数据<br>int appendElem(SeqList* L, ElemType e) {<br>    if (L-&gt;length &gt;&#x3D; max) {<br>        printf(“顺序表已满”);<br>        return 0;<br>    }<br>    L-&gt;data[L-&gt;length] &#x3D; e;<br>    L-&gt;length++;<br>    return 1;<br>}</p><p>&#x2F;&#x2F;遍历<br>void listElem(SeqList* L) {<br>    for (int i &#x3D; 0; i &lt; L-&gt;length; i++)<br>    {<br>        printf(“%d\t”, L-&gt;data[i]);<br>    }<br>    printf(“\n”);</p><p>}</p><p>&#x2F;&#x2F;插入数据<br>int insertElem(SeqList* L, int pos, ElemType e) {<br>    if (pos &lt;&#x3D; L-&gt;length - 1) {<br>        for (int i &#x3D; L-&gt;length - 1; i &gt;&#x3D; pos - 1; i–) {&#x2F;&#x2F;pos-1 就是要插入的位置<br>            L-&gt;data[i + 1] &#x3D; L-&gt;data[i];&#x2F;&#x2F;pos-1之后的数都往后挪一个位置，把pos-1的位置空出来<br>        }<br>        L-&gt;data[pos - 1] &#x3D; e;<br>        L-&gt;length++;<br>    }<br>    return 1;<br>}</p><p>&#x2F;&#x2F;删除数据<br>int deleteElem(SeqList* L, int pos, ElemType* e) {<br>    *e &#x3D; L-&gt;data[pos - 1];<br>    if (pos &lt; L-&gt;length) {<br>        for (int i &#x3D; pos; i &lt; L-&gt;length; i++)<br>        {<br>            L-&gt;data[i - 1] &#x3D; L-&gt;data[i];&#x2F;&#x2F;把要删除的位置后的数往前挪<br>        }<br>    }<br>    L-&gt;length–;<br>    return 1;<br>}</p><p>int main() {</p><pre><code>SeqList *list = initList();appendElem(list, 1);appendElem(list, 2);appendElem(list, 3);appendElem(list, 4);insertElem(list, 2, 6);listElem(list);ElemType delData;deleteElem(list, 2, &amp;delData);listElem(list);return 0;</code></pre><p>}</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>时间复杂度</title>
      <link href="/2025/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2025/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png"><br><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.png"><br>2的(t-1)次方 &gt; n  是因为只有这时候循环结束(即这是判定条件)</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/2025/05/01/JAVA/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2025/05/01/JAVA/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>一.对象代表什么,就得封装对应的数据，并提供数据对应的行为<br>比如“画圆”的对象是“圆”本身，因为画圆需要半径等等，并不是人画的<br>再比如“关门”是门自己关的，人不过是给了个作用力</p><p>二.private<br><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/JAVA%5Cprivate.png"><br>(忘了的时候看一眼吧)<br>直接用javabean插件就可以了嘻嘻<br>当然也可以用快捷键 alt+insert</p><p>三.this<br><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/JAVA/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F.png"><br>这是成员变量和局部变量</p><p><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/JAVA/%E5%B0%B1%E8%BF%91%E5%8E%9F%E5%88%99.png"><br>此为就近原则，如果不加this，谁离age近值就是谁，加上this，则会调用成员变量</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>像素画</title>
      <link href="/2025/05/01/%E5%83%8F%E7%B4%A0%E7%94%BB/%E5%83%8F%E7%B4%A0%E7%94%BB/"/>
      <url>/2025/05/01/%E5%83%8F%E7%B4%A0%E7%94%BB/%E5%83%8F%E7%B4%A0%E7%94%BB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 像素画 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>碎碎念</title>
      <link href="/2025/05/01/%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
      <url>/2025/05/01/%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>无语啦，累死我了&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</p><p>想要跳转文章的话就用 <a href="%E6%96%87%E7%AB%A0%E9%93%BE%E6%8E%A5">文章名</a></p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
