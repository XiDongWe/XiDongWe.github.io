<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>公共字段&amp;菜品部分</title>
      <link href="/2025/11/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96/%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5&amp;%E8%8F%9C%E5%93%81%E9%83%A8%E5%88%86/"/>
      <url>/2025/11/15/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96/%E5%85%AC%E5%85%B1%E5%AD%97%E6%AE%B5&amp;%E8%8F%9C%E5%93%81%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h1><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>如果通过switch来一个个查找的话，会因为查找的信息没有而发生错误，但是通过枚举的话就可以判断查找的值是否存在，不存在的话就会方法报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">testEnum</span> &#123;</span><br><span class="line">    MONDAY(<span class="string">&quot;星期一&quot;</span>),</span><br><span class="line">    TUESDAY(<span class="string">&quot;星期二&quot;</span>),</span><br><span class="line">    WEDNESDAY(<span class="string">&quot;星期三&quot;</span>),</span><br><span class="line">    THURSDAY(<span class="string">&quot;星期四&quot;</span>),</span><br><span class="line">    FRIDAY(<span class="string">&quot;星期五&quot;</span>),</span><br><span class="line">    SATURDAY(<span class="string">&quot;星期六&quot;</span>),</span><br><span class="line">    SUNDAY(<span class="string">&quot;星期日&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    DayEnum(String desc)&#123;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建的要是enum枚举类</p><p>在java类中用switch加上变量.getDesc()来获取</p><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>类型为@Interface</p><p>@Target - 指定使用目标</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常用取值：</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span>     <span class="comment">// 只能用在方法上</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span>       <span class="comment">// 类段</span></span><br><span class="line"><span class="meta">@Target(ElementType.PARAMETER)</span>  <span class="comment">// 方法参数</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span> <span class="comment">// 多个目标</span></span><br></pre></td></tr></table></figure><p>@Retention - 指定保留策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span>  <span class="comment">// 仅源码级别，编译后丢弃</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span>   <span class="comment">// 编译到class文件，但运行时不可见</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 运行时可通过反射读取（最常用）</span></span><br></pre></td></tr></table></figure><p>其他元注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span>    <span class="comment">// 包含在JavaDoc中</span></span><br><span class="line"><span class="meta">@Inherited</span>     <span class="comment">// 允许子类继承</span></span><br><span class="line"><span class="meta">@Repeatable</span>    <span class="comment">// 可重复使用</span></span><br></pre></td></tr></table></figure><p>注解属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="comment">// 基本类型，必须有默认值</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符串类型</span></span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 枚举类型</span></span><br><span class="line">    Color <span class="title function_">color</span><span class="params">()</span> <span class="keyword">default</span> Color.RED;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组类型</span></span><br><span class="line">    String[] tags() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注解类型</span></span><br><span class="line">    NestedAnnotation <span class="title function_">nested</span><span class="params">()</span> <span class="keyword">default</span> <span class="meta">@NestedAnnotation</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Class类型</span></span><br><span class="line">    Class&lt;?&gt; clazz() <span class="keyword">default</span> Object.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251116092235122.png" alt="image-20251116092235122"></p><p>反射就是返回类里面的成员变量，构造方法，成员方法等等</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251116093008607.png" alt="image-20251116093008607"></p><h3 id="获取class对象"><a href="#获取class对象" class="headerlink" title="获取class对象"></a>获取class对象</h3><p><code>Class.forName(&quot;全类名&quot;)</code> （最常用）</p><p>全类名 &#x3D; 包名 + 类名 （直接在类中右键类名复制就可以了）</p><p>Class clazz &#x3D; Class.forname(“全类名”);</p><p><code>类名.class</code>（更多的当成参数传递）</p><p>Class clazz &#x3D; Student.class;</p><p><code>对象.getClass()</code>（当已经有了这个类的对象时才能使用）</p><p>Student s &#x3D; new Student();</p><p>Class clazz &#x3D; s.getClass();</p><h3 id="获取构造方法Constructor"><a href="#获取构造方法Constructor" class="headerlink" title="获取构造方法Constructor"></a>获取构造方法Constructor</h3><p><strong>Class类中用于获取构造方法的方法</strong></p><p><code>Constructor&lt;?&gt;[] getConstructors()</code>: 返回所有公共构造方法对象的数组</p><p><code>Constructor&lt;?&gt;[] getDeclaredConstructors()</code>: 返回所有构造方法对象的数组</p><p><code>Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</code>：返回单个公共构造方法对象(如果是空就返回空参的，要返回其他的就要加上对应参数类型+.class)</p><p><code>Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code>：返回单个构造方法对象</p><p><strong>Constructor类中用于创建对象的方法</strong></p><p><code>T newInstance(Object... initargs)</code>：根据指定的构造方法创建对象</p><p><code>setAccessible(boolean flag)</code>：设置为true，表示取消访问检查</p><p><strong>Constructor类中用于操作构造方法的方法</strong>：</p><ul><li><code>T newInstance(Object... initargs)</code>：根据指定的构造方法创建对象实例。</li><li><code>void setAccessible(boolean flag)</code>：设置为true时，取消访问检查（用于访问私有构造方法）。</li><li><code>int getModifiers()</code>：获取构造方法的修饰符。</li><li><code>String getName()</code>：获取构造方法的名字（通常返回类名）。</li><li><code>Class&lt;?&gt;[] getParameterTypes()</code>：获取构造方法的形参类型数组。</li></ul><h3 id="成员变量-字段-Field"><a href="#成员变量-字段-Field" class="headerlink" title="成员变量(字段)Field"></a>成员变量(字段)Field</h3><p><strong>Class类中用于获取成员变量的方法</strong></p><p><code>Field[] getFields()</code>: 返回所有公共成员变量对象的数组</p><p><code>Field[] getDeclaredFields()</code>: 返回所有成员变量对象的数组</p><p><code>Field getField(String name)</code>：返回单个公共成员变量对象</p><p><code>Field getDeclaredField(String name)</code>：返回单个成员变量对象</p><p><strong>Field类中用于操作成员变量的方法</strong></p><p><code>void set(Object obj, Object value)</code>：为指定对象的此成员变量赋值</p><p><code>Object get(Object obj)</code>：获取指定对象的此成员变量的值</p><p><strong>Field类中用于操作字段的方法</strong>：</p><ul><li><code>int getModifiers()</code>：获取字段的修饰符（如public、private等）。</li><li><code>String getName()</code>：获取字段的名字。</li><li><code>Class&lt;?&gt; getType()</code>：获取字段的类型。</li><li><code>Object get(Object obj)</code>：获取指定对象中该字段的值。</li><li><code>void set(Object obj, Object value)</code>：设置指定对象中该字段的值。</li><li><code>void setAccessible(boolean flag)</code>：设置为true时，取消访问检查（用于访问私有字段）。</li></ul><h3 id="成员方法Method"><a href="#成员方法Method" class="headerlink" title="成员方法Method"></a>成员方法Method</h3><p><strong>Class类中用于获取成员方法的方法</strong>：</p><ul><li><code>Method[] getMethods()</code>：返回所有公共成员方法对象的数组（包括继承的公共方法）。</li><li><code>Method[] getDeclaredMethods()</code>：返回所有成员方法对象的数组（包括私有方法，但不包括继承的方法）。</li><li><code>Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code>：返回指定名称和参数类型的公共方法对象。</li><li><code>Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code>：返回指定名称和参数类型的方法对象（包括私有方法）。</li></ul><p><strong>Method类中用于操作成员方法的方法</strong>：</p><ul><li><code>int getModifiers()</code>：获取方法的修饰符。</li><li><code>String getName()</code>：获取方法的名字。</li><li><code>Class&lt;?&gt;[] getParameterTypes()</code>：获取方法的形参类型数组。</li><li><code>Class&lt;?&gt; getReturnType()</code>：获取方法的返回值类型。</li><li><code>Class&lt;?&gt;[] getExceptionTypes()</code>：获取方法抛出的异常类型数组。</li><li><code>Annotation[] getAnnotations()</code>：获取方法上的注解数组。</li><li><code>Object invoke(Object obj, Object... args)</code>：运行（调用）指定对象上的方法，并返回结果。</li></ul><p>invoke例子：</p><p>Student s &#x3D; new Student();</p><p>m.invoke(s,“kfc”)</p><p>参数一：方法的调用者</p><p>参数二：调用方法时传递的实际参数</p><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>面向切面编程，也可理解为面向特定方法编程</p><p><code>步骤</code></p><ul><li>导入aop依赖</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.5</span><span class="number">.6</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>编写aop程序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span><span class="comment">//声明当前类是一个aop类</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">//把这个类交给ioc</span></span><br><span class="line"><span class="keyword">public</span> class ...</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">record111</span> &#123;</span><br><span class="line">    <span class="meta">@Around(&quot;execution(* *..*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">record111</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>result表示原始代码，在其上下部分可添加代码</p><p>在<code>@Around</code>中设定范围</p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a><code>核心概念</code></h3><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251116133945043.png" alt="image-20251116133945043"></p><p>底层就是通过动态代理</p><p>先生成一个和目标对象同一接口的代理对象，复制方法，再把aop的代码放进去，最后在controller中注入service的就是代理对象，引用的方法也是代理对象中的</p><p>这样做就可以不污染源代码，还能实现各种操作，比如记录代码运行时间等等</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251116134216915.png" alt="image-20251116134216915"></p><h3 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a><code>通知类型</code></h3><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251116135358311.png" alt="image-20251116135358311"></p><h3 id="通知顺序"><a href="#通知顺序" class="headerlink" title="通知顺序"></a><code>通知顺序</code></h3><ul><li><p>当有多个切面的切入点都匹配到了目标方法，目标方法运行时，多个通知方法都会被执行。</p></li><li><p>在不同切面类中，默认按照切面类的<strong>类名字母排序</strong>：</p><ul><li><p>目标方法前的通知方法：字母排名靠前的先执行。</p></li><li><p>目标方法后的通知方法：字母排名靠前的后执行。</p></li></ul></li><li><p>用<code>@Order（数字）</code>加在切面类上控制顺序</p><ul><li><p>目标方法前的通知方法：数字小的先执行。</p></li><li><p>目标方法后的通知方法：数字小的后执行。</p></li></ul></li></ul><h3 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a><code>切入点表达式</code></h3><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251116142424267.png" alt="image-20251116142424267"></p><ul><li><strong>execution</strong></li></ul><p>主要根据方法的返回值、包名、类名、方法名、方法参数等信息来匹配，语法为：</p><p><code>execution(访问修饰符? 返回值 包名.类名.?方法名(方法参数) throws 异常?)</code></p><ul><li>其中带 <code>?</code>的部分表示可以省略。</li></ul><p><strong>访问修饰符</strong>：可省略（例如：public、protected）</p><p><strong>包名.类名</strong>：可省略(但不推荐)</p><p><strong>throws 异常</strong>：可省略（此处指方法声明上抛出的异常，并非实际运行时的异常）</p><ul><li><strong>通配符说明</strong>：</li></ul><p><strong><code>\*</code></strong>：表示<strong>任意单个符号</strong>，可用于通配返回值、包名、类名、方法名，或任意类型的一个参数，也可用于通配包、类、方法名的一部分。</p><p><strong>示例</strong>：<code>execution(* com.*.service.*.update*(*))</code></p><p><strong><code>..</code></strong>：表示<strong>任意多个连续的符号</strong>，可用于通配任意层级的包，或任意类型、任意个数的参数。</p><p><strong>示例</strong>：<code>execution(* com.itheima.DeptService.*(..))</code></p><ul><li>@annotation</li></ul><p>用于识别标识有特定注解的方法</p><p>这个其实是自定义注解</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251116145045229.png" alt="image-20251116145045229"></p><p>LogOpration需要自己创建一个自定义注解，方法上的@LogOpration就是调用的自定义注解</p><h3 id="连接点"><a href="#连接点" class="headerlink" title="连接点"></a>连接点</h3><p>在Spring中用JoinPoint抽象了连接点，用它可以获得方法执行时的相关信息，如目标类名、方法名、方法参数等。</p><ul><li>对于@Around通知，获取连接点信息只能使用 ProceedingJoinPoint。</li><li>对于其它四种通知，获取连接点信息只能使用JoinPoint，它是 ProceedingJoinPoint的父类型。</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251116150042542.png" alt="image-20251116150042542"></p><h1 id="公共字段自动填充"><a href="#公共字段自动填充" class="headerlink" title="公共字段自动填充"></a>公共字段自动填充</h1><p>因为在搭建项目的时候有很多重复的操作，且维护起来不方便，因此就要根据以上复习的技术点来搭建公共字段</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251116151410078.png" alt="image-20251116151410078"></p><p><code>枚举</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sky.enumeration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据库操作类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OperationType</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    UPDATE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    INSERT</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>自定义注解</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoFill &#123;</span><br><span class="line">    <span class="comment">//    数据库操作类型，update insert</span></span><br><span class="line">    <span class="comment">//    为什么用枚举？</span></span><br><span class="line">    <span class="comment">//    为了保证程序的安全性和可读性。它限定了 @AutoFill注解的</span></span><br><span class="line">    <span class="comment">//    value只能取几个预定义好的值，而不是随便写一个字符串或数字。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * value的作用</span></span><br><span class="line"><span class="comment">     * 就是把枚举里的值取出来，作为注解的参数</span></span><br><span class="line"><span class="comment">     * 例如<span class="doctag">@AutoFill</span>(value = OperationType.INSERT)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    OperationType <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AOP</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoFillAspect</span> &#123;</span><br><span class="line">    <span class="comment">//定义切入点，也就是找到对应的方法，找到对应的范围</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autoFillPointCut</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;autoFillPointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autoFill</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始进行数据填充&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义切入点autoFillPointCut的范围，再把切入点给autoFill来进行操作</p><p>在mapper对应的方法上加上以下代码即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoFill(value = Ope@AutoFill(value = OperationType.INSERT)</span></span><br><span class="line"><span class="meta">@AutoFill(value = OperationType.INSERT)rationType.UPDATE)</span></span><br></pre></td></tr></table></figure><p><code>补充AOP</code></p><ul><li>获取到当前被拦截的方法上的数据库操作类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MethodSignature</span> <span class="variable">methodSignature</span> <span class="operator">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class="line"></span><br><span class="line"><span class="comment">//joinPoint：就是被拦截到的那个“快递包裹”。</span></span><br><span class="line"><span class="comment">//.getSignature()：查看包裹上的“运单”，上面有寄件人、收件人等基本信息。</span></span><br><span class="line"><span class="comment">//(MethodSignature)：确认这个包裹是“方法类型”的快递（因为还有其他的切入点类型）。</span></span><br><span class="line"><span class="comment">//结果：我们拿到了一个详细的“运单信息”（methodSignature）</span></span><br><span class="line"></span><br><span class="line"><span class="type">AutoFill</span> <span class="variable">autoFill</span> <span class="operator">=</span> methodSignature.getMethod().getAnnotation(AutoFill.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//methodSignature.getMethod()：根据运单信息，找到具体的“包裹内容”（被拦截的Method对象）。</span></span><br><span class="line"><span class="comment">//.getAnnotation(AutoFill.class)：在这个包裹上寻找有没有贴@AutoFill这个特殊的“标签”。</span></span><br><span class="line"><span class="comment">//结果：我们找到了那个标签（autoFill注解对象）。</span></span><br><span class="line"></span><br><span class="line"><span class="type">OperationType</span> <span class="variable">operationType</span> <span class="operator">=</span> autoFill.value();</span><br><span class="line"><span class="comment">//autoFill.value()：仔细看标签上写的具体内容。</span></span><br><span class="line"><span class="comment">//结果：读到了内容是OperationType.INSERT（插入操作）或者OperationType.UPDATE（更新操作）。</span></span><br></pre></td></tr></table></figure><ul><li>获取到当前被拦截的方法的参数–实体对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object[] args = joinPoint.getArgs();</span><br><span class="line"><span class="keyword">if</span> (args == <span class="literal">null</span> || args.length == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//约定mapper中的第一个参数是实体对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> args[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><ul><li>准备赋值的数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="type">Long</span> <span class="variable">currentId</span> <span class="operator">=</span> BaseContext.getCurrentId();</span><br></pre></td></tr></table></figure><ul><li>根据不同的操作类型，为对应的属性通过反射来复制</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (operationType == OperationType.INSERT)&#123; <span class="comment">//判断添加</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">setUpdateTime</span> <span class="operator">=</span> object.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);<span class="comment">//这里用了设置的常量</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">setCreateUser</span> <span class="operator">=</span> object.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);</span><br><span class="line">            <span class="type">Method</span> <span class="variable">setUpdateUser</span> <span class="operator">=</span> object.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);</span><br><span class="line">            <span class="type">Method</span> <span class="variable">setCreateTime</span> <span class="operator">=</span> object.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);</span><br><span class="line">            <span class="comment">//通过反射赋值</span></span><br><span class="line">            setCreateTime.invoke(object,now);</span><br><span class="line">            setUpdateTime.invoke(object,now);</span><br><span class="line">            setCreateUser.invoke(object,currentId);</span><br><span class="line">            setUpdateUser.invoke(object,currentId);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(operationType == OperationType.UPDATE)&#123;  <span class="comment">//判断更新</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">setUpdateTime</span> <span class="operator">=</span> object.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">setUpdateUser</span> <span class="operator">=</span> object.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);</span><br><span class="line"></span><br><span class="line">        setUpdateTime.invoke(object,now);</span><br><span class="line">        setUpdateUser.invoke(object,currentId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="菜品功能"><a href="#菜品功能" class="headerlink" title="菜品功能"></a>菜品功能</h1><h2 id="新增菜品"><a href="#新增菜品" class="headerlink" title="新增菜品"></a>新增菜品</h2><ul><li>文件上传</li></ul><p>先在application.yml中配置阿里云oss</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alioss:</span><br><span class="line">  endpoint: oss-cn-beijing.aliyuncs.com</span><br><span class="line">  access-key-id: LTAI5tEnxippfj9dn2iynJBe</span><br><span class="line">  access-key-secret: qY7L9R4516VLV8WjqXpzvYU89q9phy</span><br><span class="line">  bucket-name: sky-take-out</span><br></pre></td></tr></table></figure><p>根据接口文档的要求创建新的controller来进行文件上传</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> AliOssUtil aliOssUtil;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//String是因为返回的必须的data是字符串</span></span><br><span class="line">   <span class="comment">//MultipartFile指文件类型</span></span><br><span class="line">   <span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">upload</span><span class="params">(MultipartFile file)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       log.info(<span class="string">&quot;文件上传：&#123;&#125;&quot;</span>,file);</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">       <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">       <span class="type">String</span> <span class="variable">extension</span> <span class="operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">       <span class="type">String</span> <span class="variable">objectName</span> <span class="operator">=</span> UUID.randomUUID().toString() + extension;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 调用阿里云OSS工具类上传文件</span></span><br><span class="line">       aliOssUtil.upload(file.getBytes(),objectName);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> Result.success(objectName);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AliOssUtil aliOssUtil;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">upload</span><span class="params">(MultipartFile file)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    log.info(<span class="string">&quot;文件上传：&#123;&#125;&quot;</span>, file.getOriginalFilename());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 验证文件</span></span><br><span class="line">        <span class="keyword">if</span> (file.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.error(<span class="string">&quot;文件不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原始文件名，比如 &quot;avatar.jpg&quot;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 截取文件后缀，比如 &quot;.jpg&quot;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">extension</span> <span class="operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成唯一文件名，比如 &quot;a1b2c3d4-e5f6-7890.jpg&quot;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">objectName</span> <span class="operator">=</span> UUID.randomUUID().toString() + extension;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用阿里云OSS工具类上传文件，并获取完整的URL</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileUrl</span> <span class="operator">=</span> aliOssUtil.upload(file.getBytes(), objectName);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;文件上传成功，URL：&#123;&#125;&quot;</span>, fileUrl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回完整的URL，而不是文件名</span></span><br><span class="line">        <span class="keyword">return</span> Result.success(fileUrl);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;文件上传失败&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;上传失败：&quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="新增菜品-1"><a href="#新增菜品-1" class="headerlink" title="新增菜品"></a>新增菜品</h2><p><code>controller</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">addDish</span><span class="params">(<span class="meta">@RequestBody</span> DishDTO dishDTO)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;新增菜品：&#123;&#125;&quot;</span>,dishDTO);</span><br><span class="line">    dishService.addDish(dishDTO);</span><br><span class="line">    <span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>service</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span> <span class="comment">//添加事务注解  因为有多个表要插入，若一个错误，将不在运行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addDish</span><span class="params">(DishDTO dishDTO)</span> &#123;</span><br><span class="line">    <span class="comment">//向菜品表插入一条数据</span></span><br><span class="line">    <span class="type">Dish</span> <span class="variable">dish</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dish</span>();</span><br><span class="line">    BeanUtils.copyProperties(dishDTO,dish);</span><br><span class="line">    dishMapper.addDish(dish);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取addDish生成的主键值（因为口味表那里需要主键值</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">dishId</span> <span class="operator">=</span> dish.getId();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向口味表插入n条数据</span></span><br><span class="line">    List&lt;DishFlavor&gt; flavors = dishDTO.getFlavors();</span><br><span class="line">    <span class="keyword">if</span> (flavors != <span class="literal">null</span> &amp;&amp; flavors.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        flavors.forEach(dishFlavor -&gt; dishFlavor.setDishId(dishId));</span><br><span class="line">        dishF.add(flavors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mapper</code></p><ul><li>菜品</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    因为在菜品口味的时候需要菜品的id，所以这里要返回id--&gt;</span><br><span class="line">    &lt;insert id=<span class="string">&quot;addDish&quot;</span> useGeneratedKeys=<span class="string">&quot;true&quot;</span> keyProperty=<span class="string">&quot;id&quot;</span>&gt;</span><br><span class="line">insert into <span class="title function_">dish</span> </span><br><span class="line">    <span class="params">(name, category_id, description, price, image, status, create_time, update_time, create_user, update_user)</span></span><br><span class="line">        values </span><br><span class="line">    (#&#123;name&#125;, #&#123;categoryId&#125;, #&#123;description&#125;,#&#123;price&#125;, </span><br><span class="line">     #&#123;image&#125;, #&#123;status&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;, #&#123;createUser&#125;, #&#123;updateUser&#125;)</span><br><span class="line">    &lt;/insert&gt;</span><br></pre></td></tr></table></figure><ul><li>口味</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=<span class="string">&quot;add&quot;</span>&gt;</span><br><span class="line">    insert into <span class="title function_">dish_flavor</span> <span class="params">(name, dish_id,value)</span> values</span><br><span class="line">    &lt;foreach collection=<span class="string">&quot;flavors&quot;</span> item=<span class="string">&quot;df&quot;</span> separator=<span class="string">&quot;,&quot;</span>&gt;  <span class="comment">//关于xml的遍历语法</span></span><br><span class="line">        (#&#123;df.name&#125;, #&#123;df.dishId&#125;, #&#123;df.value&#125;)</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure><h2 id="页面查询"><a href="#页面查询" class="headerlink" title="页面查询"></a>页面查询</h2><p>其他部分与之前都大差不差，只有一些小区别</p><p><code>service</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Page&lt;DishVO&gt; page = dishMapper.pageQuery(dishPageQueryDto);</span><br></pre></td></tr></table></figure><p>这里的Page的泛型用了DishVO，因为相比Dish，DishVO中有变量catefory</p><p><code>mapper</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">select d.*,c.name as categoryName from dish d left outer join category c on d.category_id = c.id <span class="comment">//这里用了左外连接</span></span><br><span class="line">&lt;where&gt;</span><br><span class="line">    &lt;<span class="keyword">if</span> test=<span class="string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span><br><span class="line">        and d.name like <span class="string">&#x27;%$&#123;name&#125;%&#x27;</span></span><br><span class="line">    &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">if</span> test=<span class="string">&quot;categoryId != null&quot;</span>&gt;</span><br><span class="line">        and d.category_id = #&#123;categoryId&#125;</span><br><span class="line">    &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">if</span> test=<span class="string">&quot;status != null&quot;</span>&gt;</span><br><span class="line">        and d.status = #&#123;status&#125;</span><br><span class="line">    &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;/where&gt;</span><br><span class="line">order by d.update_time desc</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 苍穹外卖 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>项目搭建&amp;员工部分</title>
      <link href="/2025/11/14/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA&amp;%E5%91%98%E5%B7%A5%E9%83%A8%E5%88%86/"/>
      <url>/2025/11/14/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA&amp;%E5%91%98%E5%B7%A5%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="工程搭建"><a href="#工程搭建" class="headerlink" title="工程搭建"></a>工程搭建</h1><ul><li>创建SpringBoot工程，并引入Web开发起步依赖,mybasits,mysql驱动,lombok</li></ul><p>developer tools: <code>lombok</code></p><p>Web:<code>Spring Web</code></p><p>SQL:<code>Mybatis Framework，MySQL Driver</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251113134722714.png" alt="image-20251113134722714"></p><p>创建之后保留这三个文件就可以了</p><p>把resources中的文件都删掉，新建<code>application.yml</code>文件，在此文件中连接数据库</p><p><code>yml配置文件形式</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251113135842773.png" alt="image-20251113135842773"></p><p><code>关于数据库</code></p><p>在不同主机名(如localhost)下都是一个个电脑，而数据库就是在这电脑里，通过idea连接的就是此数据库(因为之前不明白数据库是怎么工作的),只要属性都对上就可以正常工作</p><ul><li>创建数据库表，并在application.yml中配置数据库的基本信息</li></ul><p>可以像这么写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">datasource:</span><br><span class="line">    driver-class-name: $&#123;sky.datasource.driver-class-name&#125;</span><br><span class="line">    url: jdbc:mysql:<span class="comment">//$&#123;sky.datasource.host&#125;:$&#123;sky.datasource.port&#125;/$&#123;sky.datasource.database&#125;</span></span><br><span class="line">    username: $&#123;sky.datasource.username&#125;</span><br><span class="line">    password: $&#123;sky.datasource.password&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251113143335565.png" alt="image-20251113143335565"></p><p>其中mapper的xml配置可以像这么配置</p><p>寻找在recources的mapper目录下的所有xml</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:mapper<span class="comment">/*.xml</span></span><br><span class="line"><span class="comment">  configuration:</span></span><br><span class="line"><span class="comment">  #开启驼峰命名</span></span><br><span class="line"><span class="comment">    map-underscore-to-camel-case: true</span></span><br></pre></td></tr></table></figure><ul><li>准备基础代码结构，并引入实体类及统一的相应结果分装类Result</li></ul><p><code>DTO接收数据</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前端发送 POST 请求，Body 是 JSON：</span></span><br><span class="line"><span class="comment">// &#123;&quot;username&quot;: &quot;admin&quot;, &quot;password&quot;: &quot;123456&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> EmployeeLoginDTO dto)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. HTTP 请求进来，SpringMVC 拦截到</span></span><br><span class="line">    <span class="comment">// 2. @RequestBody 告诉 Spring：把请求 Body 的 JSON 转成 Java 对象</span></span><br><span class="line">    <span class="comment">// 3. Spring 调用 Jackson 库，自动匹配 JSON 的 key 和 DTO 的字段名</span></span><br><span class="line">    <span class="comment">// 4. 自动创建 EmployeeLoginDTO 对象并填充数据：</span></span><br><span class="line">    <span class="comment">//    dto.username = &quot;admin&quot;</span></span><br><span class="line">    <span class="comment">//    dto.password = &quot;123456&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过&#96;&#96;@RequestBody&#96;把前端返回的数据变为java语言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;EmployeeVO&gt; <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> EmployeeLoginDTO dto)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. Service 层查出 Employee 实体</span></span><br><span class="line">    <span class="type">Employee</span> <span class="variable">entity</span> <span class="operator">=</span> employeeService.login(dto);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 手动把 Entity 转成 VO（隐藏敏感字段）</span></span><br><span class="line">    <span class="type">EmployeeVO</span> <span class="variable">vo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmployeeVO</span>();</span><br><span class="line">    vo.setId(entity.getId());</span><br><span class="line">    vo.setName(entity.getName()); <span class="comment">// 不返回 password！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 把 VO 装进 Result</span></span><br><span class="line">    Result&lt;EmployeeVO&gt; result = Result.success(vo);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. SpringMVC 把 Result 对象转成 JSON 字符串</span></span><br><span class="line">    <span class="comment">// 5. 通过 HTTP 响应返回给前端</span></span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// 最终前端收到：&#123;&quot;code&quot;:1,&quot;msg&quot;:null,&quot;data&quot;:&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;admin&quot;&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>return Result.success(employeeLoginVO);</code>把VO装进result返回</p><h1 id="新增员工"><a href="#新增员工" class="headerlink" title="新增员工"></a>新增员工</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251114105141508.png" alt="image-20251114105141508"></p><p>员工的DTO按前端的来设置</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String idNumber;</span><br></pre></td></tr></table></figure><p><code>controller</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    新增员工</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;新增员工&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> EmployeeDTO employeeDTO)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;新增员工：&#123;&#125;&quot;</span>,employeeDTO);</span><br><span class="line">    employeeService.save(employeeDTO);</span><br><span class="line">    <span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取dto，用@RequestBody变为java语言，在用sava方法传给Service</p><p><code>service</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    新增员工</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(EmployeeDTO employeeDTO)</span> &#123;</span><br><span class="line">    <span class="comment">//在sava里，把employee里没涉及到的属性进行封装</span></span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">    <span class="comment">//一键拷贝</span></span><br><span class="line">    BeanUtils.copyProperties(employeeDTO,employee);</span><br><span class="line">    <span class="comment">//把dto里没有的属性加进去</span></span><br><span class="line">    <span class="comment">//密码进行md5加密</span></span><br><span class="line">    employee.setPassword(DigestUtils.md5DigestAsHex(PasswordConstant.DEFAULT_PASSWORD.getBytes()));</span><br><span class="line">    <span class="comment">//创建，更新时间</span></span><br><span class="line">    employee.setCreateTime(LocalDateTime.now());</span><br><span class="line">    employee.setUpdateTime(LocalDateTime.now());</span><br><span class="line">    <span class="comment">//设置创建人和修改人id</span></span><br><span class="line">    <span class="comment">// TODO   后期改换为当前登录用户的id</span></span><br><span class="line">    employee.setCreateUser(<span class="number">10L</span>);</span><br><span class="line">    employee.setUpdateUser(<span class="number">10L</span>);</span><br><span class="line"></span><br><span class="line">    employeeMapper.insert(employee);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一键拷贝只能拷dto和employee共有的，其余的要手动打</p><p>再用insert方法传给mapper</p><p><code>mapper</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    新增员工</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Insert(&quot;insert into employee (name, username, password, phone, sex, id_number, create_time, update_time, create_user, update_user) VALUE &quot; +</span></span><br><span class="line"><span class="meta">        &quot;(#&#123;name&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;phone&#125;,#&#123;sex&#125;,#&#123;idNumber&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;,#&#123;createUser&#125;,#&#123;updateUser&#125;)&quot;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Employee employee)</span></span><br></pre></td></tr></table></figure><p>用驼峰来传递</p><h2 id="代码完善"><a href="#代码完善" class="headerlink" title="代码完善"></a>代码完善</h2><p>目前有两个问题:</p><ul><li>录入的用户名已存在，抛出异常后没有处理</li><li>新增员工时，创建人id和修改人id设置为固定值</li></ul><p><code>问题一</code></p><p>在handler全局异常处理器中</p><p>原语句：java.sql.SQLIntegrityConstraintViolationException: Duplicate entry ‘慈超栋’ for key ‘employee.idx_username’</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">exceptionHandler</span><span class="params">(SQLIntegrityConstraintViolationException ex)</span>&#123;</span><br><span class="line">    <span class="comment">//Duplicate entry &#x27;慈超栋&#x27; for key &#x27;employee.idx_username</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> ex.getMessage();</span><br><span class="line">    <span class="keyword">if</span> (message.contains(<span class="string">&quot;Duplicate entry&quot;</span>))&#123;</span><br><span class="line">        String[] split = message.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span>  <span class="operator">=</span> split[<span class="number">2</span>];</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> username + <span class="string">&quot;已存在&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> Result.error(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error(<span class="string">&quot;未知错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>问题二</code></p><p>客户端发送的每一个请求都是一个单独的线程，因此可以用<code>ThreadLocal</code>在这个线程内，通过拦截器获取id并把id设置到线程中来获取</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251114134557756.png" alt="image-20251114134557756"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setCurrentId</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    threadLocal.set(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">getCurrentId</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeCurrentId</span><span class="params">()</span> &#123;</span><br><span class="line">    threadLocal.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h1><p>先分析一下</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251114165946062.png" alt="image-20251114165946062"></p><p>Result中的data里面有total和records，records里有员工的信息，因此可以把data单独封装，以便方便</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageResult</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> total; <span class="comment">//总记录数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List records; <span class="comment">//当前页数据集合</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/picturepictureimage-20251114171711913.png" alt="image-20251114171711913"></p><p><code>controller</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/page&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;PageResult&gt; <span class="title function_">pageQuery</span><span class="params">(EmployeePageQueryDTO employeePageQueryDTO)</span>&#123;<span class="comment">//因为返回类型是QueryPageResult，</span></span><br><span class="line">      log.info(<span class="string">&quot;分页查询：&#123;&#125;&quot;</span>,employeePageQueryDTO);</span><br><span class="line">      <span class="type">PageResult</span> <span class="variable">pageResult</span> <span class="operator">=</span> employeeService.pageQuery(employeePageQueryDTO);</span><br><span class="line">      <span class="keyword">return</span> Result.success(pageResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是分页查询，所以返回的Result的泛型就要为PageResult(看图，相当于Result包含PageResult)</p><p>最后返回PageResult</p><p><code>service</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageResult <span class="title function_">pageQuery</span><span class="params">(EmployeePageQueryDTO employeePageQueryDTO)</span> &#123;</span><br><span class="line">    <span class="comment">//通过PageHelper进行分页</span></span><br><span class="line">    PageHelper.startPage(employeePageQueryDTO.getPage(),employeePageQueryDTO.getPageSize());</span><br><span class="line">    <span class="comment">//PageHelper规定要用Page&lt;T&gt;</span></span><br><span class="line">    Page&lt;Employee&gt; page = employeeMapper.pageQuery(employeePageQueryDTO);</span><br><span class="line">    <span class="comment">//因为要返回PageResult,所以要配置其他变量（因为这是service层啊，这玩意就是干这个的）</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> page.getTotal();</span><br><span class="line">    List&lt;Employee&gt; records = page.getResult();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageResult</span>(total,records);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过PageHelper插件计算页码</p><p>最后返回PageResult</p><p><code>mapper</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;pageQuery&quot;</span> resultType=<span class="string">&quot;com.sky.entity.Employee&quot;</span>&gt;</span><br><span class="line">    select * from employee</span><br><span class="line">    &lt;where&gt;</span><br><span class="line">        &lt;<span class="keyword">if</span> test=<span class="string">&quot;name != null and name !=&#x27;&#x27;&quot;</span>&gt;</span><br><span class="line">            and name like <span class="title function_">concat</span><span class="params">(<span class="string">&#x27;%&#x27;</span>,#&#123;name&#125;,<span class="string">&#x27;%&#x27;</span>)</span></span><br><span class="line">        &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">    &lt;/where&gt;</span><br><span class="line">    order by create_time desc</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>其中like是模糊查询，concat(‘%’,#{name},’%’)是拼接字符串，会查询任何包含name的字符串</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251114182917495.png" alt="image-20251114182917495"></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251114182907361.png" alt="image-20251114182907361"></p><p>但是操作时间有问题，需要改一下</p><p>在config中改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;扩展消息转换器&quot;</span>);</span><br><span class="line">    <span class="comment">//创建一个消息转化器对象</span></span><br><span class="line">    <span class="type">MappingJackson2HttpMessageConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>();</span><br><span class="line">    <span class="comment">//需要为消息转化器设置一个对象转换器，对象转换器可以将Java对象转为json</span></span><br><span class="line">    converter.setObjectMapper(<span class="keyword">new</span> <span class="title class_">JacksonObjectMapper</span>());</span><br><span class="line">    <span class="comment">//将自己的消息转换器加入容器中(把自己的排在序号0上)</span></span><br><span class="line">    converters.add(<span class="number">0</span>,converter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JacksonObjectMapper()到时候找ai生成就行了，比较固定(懒</p><h1 id="禁用-启用员工账号"><a href="#禁用-启用员工账号" class="headerlink" title="禁用&amp;启用员工账号"></a>禁用&amp;启用员工账号</h1><p>原理就是通过更新</p><p><code>controller</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/status/&#123;status&quot;)</span><span class="comment">//status表示状态，来判断启用禁用</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">startOrStop</span><span class="params">(<span class="meta">@PathVariable</span> Integer status, Long id)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;启用禁用员工,&#123;&#125;,&#123;&#125;&quot;</span>,status,id);</span><br><span class="line">    employeeService.startOrStop(status,id);</span><br><span class="line">    <span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路径参数就加上@PathVariable</p><p><code>service</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startOrStop</span><span class="params">(Integer status, Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//但是如果只是传这两个参数的话，mapper的update语句局限性太大了、</span></span><br><span class="line">    <span class="comment">//因此可以在这里新建一个对象来传递</span></span><br><span class="line">    <span class="comment">//这样的话之后还想用update的话也可以复用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里的build是因为dto里有@Builder</span></span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> Employee.builder()</span><br><span class="line">            .status(status)</span><br><span class="line">            .id(id)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    employeeMapper.update(employee);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mapper</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id=<span class="string">&quot;update&quot;</span>&gt;</span><br><span class="line">    update employee</span><br><span class="line">    &lt;set&gt;</span><br><span class="line">    &lt;<span class="keyword">if</span> test=<span class="string">&quot;username != null&quot;</span>&gt;username = #&#123;username&#125;,&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">if</span> test=<span class="string">&quot;name != null&quot;</span>&gt;name = #&#123;name&#125;,&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">if</span> test=<span class="string">&quot;phone != null&quot;</span>&gt;phone = #&#123;phone&#125;,&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">if</span> test=<span class="string">&quot;sex != null&quot;</span>&gt;sex = #&#123;sex&#125;,&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">if</span> test=<span class="string">&quot;idNumber != null&quot;</span>&gt;id_number = #&#123;idNumber&#125;,&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">if</span> test=<span class="string">&quot;status != null&quot;</span>&gt;status = #&#123;status&#125;,&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">if</span> test=<span class="string">&quot;updateTime != null&quot;</span>&gt;update_time = #&#123;updateTime&#125;,&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">    &lt;/set&gt;</span><br><span class="line">    <span class="type">where</span> <span class="variable">id</span> <span class="operator">=</span> #&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure><h1 id="编辑员工"><a href="#编辑员工" class="headerlink" title="编辑员工"></a>编辑员工</h1><p>两个接口</p><ul><li>根据id查询员工信息</li><li>编辑员工信息</li></ul><h2 id="查询员工"><a href="#查询员工" class="headerlink" title="查询员工"></a>查询员工</h2><p><code>controller</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result&lt;Employee&gt; <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;根据id查询员工,&#123;&#125;&quot;</span>,id);</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> employeeService.getById(id);</span><br><span class="line">    <span class="keyword">return</span> Result.success(employee);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>service</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Employee <span class="title function_">getById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> employeeMapper.getById(id);</span><br><span class="line">    employee.setPassword(<span class="string">&quot;****&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> employee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把密码隐藏掉</p><p><code>mapper</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from employee where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">Employee <span class="title function_">getById</span><span class="params">(Long id)</span>;</span><br></pre></td></tr></table></figure><p>11.15</p><p>分类管理模块的功能已写好，就是按类型分类有问题，其他的跟员工部分没什么区别</p>]]></content>
      
      
      <categories>
          
          <category> 苍穹外卖 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git基础</title>
      <link href="/2025/11/08/JAVAWEB/git%E5%9F%BA%E7%A1%80/"/>
      <url>/2025/11/08/JAVAWEB/git%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><code>为什么学Git</code></p><ol><li>备份：以防电脑突然蓝屏导致代码丢失</li><li>代码还原：在把代码改的乱七八糟之后还能复原</li><li>协同开发：为了同时修改代码</li><li>追溯代码编写人和编写时间</li></ol><p><code>获取本地仓库</code></p><ol><li>在任意位置创建一个空目录</li><li>进入目录后打开Git Bash</li><li>执行<code>git init</code></li><li>如果创建成功就可以看见<code>.git</code>目录</li></ol><p><code>基础操作命令</code></p><p><code>创建</code>：touch …</p><p>对于修改这一类（增删改），需要先从<code>工作区</code>通过<code>git add</code>把他提交到<code>暂存区</code></p><p>在通过<code>git commit</code>提交到<code>仓库</code>才能完成修改，成为一次提交记录</p><p><code>git status</code>查看修改的状态（工作区，暂存区）</p><p><code>git commit -m &quot;注释内容&quot;</code>将暂存区里的内容存到仓库当前分支中，日志为注释内容</p><p><code>vi 文件名</code>修改文件（编辑按i，退出的话按esc，在按：加上wq）</p><p><code>git log [option]</code>查看提交记录</p><p>option:</p><ol><li>–all 显示所有分支</li><li>–pretty&#x3D;oneline 将提交信息显示为一行</li><li>–abbrev-commit 使得输出的commitld更简短</li><li>–graph 以图的形式显示</li></ol><p>但是每次查看记录非常麻烦，因此可以用别名把这些内容缩短</p><p><code>alias 别名=&#39;操作&#39;</code>  如git-log</p><p><code>git reset --hard 日志</code>版本回退</p><ul><li>7c4b75b (HEAD -&gt; master) file change </li><li>45bae1d first</li></ul><p>日志就是前面的一串符号</p><p><code>git reflog</code>查看之前已经删除的日志记录</p><p>之前的git add . ，如果有不想管理的文件，那这个操作就非常麻烦，因此可以创建一个<code>.gitignore</code>文件来忽略</p><p><code>touch .gitignore</code></p><p>添加<code>*.a</code>来忽略所有以.a结尾的文件</p><p><code>分支</code></p><p>从主线上分开来开发新的功能，且不会影响主线</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251108151024575.png" alt="image-20251108151024575"></p><p>HEAD指向谁，谁就是当前分支</p><p><code>git branch</code>查看本地分支 （-vv  会展示更详细的内容）</p><p><code>git branch 分支名</code>创建本地分支</p><p><code>git checkout 分支名</code>切换分支</p><p><code>git checkout -b 分支名</code>创建并切换分支</p><p><code>git merge 分支名</code>合并分支（把分支名这个分支合并到当前分支）</p><p><code>git branch -d 分支名</code>删除分支（不能删除当前分支，只能删除其他分支）</p><p><code>git branch -D 分支名</code>强制删除分支：当要删除的分支没有合并到master时，用-d的话会提醒你没合并，这时候就用-D</p><p><code>冲突</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251108172458313.png" alt="image-20251108172458313"></p><p>两个分支修改的时候可能会产生冲突，例如修改了同一行代码，这时候就需要手动修改</p><p><code>github连接远程仓库</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">&quot;first commit&quot;</span></span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin https:<span class="comment">//github.com/XiDongWe/CangQiongWaiMai.git //修改一下</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p><code>git remote add &lt;远端名称&gt; &lt;仓库路径&gt;</code> 添加远程仓库 （远端名称一般是orrgin）</p><p><code>git remote</code>查看远程仓库</p><p><code>git push [远端名称[本地分支名][:远端分支名]</code>推送到远程仓库</p><p>若两个分支名相同，可省略[:远端分支名]</p><p><code>git clone &lt;仓库路径&gt; [本地目录]</code>克隆仓库</p><p><code>git fetch [远端名称] [分支名]</code>抓取指令，把仓库里的更新抓取到本地，不会进行合并</p><p><code>git pull [远端名称] [分支名]</code>拉取指令，就是fetch+merge(也会有冲突，按上文修改即可)</p>]]></content>
      
      
      <categories>
          
          <category> JAVAWEB </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Web后端开发心得</title>
      <link href="/2025/10/11/JAVAWEB/Web%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97/"/>
      <url>/2025/10/11/JAVAWEB/Web%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="Web后端开发心得"><a href="#Web后端开发心得" class="headerlink" title="Web后端开发心得"></a>Web后端开发心得</h1><p>关于一些基础知识，因为每天学的东西有点多，所以基础不太牢，遇见就记一下</p><ul><li>JSON</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;total&quot;</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="string">&quot;rows&quot;</span>: [ <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它是给前端（网页、小程序）看的，前端只认这种格式，别的看不懂</p><ul><li>序列化</li></ul><p>序列化 &#x3D; 把 Java 对象变成 JSON 字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PageResult</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageResult</span>();</span><br><span class="line">p.setTotal(<span class="number">30</span>);</span><br><span class="line">p.setRows(Arrays.asList(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>));</span><br></pre></td></tr></table></figure><p>变为下面这个</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;total&quot;</span><span class="punctuation">:</span><span class="number">30</span><span class="punctuation">,</span><span class="attr">&quot;rows&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span><span class="string">&quot;李四&quot;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>那怎么变为序列化？</p><p>一个叫 <strong>Jackson</strong> 的工具包（Spring Boot自带）</p><p>会自动把对象变为JSON</p><p>不过有规则：</p><ol><li>只认 public 的东西</li><li>public 字段 可以</li><li>private 字段 + public getter 也可以</li></ol><ul><li>setter&amp;getter</li></ul><p>没有这两个的话前端就接收不到信息，变为 { }</p><p>如果加上的话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageResult</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> total;</span><br><span class="line">    <span class="keyword">private</span> List rows;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTotal</span><span class="params">()</span> &#123; <span class="keyword">return</span> total; &#125;  <span class="comment">// ← 有了！</span></span><br><span class="line">    <span class="keyword">public</span> List <span class="title function_">getRows</span><span class="params">()</span> &#123; <span class="keyword">return</span> rows; &#125;    <span class="comment">// ← 有了！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就会接收到JSON语句，前端也就可以打印出来</p><p>比如员工管理那里PageResult不加上setter&amp;getter，前端就不会显示数据（浪费我一天，一定要牢记）</p><p>getter &#x3D; 拿值 setter &#x3D; 放值</p><p>当然也是因为lombok失效了:(</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> JAVAWEB </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WEB后端</title>
      <link href="/2025/09/25/JAVAWEB/WEB%E5%90%8E%E7%AB%AF/"/>
      <url>/2025/09/25/JAVAWEB/WEB%E5%90%8E%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250925135424815.png" alt="image-20250925135424815"></p><ul><li>Maven坐标</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250925151518259.png" alt="image-20250925151518259"></p><ul><li>配置依赖</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250925154048279.png" alt="image-20250925154048279"></p><ul><li>排除依赖</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250925154525058.png" alt="image-20250925154525058"></p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250925154947556.png" alt="image-20250925154947556"></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250925155153240.png" alt="image-20250925155153240"></p><p>执行方式：</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250925155223543.png" alt="image-20250925155223543"></p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250925190948197.png" alt="image-20250925190948197"></p><ul><li>测试方法</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250925191304026.png" alt="image-20250925191304026"></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250925191530543.png" alt="image-20250925191530543"></p><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250925191853121.png" alt="image-20250925191853121"></p><ul><li>Junit</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250925192218766.png" alt="image-20250925192218766"></p><ul><li>常见注解</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250925195355218.png" alt="image-20250925195355218"></p><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250925193724415.png" alt="image-20250925193724415"></p><h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250925203558124.png" alt="image-20250925203558124"></p><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><p>项目搭建</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250927161522337.png" alt="image-20250927161522337"></p><p>勾选的选项：</p><p>Lombok,Spring Web,MyBatis Framework,MySQL Driver</p><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250927161707278.png" alt="image-20250927161707278"></p><h2 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h2><ul><li>请求行</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250927162114795.png" alt="image-20250927162114795"></p><ul><li>请求头</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250927162152781.png" alt="image-20250927162152781"></p><ul><li>请求体</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250927162241514.png" alt="image-20250927162241514"></p><h2 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250927163646113.png" alt="image-20250927163646113"></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250927164705804.png" alt="image-20250927164705804"></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250927165230321.png" alt="image-20250927165230321"></p><h1 id="分层解耦-IOC-DI"><a href="#分层解耦-IOC-DI" class="headerlink" title="分层解耦 IOC DI"></a>分层解耦 IOC DI</h1><h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250927194728287.png" alt="image-20250927194728287"></p><h2 id="分层解耦"><a href="#分层解耦" class="headerlink" title="分层解耦"></a>分层解耦</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250927210328298.png" alt="image-20250927210328298"></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250927210008748.png" alt="image-20250927210008748"></p><p>步骤</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250927210748471.png" alt="image-20250927210748471"></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250927212639179.png" alt="image-20250927212639179"></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250927214809752.png" alt="image-20250927214809752"></p><h1 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h1><p><code>连接：</code></p><p>mysql -u用户名 -密码 [-h数据库服务器IP地址  -P端口号]</p><p>mine：mysql -uroot -pshenentao520 </p><p><code>退出:</code> exit</p><ul><li>关系型数据库</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250928122729409.png" alt="image-20250928122729409"></p><h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250928123528214.png" alt="image-20250928123528214"></p><h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250928123717437.png" alt="image-20250928123717437"></p><p>其中<code>database</code>可以换成<code>schema</code></p><h3 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h3><ul><li>创建</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250928131355727.png" alt="image-20250928131355727"></p><p><code>约束：</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250928132506956.png" alt="image-20250928132506956"></p><ul><li>数值类型</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250928170948861.png" alt="image-20250928170948861"></p><ul><li>字符串类型</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250928171525880.png" alt="image-20250928171525880"></p><ul><li>日期时间类型</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250928171648624.png" alt="image-20250928171648624"></p><ul><li>查询，修改，删除</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250928184930545.png" alt="image-20250928184930545"></p><h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250928185417588.png" alt="image-20250928185417588"></p><h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250928190704936.png" alt="image-20250928190704936"></p><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250928191136436.png" alt="image-20250928191136436"></p><h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250928194510615.png" alt="image-20250928194510615"></p><h3 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h3><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250928194648145.png" alt="image-20250928194648145"></p><p>不推荐用第二个</p><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250928195859361.png" alt="image-20250928195859361"></p><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><ul><li>聚合函数</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250928201151013.png" alt="image-20250928201151013"></p><p><code>注：</code>聚合函数不参与null的统计</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250928201822808.png" alt="image-20250928201822808"></p><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250928203653117.png" alt="image-20250928203653117"></p><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250928204457073.png" alt="image-20250928204457073"></p><p><code>起始索引：</code>(页码 - 1) * 每页展示记录数</p><h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250929105746838.png" alt="image-20250929105746838"></p><p><code>格式：</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250929105828238.png" alt="image-20250929105828238"></p><p><code>查询：</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250929110043956.png" alt="image-20250929110043956"></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250929110950913.png" alt="image-20250929110950913"></p><h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><ul><li>查询数据</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251007105923718.png" alt="image-20251007105923718"></p><ul><li>删除用户</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251007140028682.png" alt="image-20251007140028682"></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251007140649624.png" alt="image-20251007140649624"></p><ul><li>新增用户</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251007141432140.png" alt="image-20251007141432140"></p><ul><li>修改用户</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251007145433061.png" alt="image-20251007145433061"></p><ul><li>查询用户</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251007145919520.png" alt="image-20251007145919520"></p><h2 id="XML映射配置"><a href="#XML映射配置" class="headerlink" title="XML映射配置"></a>XML映射配置</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251007151213707.png" alt="image-20251007151213707"></p><h2 id="yml配置文件"><a href="#yml配置文件" class="headerlink" title="yml配置文件"></a>yml配置文件</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251008124858916.png" alt="image-20251008124858916"></p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251013105258319.png" alt="image-20251013105258319"></p><p>如添加员工的操作包括保存员工信息和经历信息，两者有一个有误的话会对添加员工有影响，所以要通过事务来让两者同时成功或失败</p><p>操作：</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251013105336579.png" alt="image-20251013105336579"></p><ul><li>动态遍历</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251013124602861.png" alt="image-20251013124602861"></p><h2 id="事务管理-控制事务"><a href="#事务管理-控制事务" class="headerlink" title="事务管理-控制事务"></a>事务管理-控制事务</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251013110707141.png" alt="image-20251013110707141"></p><h1 id="阿里云OSS"><a href="#阿里云OSS" class="headerlink" title="阿里云OSS"></a>阿里云OSS</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251014105703206.png" alt="image-20251014105703206"></p><h2 id="参数化配置"><a href="#参数化配置" class="headerlink" title="参数化配置"></a>参数化配置</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251015105534267.png" alt="image-20251015105534267"></p><ul><li>ConfigurationProperties</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251015105352513.png" alt="image-20251015105352513"></p><h1 id="登录认证"><a href="#登录认证" class="headerlink" title="登录认证"></a>登录认证</h1><h2 id="登录校验"><a href="#登录校验" class="headerlink" title="登录校验"></a>登录校验</h2><ul><li>Cookie</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251018131851307.png" alt="image-20251018131851307"></p><p>先通过响应头Set-Cookie把Cookie保存在浏览器上，在通过请求头获取到Cookie</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251018131737035.png" alt="image-20251018131737035"></p><ul><li>Session</li></ul><p>与Cookie相似，唯一区别就是在浏览器中保存的是Session的唯一标识（id），前端看不到具体信息，相对安全</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251018133212132.png" alt="image-20251018133212132"></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251018132534248.png" alt="image-20251018132534248"></p><ul><li>令牌</li></ul><p>如同身份证一样，真的身份证就通过，伪造的就不行</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251018133526145.png" alt="image-20251018133526145"></p><p>JWT令牌</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251018192747596.png" alt="image-20251018192747596"></p><p>生成&#x2F;解析</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251018193157641.png" alt="image-20251018193157641"></p><h2 id="过滤器Filter"><a href="#过滤器Filter" class="headerlink" title="过滤器Filter"></a>过滤器Filter</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251019134531937.png" alt="image-20251019134531937"></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251019134804620.png" alt="image-20251019134804620"></p><ul><li>令牌校验</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.tliaswebmanagment.Filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.tliaswebmanagment.utils.JwtUtils;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.*;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse) servletResponse;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.获取请求路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">requestURI</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        <span class="comment">//2.判断时候是登录请求，如果路径中包含/login,说明是登录操作，放行</span></span><br><span class="line">        log.info(<span class="string">&quot;登陆成功，放行&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (requestURI.contains(<span class="string">&quot;/login&quot;</span>))&#123;</span><br><span class="line">            filterChain.doFilter(request,response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.获取请求头中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.判断token时候存在，如果不存在，说明用户没登录，返回错误信息（401）</span></span><br><span class="line">        <span class="keyword">if</span> (token == <span class="literal">null</span> || token.isEmpty())&#123;</span><br><span class="line">            log.info(<span class="string">&quot;令牌为空，响应401&quot;</span>);</span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.如果token存在，校验令牌，如果校验失败，返回错误信息（401）</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JwtUtils.parseToken(token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;令牌为空，响应401&quot;</span>);</span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//校验通过，放行</span></span><br><span class="line">        log.info(<span class="string">&quot;令牌通过，放行&quot;</span>);</span><br><span class="line">        filterChain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拦截器Intercepter"><a href="#拦截器Intercepter" class="headerlink" title="拦截器Intercepter"></a>拦截器Intercepter</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251019152258627.png" alt="image-20251019152258627"></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251020123952819.png" alt="image-20251020123952819"></p><ol><li><strong>先过安检门（Interceptor）</strong><ul><li>preHandle()  —— 进门检查：鉴权、限流、日志、包装请求……<br>返回 true → 放行；返回 false → 直接打回（后面全不执行）</li></ul></li><li>到达 <strong>Controller</strong> 执行业务</li><li>业务办完，回来再过安检门<ul><li>postHandle() —— 出门检查：可以改 <strong>ModelAndView</strong>（数据+页面），但异常时不会进来</li></ul></li><li>渲染视图（JSON&#x2F;HTML 等）</li><li>最后再过一次安检门<ul><li>afterCompletion() —— 无论成功失败都会进：清理资源、记录耗时、统计异常……</li></ul></li></ol><ul><li>拦截路径</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251020132331114.png" alt="image-20251020132331114"></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251020133231922.png" alt="image-20251020133231922"></p><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251020184618049.png" alt="image-20251020184618049"></p><p><code>步骤</code>：</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251020185201398.png" alt="image-20251020185201398"></p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251020191951243.png" alt="image-20251020191951243"></p><ol><li>连接点 JoinPoint<br>&#x3D; 整部电影里<strong>每一句台词</strong>（每一个方法）。<br>特效师可以<strong>随时在任意一句台词上做手脚</strong>，但还没决定到底改哪句。</li><li>通知 Advice<br>&#x3D; 具体加的特效本身：“火焰怎么烧、烧多久”。<br>在代码里就是<strong>一个普通方法</strong>，里面写“记录时间、开事务、打日志”这些<strong>重复动作</strong>。<br>一句话：<strong>“改什么内容”</strong>。</li><li>切入点 PointCut<br>&#x3D; 特效师<strong>真正挑选</strong>的那些台词：“只要男主角说英文，就加火焰特效”。<br>一句话：<strong>“要改哪里”</strong>。</li><li>切面 Aspect<br>&#x3D; 把“要改哪里”和“改什么内容”<strong>订在一起</strong>的合同：<br>“男主角英文台词 + 火焰特效”合成一张<strong>特效表</strong>，这就是切面。<br>一句话：<strong>“切入点 + 通知”的配对</strong>。</li><li>目标对象 Target<br>&#x3D; 被加特效的<strong>男主角本人</strong>（原始业务类，如 <code>DeptServiceImpl</code>）。<br>他<strong>完全不知道</strong>自己被烧了火焰，照常背台词。</li></ol><ul><li>执行流程</li></ul><p><img src="/./C:/Users/20673/AppData/Roaming/Typora/typora-user-images/image-20251020192514362.png" alt="image-20251020192514362"></p><p>当 Spring 容器启动时，如果发现某个 Bean（例如 <code>DeptServiceImpl</code>）的方法匹配了 <code>@Aspect</code> 切面里定义的切入点表达式，就会<strong>提前</strong>为它生成一个<strong>动态代理对象</strong>（JDK 动态代理或 CGLIB 代理）。<br>这个代理对象<strong>实现了与目标对象相同的接口</strong>（或是目标对象的子类），因此<strong>方法签名完全一致</strong>，从外表上看两者没有任何区别。</p><p>在代理对象的<strong>同名方法</strong>内部，Spring 会把我们定义的<strong>通知代码</strong>（如 <code>@Around</code>、<code>@Before</code>、<code>@After</code> 等）织入进去：<br>先执行切面里写的<strong>附加逻辑</strong>（如记录时间、开启事务、权限校验），再通过 <code>joinPoint.proceed()</code> <strong>回调原始目标对象的真实方法</strong>，最后再执行<strong>后置逻辑</strong>。</p><p>因此，当 Controller 中通过 <code>@Autowired</code> 注入 <code>DeptService</code> 并调用 <code>deptService.list()</code> 时，<strong>实际拿到的是容器里的代理对象</strong>，而不是原始的目标对象。<br>这次调用<strong>首先进入的是代理方法</strong>，从而<strong>自动触发了 AOP 的逻辑</strong>；也正因为如此，AOP 只对**“从外部穿过代理对象”<strong>的方法调用生效，而</strong>类内部自调用**（如 <code>this.list()</code>）则不会触发代理，也就<strong>不会进入切面</strong>。</p><h2 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h2><p>内部</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251021193711050.png" alt="image-20251021193711050"></p><p>外部</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251022125507823.png" alt="image-20251022125507823"></p><p>jar包的话用maven里的package</p><p><img src="/C:/Users/20673/AppData/Roaming/Typora/typora-user-images/image-20251022125620194.png" alt="image-20251022125620194"></p><h2 id="通知顺序"><a href="#通知顺序" class="headerlink" title="通知顺序"></a>通知顺序</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251021190651896.png" alt="image-20251021190651896"></p><h2 id="切入点表达式execution-annotation"><a href="#切入点表达式execution-annotation" class="headerlink" title="切入点表达式execution&amp;annotation"></a>切入点表达式execution&amp;annotation</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251021191229321.png" alt="image-20251021191229321"></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251021191452730.png" alt="image-20251021191452730"></p><h2 id="连接点"><a href="#连接点" class="headerlink" title="连接点"></a>连接点</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251021192127691.png" alt="image-20251021192127691"></p><h1 id="原理篇"><a href="#原理篇" class="headerlink" title="原理篇"></a>原理篇</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251022124406118.png" alt="image-20251022124406118"></p><p>jar包的话用maven里的package</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251022125620194.png" alt="image-20251022125620194"></p><p>然后再target里找</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251022125757449.png" alt="image-20251022125757449"></p><h1 id="Maven-1"><a href="#Maven-1" class="headerlink" title="Maven"></a>Maven</h1><h2 id="分模块设计"><a href="#分模块设计" class="headerlink" title="分模块设计"></a>分模块设计</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251022130730476.png" alt="image-20251022130730476"></p><p>对开发和维护更有利，增加复用性</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251022130955573.png" alt="image-20251022130955573"></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251022185027263.png" alt="image-20251022185027263"></p><p>打包方式用<code>&lt;package&gt;...&lt;/package&gt;</code>修改</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251022184946665.png" alt="image-20251022184946665"></p><p>只支持单继承，不能多继承，但可以多重继承</p><ul><li>版本锁定</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251022191340691.png" alt="image-20251022191340691"></p><ul><li>自定义属性</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251022191154430.png" alt="image-20251022191154430"></p><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20251022192210487.png" alt="image-20251022192210487"></p>]]></content>
      
      
      <categories>
          
          <category> JAVAWEB </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WEB前端</title>
      <link href="/2025/09/22/JAVAWEB/HTML-CSS/"/>
      <url>/2025/09/22/JAVAWEB/HTML-CSS/</url>
      
        <content type="html"><![CDATA[<p><code>Web标准</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250922174552475.png" alt="image-20250922174552475"></p><h1 id="HTML-css"><a href="#HTML-css" class="headerlink" title="HTML&amp;css"></a>HTML&amp;css</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250922191101603.png" alt="image-20250922191101603"></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250922191935091.png" alt="image-20250922191935091"></p><p>具体可以到MDN找</p><h2 id="HTML结构"><a href="#HTML结构" class="headerlink" title="HTML结构"></a>HTML结构</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250922192249931.png" alt="image-20250922192249931"></p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>格式：</p><p><a href="网站地址" target="_blank(新窗口打开) / _self(本窗口打开，默认的)">网站名字</a></p><h2 id="css引入格式"><a href="#css引入格式" class="headerlink" title="css引入格式"></a>css引入格式</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250922203230032.png" alt="image-20250922203230032"></p><h2 id="颜色表示形式"><a href="#颜色表示形式" class="headerlink" title="颜色表示形式"></a>颜色表示形式</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250922204854018.png" alt="image-20250922204854018"></p><p>css选择器</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250922212559680.png" alt="image-20250922212559680"></p><p>如：<span class="..." id="...">…</span></p><p>优先级：id &gt; 类 &gt; 元素</p><p><code>图片</code></p><p>&lt;img src&#x3D;”…” alt&#x3D;”…”     src: 属性 存放图片的路径 alt: 描述图片 </p><p><code>视频</code></p><p><video src="..." controls ></video></p><p> controls 添加控制条<br> autoplay 自动播放<br> loop 循环播放<br> muted 静音播放<br> poster 添加封面图片<br> width 宽度<br> height 高度</p><p>​     </p><p>&lt; br &gt; 换行</p><p>&lt; p &gt; 标签可以框选文字，会自动换行</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250923122549957.png" alt="image-20250923122549957"></p><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250923124105313.png" alt="image-20250923124105313"></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250923124039984.png" alt="image-20250923124039984"></p><h2 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250923191834298.png" alt="image-20250923191834298"></p><h2 id="表单项"><a href="#表单项" class="headerlink" title="表单项"></a>表单项</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250923191926121.png" alt="image-20250923191926121"></p><h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250923200131892.png" alt="image-20250923200131892"></p><h2 id="JS引入方法"><a href="#JS引入方法" class="headerlink" title="JS引入方法"></a>JS引入方法</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250923200419443.png" alt="image-20250923200419443"></p><h2 id="变量-常量"><a href="#变量-常量" class="headerlink" title="变量&amp;常量"></a>变量&amp;常量</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250923201129386.png" alt="image-20250923201129386"></p><ul><li>输出语句</li></ul><p>window.alert() : 弹出警告框(使用频率高)   window.可以省略</p><p>console.log()  ： 写入浏览器控制台(使用频率高)</p><p>document.write() :想HTML的body内输出内容(使用频率低)</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250923202540881.png" alt="image-20250923202540881"></p><p>模版字符串</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250923203042866.png" alt="image-20250923203042866"></p><p>反引号在键盘左上角</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>具名函数</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250923211646267.png" alt="image-20250923211646267"></p><p>匿名函数</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250923212114255.png" alt="image-20250923212114255"></p><h2 id="自定义对象"><a href="#自定义对象" class="headerlink" title="自定义对象"></a>自定义对象</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250924104012013.png" alt="image-20250924104012013"></p><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureSnipaste_2025-09-24_10-47-37.png" alt="Snipaste_2025-09-24_10-47-37"></p><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureSnipaste_2025-09-24_10-59-50.png" alt="Snipaste_2025-09-24_10-59-50"></p><ul><li>操作</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250924110232131.png" alt="image-20250924110232131"></p><h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250924111115489.png" alt="image-20250924111115489"></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250924111305447.png" alt="image-20250924111305447"></p><ul><li>常见事件</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250924190500465.png" alt="image-20250924190500465"></p><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250924192258799.png" alt="image-20250924192258799"></p><h1 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250924194953576.png" alt="image-20250924194953576"></p><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250924195306148.png" alt="image-20250924195306148"></p><ul><li>v-for</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250924195737291.png" alt="image-20250924195737291"></p><ul><li>v-bind</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250924203824700.png" alt="image-20250924203824700"></p><ul><li>v-if &amp; v-show</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250924204526419.png" alt="image-20250924204526419"></p><ul><li>v-model</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250924205540757.png" alt="image-20250924205540757"></p><ul><li>v-on</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250924210438237.png" alt="image-20250924210438237"></p><h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250924211025624.png" alt="image-20250924211025624"></p><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250924211303372.png" alt="image-20250924211303372"></p><h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250924211558373.png" alt="image-20250924211558373"></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250924212332845.png" alt="image-20250924212332845"></p>]]></content>
      
      
      <categories>
          
          <category> JAVAWEB </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络编程</title>
      <link href="/2025/09/21/JAVASE/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2025/09/21/JAVASE/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250921125338905.png" alt="image-20250921125338905"></p><h1 id="网路编程三要素"><a href="#网路编程三要素" class="headerlink" title="网路编程三要素"></a>网路编程三要素</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250921125718348.png" alt="image-20250921125718348"></p><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250921130246415.png" alt="image-20250921130246415"></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250921131939036.png" alt="image-20250921131939036"></p><h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250921132102242.png" alt="image-20250921132102242"></p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250921132555263.png" alt="image-20250921132555263"></p><p><code>UDP发送数据</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建DatagramSocket对象</span></span><br><span class="line"><span class="comment">//空参：所有可用端口中随机一个进行使用</span></span><br><span class="line"><span class="comment">//有参：指定端口号进行绑定</span></span><br><span class="line"><span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//打包数据</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;泥嚎&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] bytes = str.getBytes();</span><br><span class="line"></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">byName</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">10086</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes,bytes.length,byName,port);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line">ds.send(dp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">ds.close();</span><br></pre></td></tr></table></figure><p><code>UDP接收数据</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建DatagramSocket对象</span></span><br><span class="line"><span class="comment">//在接收的时候，一定要绑定端口</span></span><br><span class="line"><span class="comment">//而且绑定的端口一定要与发送的端口保持一致</span></span><br><span class="line"><span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">10086</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收数据包</span></span><br><span class="line"><span class="comment">//创建一个数组来接收数据</span></span><br><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析数据包</span></span><br><span class="line"><span class="type">byte</span>[] data = dp.getData();</span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> dp.getAddress();</span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> dp.getLength();</span><br><span class="line"><span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> dp.getPort();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">ds.close();</span><br></pre></td></tr></table></figure><p><code>UDP三种通信方式</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250921152928921.png" alt="image-20250921152928921"></p><p><code>TCP</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250921153400641.png" alt="image-20250921153400641"></p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/2025/09/19/JAVASE/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2025/09/19/JAVASE/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><code>多线程</code>就是在实施某一程序的空闲时间内去实施另一程序，可以提高运行效率</p><h1 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h1><p><code>并发</code>：在同一时刻，有多个指令在单个CPU上<code>交替</code>执行</p><p><code>并行</code>：在同一时刻，有多个指令在多个CPU上<code>同时</code>执行</p><h1 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h1><h2 id="继承Thread类的"><a href="#继承Thread类的" class="headerlink" title="继承Thread类的"></a>继承Thread类的</h2><ul><li><p>定义一个类继承Thread</p></li><li><p>重写run方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Thread &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;日奈&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建子类的对象，并启动线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><p>用start就是启动线程，而用run的话就是单纯的调用方法</p><h2 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h2><ul><li>定义一个类继承Runnable</li><li>重写run方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRun</span> <span class="keyword">implements</span> <span class="title class_">java</span>.lang.Runnable &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;日奈&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p><ul><li>创建自己类的对象</li><li>创建Thread类的对象，并开启线</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyRun</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRun</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><h2 id="利用Callable接口和Future接口"><a href="#利用Callable接口和Future接口" class="headerlink" title="利用Callable接口和Future接口"></a>利用Callable接口和Future接口</h2><ul><li>创建自己类（如MyCallable）实现Callable接口</li><li>重写call（有返回值）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            p += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建MyCallable的对象（表示多线程要执行的任务）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyCallable</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br></pre></td></tr></table></figure><ul><li>创建FutureTask的对象（管理多线程运行的结果）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(mc);</span><br></pre></td></tr></table></figure><ul><li>创建Thread类的对象，并启动</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><ul><li>获取多线程运行的结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> ft.get();</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure><h1 id="常见成员方法"><a href="#常见成员方法" class="headerlink" title="常见成员方法"></a>常见成员方法</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250918201328275.png" alt="image-20250918201328275"></p><p>优先级：最低为1，最高为10</p><p>守护线程：就相当于备胎</p><p>当非守护线程执行完毕后，守护线程会执行一段时间，在结束(不会执行所有)</p><p><code>线程的生命周期</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250918205040016.png" alt="image-20250918205040016"></p><h1 id="同步代码块-同步方法"><a href="#同步代码块-同步方法" class="headerlink" title="同步代码块&amp;同步方法"></a>同步代码块&amp;同步方法</h1><p>当有多个线程启动的时候，会发生一系列错误</p><p>如：a线程运行的时候，还没运行完成，这时b线程抢夺了a线程的位置而实行b线程，导致结果出问题</p><p>这时候就要在a线程运行的时候把线程<code>锁住</code> 而不让其他的线程插入进来</p><p><code>同步代码块</code>：</p><p>synchronized (锁) {</p><p>​操作共享数据的代码</p><p>}</p><p>其中“锁”要是唯一的，所以定义时要用static</p><p>如：static Object oj &#x3D; new Object();</p><p><code>特点</code>：</p><ul><li>锁默认打开，有一个线程进去了，锁自动关闭</li><li>里面的代码全部执行完毕，线程出来，锁自动打开</li></ul><p><code>同步方法</code>：</p><p>就可以看作把同步代码块中synchronized提取出来</p><p><code>格式</code>：</p><p>修饰符 synchronized 返回值类型 命名 (参数){…}</p><p><code>特点</code>：</p><ul><li>同步方法是锁住方法里面所有的代码</li><li>锁对象不能自己指定: <code>非静态</code> this  <code>静态</code> 当前类的字节码文件对象(文件名.class)</li></ul><h1 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250919192114492.png" alt="image-20250919192114492"></p><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250919194427149.png" alt="image-20250919194427149"></p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>按照之前的多线程的方法，都是用完就扔了，既浪费资源又浪费时间，因此通过<code>线程池</code>把线程存储起来</p><p><code>原理</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250920204838315.png" alt="image-20250920204838315"></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250920205042186.png" alt="image-20250920205042186"></p><p><code>提交任务</code>：对象.submit()</p><p><code>销毁线程池</code>：对象.shutdown()</p><h1 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250920210214496.png" alt="image-20250920210214496"></p><p>当核心线程和队伍都满的时候，临时线程才会处理剩下的线程78，并不会先处理456</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250920210508911.png" alt="image-20250920210508911"></p><p>如果有是个线程，多出来的任务10会触发<code>任务拒绝策略</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250920210854361.png" alt="image-20250920210854361"></p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO流</title>
      <link href="/2025/07/22/JAVASE/IO%E6%B5%81/"/>
      <url>/2025/07/22/JAVASE/IO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>IO流就是读取和存储数据的解决方案</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250722194923088.png" alt="image-20250722194923088"></p><p><code>结构：</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250722201616381.png" alt="image-20250722201616381"></p><h1 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250722201704545.png" alt="image-20250722201704545"></p><h2 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h2><p>可以把程序中的数据写到本地文件中</p><p><code>步骤：</code></p><ul><li>创建对象</li></ul><p>FileOutputStream f1 &#x3D; new FileOutputStream(“Test7\bb.txt”);         </p><ul><li>写数据</li></ul><p>f1.write(97);         </p><ul><li>释放资源</li></ul><p>f1.close();</p><p><code>一定要释放</code></p><h2 id="FileOutputStream写数据的3种方法"><a href="#FileOutputStream写数据的3种方法" class="headerlink" title="FileOutputStream写数据的3种方法"></a>FileOutputStream写数据的3种方法</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250727183210188.png" alt="image-20250727183210188"></p><ul><li>换行写</li></ul><p>只需加个换行符就行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">w</span> <span class="operator">=</span> <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] bytes1 = w.getBytes();</span><br><span class="line">f1.write(bytes1);</span><br></pre></td></tr></table></figure><ul><li>续写</li></ul><p>如果想要续写而不是清空原文件，只需在创建文件时的第二个参数选择true或false即可</p><p>FileOutputStream f1 &#x3D; new FileOutputStream(“Test7\bb.txt”，true&#x2F;false);   </p><ul><li>循环读取</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="keyword">while</span>((b = f2.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println((<span class="type">char</span>)b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h1><p><code>特点</code></p><p>一次读一个字节，遇到中文时，一次读多个字节</p><h2 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250909180710104.png" alt="image-20250909180710104"></p><p><code>步骤</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250909180917165.png" alt="image-20250909180917165"></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250909181219589.png" alt="image-20250909181219589"></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250909181254345.png" alt="image-20250909181254345"></p><h2 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h2><p><code>构造方法</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250909181747878.png" alt="image-20250909181747878"></p><p><code>成员方法</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250909181913301.png" alt="image-20250909181913301"></p><p><code>细节</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250909182059305.png" alt="image-20250909182059305"></p><p><code>使用场景</code></p><p>字节流：拷贝任意类型的文件</p><p>字符流：读取纯文本文件中的数据，往纯文本文件中写出数据</p><p><code>^</code>: 异或<br>两边相同：false<br>两边不同：true</p><p>当一个数字异或另一个数字两次，即可还原</p><h1 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250910164423829.png" alt="image-20250910164423829"><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250910164508193.png" alt="image-20250910164508193"></p><h1 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250910164544520.png" alt="image-20250910164544520"></p><h1 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250910164828023.png" alt="image-20250910164828023"></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250910165244009.png" alt="image-20250910165244009"></p><p>但是直接用的话会报错，因此要在对象类中（如Student），&#96;&#96;implements Serializable&#96;</p><p>一旦实现了这个接口，就表示当前的Student类可以被序列化</p><h1 id="反序列化流"><a href="#反序列化流" class="headerlink" title="反序列化流"></a>反序列化流</h1><p>用序列化流写到文件之后会看不懂，因此要用反序列化流</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250910165925979.png" alt="image-20250910165925979"></p><h1 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250910172817349.png" alt="image-20250910172817349"></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250910172932427.png" alt="image-20250910172932427"></p><h2 id="字节打印流"><a href="#字节打印流" class="headerlink" title="字节打印流"></a>字节打印流</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250910173120104.png" alt="image-20250910173120104"></p><p>不过字节打印流没有缓冲区，刷不刷新都一样</p><h2 id="字符打印流"><a href="#字符打印流" class="headerlink" title="字符打印流"></a>字符打印流</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250911132359916.png" alt="image-20250911132359916"></p><h1 id="压缩流"><a href="#压缩流" class="headerlink" title="压缩流"></a>压缩流</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250911132444154.png" alt="image-20250911132444154"></p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>File</title>
      <link href="/2025/07/22/JAVASE/File/"/>
      <url>/2025/07/22/JAVASE/File/</url>
      
        <content type="html"><![CDATA[<p>创建文件对象</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250721194605559.png" alt="image-20250721194605559"></p><p>String 名 &#x3D; new File(…);</p><h1 id="判断-获取"><a href="#判断-获取" class="headerlink" title="判断&#x2F;获取"></a>判断&#x2F;获取</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250722104048942.png" alt="image-20250722104048942"></p><h1 id="创建-删除"><a href="#创建-删除" class="headerlink" title="创建&#x2F;删除"></a>创建&#x2F;删除</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250722105753121.png" alt="image-20250722105753121"></p><p>一般用mkdirs就可以了</p><h1 id="获取并遍历"><a href="#获取并遍历" class="headerlink" title="获取并遍历"></a>获取并遍历</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250722192810107.png" alt="image-20250722192810107"></p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>十大建模操作</title>
      <link href="/2025/07/21/%E5%BB%BA%E6%A8%A1/%E5%8D%81%E5%A4%A7%E5%BB%BA%E6%A8%A1%E6%93%8D%E4%BD%9C/"/>
      <url>/2025/07/21/%E5%BB%BA%E6%A8%A1/%E5%8D%81%E5%A4%A7%E5%BB%BA%E6%A8%A1%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="点线面"><a href="#点线面" class="headerlink" title="点线面"></a>点线面</h1><p>tap进入编辑模式</p><p>1,2,3，各对应点，线，面</p><p>选中一个点按alt可以选横向纵向</p><p>选中一个线按ctrl+alt可以选横向</p><h1 id="四大"><a href="#四大" class="headerlink" title="四大"></a>四大</h1><h2 id="向外挤出"><a href="#向外挤出" class="headerlink" title="向外挤出"></a>向外挤出</h2><p>打开编辑模式，选择面，按<code>E</code>即可挤出</p><p>按<code>shift</code>可以选择坐标方向</p><p>按<code>S</code>放大缩小</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250718133733442.png" alt="image-20250718133733442"></p><p>点模式下<code>ctrl+右键</code>可以挤出一条线</p><p>线模式下<code>E</code>可以从线中拉出面</p><h2 id="向内挤出"><a href="#向内挤出" class="headerlink" title="向内挤出"></a>向内挤出</h2><p>按<code>I</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250718134604000.png" alt="image-20250718134604000"></p><h2 id="倒角"><a href="#倒角" class="headerlink" title="倒角"></a>倒角</h2><p><code>ctrl+B</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250718134756037.png" alt="image-20250718134756037"></p><p>按鼠标滚轮可以增加段数</p><p>选面也可以</p><h2 id="循环切割"><a href="#循环切割" class="headerlink" title="循环切割"></a>循环切割</h2><p><code>ctrl+R</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250718135123416.png" alt="image-20250718135123416"></p><p>选择挤出各个面可以将切割的面分开，这样可以分开移动，而不会整体移动</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250718140212819.png" alt="image-20250718140212819"></p><h1 id="六小"><a href="#六小" class="headerlink" title="六小"></a>六小</h1><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p><code>M</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250718140556986.png" alt="image-20250718140556986"></p><h2 id="断开"><a href="#断开" class="headerlink" title="断开"></a>断开</h2><p><code>V</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250718140901193.png" alt="image-20250718140901193"></p><h2 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h2><p><code>F</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250718141050986.png" alt="image-20250718141050986"></p><p>先alt全选在填充</p><h2 id="切刀"><a href="#切刀" class="headerlink" title="切刀"></a>切刀</h2><p><code>K</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250718142041601.png" alt="image-20250718142041601"></p><h2 id="桥接"><a href="#桥接" class="headerlink" title="桥接"></a>桥接</h2><p><code>ctrl+E</code></p><ol><li>把想要拼接的两个物体对应的面删掉</li><li>在把两物体连接为一个整体(shift选择，ctrl+j连接)</li><li>alt双击选择两物体对应的线，如图</li><li>右键<code>桥接循环边</code>连接即可<br><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250718143308595.png" alt="image-20250718143308595"></li></ol><h2 id="分离"><a href="#分离" class="headerlink" title="分离"></a>分离</h2><p><code>P</code></p><p>字面意思</p>]]></content>
      
      
      <categories>
          
          <category> 建模 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>方法引用</title>
      <link href="/2025/07/21/JAVASE/%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"/>
      <url>/2025/07/21/JAVASE/%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250719135946701.png" alt="image-20250719135946701"></p><h1 id="引用静态方法"><a href="#引用静态方法" class="headerlink" title="引用静态方法"></a>引用静态方法</h1><p>其中的方法如果是静态static，就要用 <code>类名::静态方法方法</code> 的格式写</p><p><code>::</code>是方法引用符</p><h1 id="引用成员方法"><a href="#引用成员方法" class="headerlink" title="引用成员方法"></a>引用成员方法</h1><p><code>格式：</code>对象::成员方法</p><ol><li><code>其他类：</code>其他类对象::方法名</li><li><code>本类：</code>this::方法名</li><li><code>父类：</code>super::方法名</li></ol><h1 id="引用构造方法"><a href="#引用构造方法" class="headerlink" title="引用构造方法"></a>引用构造方法</h1><p><code>格式：</code>类名::new</p><h1 id="使用类名引用成员方法"><a href="#使用类名引用成员方法" class="headerlink" title="使用类名引用成员方法"></a>使用类名引用成员方法</h1><p><code>格式：</code>类名::成员方法</p><h1 id="引用数组的构造方法"><a href="#引用数组的构造方法" class="headerlink" title="引用数组的构造方法"></a>引用数组的构造方法</h1><p><code>格式：</code>数据类型[]::new</p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stream流</title>
      <link href="/2025/07/18/JAVASE/Stream%E6%B5%81/"/>
      <url>/2025/07/18/JAVASE/Stream%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><p>​就像工厂流水线一样，通过对产品的一系列改造，最后得出商品</p><h1 id="1-先获取一条Stream流，并把数据放上去"><a href="#1-先获取一条Stream流，并把数据放上去" class="headerlink" title="1.先获取一条Stream流，并把数据放上去"></a>1.先获取一条Stream流，并把数据放上去</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250715145212013.png" alt="image-20250715145212013"></p><h1 id="2-Stream流中间方法"><a href="#2-Stream流中间方法" class="headerlink" title="2.Stream流中间方法"></a>2.Stream流中间方法</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250715151404682.png" alt="image-20250715151404682"></p><ul><li>filter过滤</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.addAll(list,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; stream1 = list.stream();</span><br><span class="line">stream1.filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.equals(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure><p>return 如果是true，则返回，false，则不返回</p><p>也可以接上自己想要的条件</p><p><code>建议使用链式方程</code>，代码更简洁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream1.filter(s -&gt; s.equals(<span class="string">&quot;a&quot;</span>)).forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure><ul><li>limit</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream1.limit(<span class="number">2</span>).forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure><ul><li>skip</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream1.skip(<span class="number">2</span>).forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure><ul><li>distinct</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream1.distinct().forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure><ul><li><p>contact</p></li><li><p>map</p></li></ul><h1 id="3-Stream流中的终结方法"><a href="#3-Stream流中的终结方法" class="headerlink" title="3.Stream流中的终结方法"></a>3.Stream流中的终结方法</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250715155911140.png" alt="image-20250715155911140"></p><p>其中collect要用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.collect(Collectors.类型)</span><br></pre></td></tr></table></figure><p>如果是双列集合map的话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.collec(Collectors.toMap(键的规则,值的规则))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中键和值的规则的格式为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.collect(Collectors.toMap(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;流当中数据的类型, 键的类型&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(String s)</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="keyword">new</span> <span class="title class_">Function</span>&lt;流当中数据的类型, 值的类型&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(String s)</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br></pre></td></tr></table></figure><p>最后华为lambda表达式即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.collect(Collectors.toMap(s -&gt; s., s -&gt; s.));</span><br></pre></td></tr></table></figure><p>或者在复习一下<a href="https://www.bilibili.com/video/BV1yW4y1Y7Ms?spm_id_from=333.788.videopod.episodes&vd_source=b0dff9885c076f5f4c78c1f99505a0cf&p=39">收集方法collect超详解</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快捷键</title>
      <link href="/2025/07/07/%E5%BB%BA%E6%A8%A1/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2025/07/07/%E5%BB%BA%E6%A8%A1/%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><p><code>中键</code>  旋转</p><p><code>shift+中键</code>  平移</p><p><code>shift+a</code>  新建图形</p><p><code>x / delete</code> 删除</p><p><code>g</code>  对着模型按，会跟着鼠标移动</p><p>再按 x, y, z, 会在对应坐标轴上移动</p><p><code>r</code>  旋转</p><p><code>s</code>  缩放</p><p><code>shift+z</code>  透视</p><p><code>h</code>  隐藏</p><p><code>shift+d</code>  复制</p><p><code>/</code> 选中拉进</p><p>小键盘中</p><p><code>1</code> 正视图 <code>3</code> 左视图<code>7</code> 俯视图 <code>9</code> 反向 <code>0</code> 摄像机视角</p><p><code>gz</code> 切换局部坐标(物体自己的xyz，是可变的)，再按xyz，切换全局坐标(整个界面的xyz，是规定的)</p>]]></content>
      
      
      <categories>
          
          <category> 建模 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL</title>
      <link href="/2025/07/06/Python/SQL/"/>
      <url>/2025/07/06/Python/SQL/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL语法特征"><a href="#SQL语法特征" class="headerlink" title="SQL语法特征"></a>SQL语法特征</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250705163608687.png" alt="image-20250705163608687"></p><h1 id="库管理"><a href="#库管理" class="headerlink" title="库管理"></a>库管理</h1><ul><li>查看数据库</li></ul><p>show databases;</p><ul><li>使用数据库</li></ul><p>use 数据库名称;</p><ul><li>创建数据库</li></ul><p>create database 数据库名称 [charset utf8]; &#x2F;&#x2F; []可写可不写</p><ul><li>删除数据库</li></ul><p>drop database 数据库名称;</p><ul><li>查看当前使用的数据库</li></ul><p>select database();</p><h1 id="DDL-表管理"><a href="#DDL-表管理" class="headerlink" title="DDL-表管理"></a>DDL-表管理</h1><ul><li>查看有哪些表</li></ul><p>show tables;    <code>需要先选择数据库</code></p><ul><li>创建表</li></ul><p>create table 表名称(</p><p>​列名称  列类型,</p><p>​……</p><p>);</p><p><code>类型</code></p><p>int           – 整数</p><p>float         – 浮点型</p><p>varchar(长度)  – 文本，长度为数字，做最大长度限制</p><p>date          – 日期类型</p><p>timestamp     – 时间戳类型</p><ul><li>删除表</li></ul><p>drop table 表名称;</p><p>drop table if exists 表名称;</p><h1 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h1><p>用来对数据库中表的数据记录进行更新</p><h2 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h2><p>语法:</p><p>insert into 表[(列1，列2，……，列n)] values(值1，值2，……，值n),[(值1，值2，……，值n),(值1，值2，……，值n),……]</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">use world;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> tables;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create table</span> animal(</span><br><span class="line"></span><br><span class="line">​age <span class="type">int</span>,</span><br><span class="line"></span><br><span class="line">​nam <span class="type">varchar</span>(<span class="number">10</span>) </span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert into</span> animal(age) <span class="keyword">values</span>(<span class="number">1</span>),(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>其中13行的animal(age)中的元素age等可以省略</p><h2 id="数据删除"><a href="#数据删除" class="headerlink" title="数据删除"></a>数据删除</h2><p>语法：</p><p>delete from 表名称 [where 条件判断]；</p><p>条件格式：列  操作符  值</p><p>操作符：&#x3D; &lt; &gt; &lt;&#x3D; &gt;&#x3D; !&#x3D;  等等</p><h2 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h2><p>updata 表名 set 列&#x3D;值 [where 条件判断];</p><h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><p> select 字段列表|* from 表;        &#x2F;&#x2F;*代表全部</p><p>如：select id,name from Student;</p><ul><li>过滤</li></ul><p> select 字段列表|* from 表 where 条件判断;  </p><h2 id="分组聚合"><a href="#分组聚合" class="headerlink" title="分组聚合"></a>分组聚合</h2><p>select 字段|聚合函数 from 表 [where 条件] group by 列</p><p><code>聚合函数</code>：</p><p>sun(列)    求和</p><p>avg(列)    求平均值</p><p>min(列)    求最小值</p><p>max()      求最大值</p><p>count()    求数量</p><h2 id="结果排序"><a href="#结果排序" class="headerlink" title="结果排序"></a>结果排序</h2><p>select 列|聚合函数|* from 表</p><p>where ……</p><p>group by ……</p><p>order by … [asc(从小到大) | desc(从大到小)]</p><ul><li>结果分页</li></ul><p>用limit关键字，对查询结果进行数量限制或分页显示</p><p>select 列|聚合函数|* from 表</p><p>where ……</p><p>group by ……</p><p>order by … [asc(从小到大) | desc(从大到小)]</p><p>limit n,[ m ]   &#x2F;&#x2F;如果只有n，意思是输出前n条，</p><p>​&#x2F;&#x2F;如果有n，m，意思是跳过前n条，再往后输出m条</p><h1 id="Python操作MySQL操作"><a href="#Python操作MySQL操作" class="headerlink" title="Python操作MySQL操作"></a>Python操作MySQL操作</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pymysql <span class="keyword">import</span> Connection</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建到MySQL数据库的链接</span></span><br><span class="line">conn = Connection(</span><br><span class="line">    host=<span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    port=<span class="number">3306</span>,</span><br><span class="line">    user=<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    password=<span class="string">&#x27;shenentao520&#x27;</span>,</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(conn.get_server_info())</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="执行非查询性质的sql语句"><a href="#执行非查询性质的sql语句" class="headerlink" title="执行非查询性质的sql语句"></a>执行非查询性质的sql语句</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取游标对象</span></span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"><span class="comment"># 先选择数据库</span></span><br><span class="line">conn.select_db(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"><span class="comment"># 使用游标对象，执行sql语句</span></span><br><span class="line">cursor.execute(<span class="string">&#x27;create table test (id int, name varchar(20))&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="执行查询性质的sql语句"><a href="#执行查询性质的sql语句" class="headerlink" title="执行查询性质的sql语句"></a>执行查询性质的sql语句</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用游标对象，执行sql语句</span></span><br><span class="line">cursor.execute(<span class="string">&#x27;select * from country&#x27;</span>)</span><br><span class="line">result: <span class="built_in">tuple</span> = cursor.fetchall()</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭连接</span></span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure><h2 id="执行插入性质的sql语句"><a href="#执行插入性质的sql语句" class="headerlink" title="执行插入性质的sql语句"></a>执行插入性质的sql语句</h2><p>执行插入语句的时候，并不会直接完成，而是要我们进行一个确认</p><p>通过连接对象.commit()进行确认即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cursor.execute(<span class="string">&quot;insert into animal(nam) values(&#x27;猫&#x27;)&quot;</span>)</span><br><span class="line"></span><br><span class="line">conn.commit()</span><br></pre></td></tr></table></figure><ul><li>自动commit</li></ul><p>autocommit&#x3D;True</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">conn = Connection(</span><br><span class="line">    host=<span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    port=<span class="number">3306</span>,</span><br><span class="line">    user=<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    password=<span class="string">&#x27;shenentao520&#x27;</span>,</span><br><span class="line">    autocommit=<span class="literal">True</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/2025/07/05/Python/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2025/07/05/Python/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><ul><li>设计一个类</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class student:</span><br><span class="line">    name = None</span><br><span class="line">    age = None</span><br></pre></td></tr></table></figure><ul><li>创建一个对象</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stu1 = student()</span><br></pre></td></tr></table></figure><ul><li>对对象进行赋值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stu1.name = &quot;日奈&quot;</span><br><span class="line">stu1.age = 17</span><br></pre></td></tr></table></figure><ul><li>类里面也可以添加函数</li></ul><p>class xxx:</p><p>​def xxxx(self):    &#x2F;&#x2F;self必须存在用来表示类对象自身的意思</p><p>​xxx       &#x2F;&#x2F;不过在传入参数时不用理它</p><p>如果有成员变量要传入到成员方法，要加self.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>:</span><br><span class="line">    name = None</span><br><span class="line">    def <span class="title function_">s</span><span class="params">(self)</span>:</span><br><span class="line">    print(f<span class="string">&quot;我是&#123;slef.name&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>成员方法也可以继续添加元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>:</span><br><span class="line">    name = None</span><br><span class="line">    def <span class="title function_">s</span><span class="params">(self,str)</span>:</span><br><span class="line">    print(f<span class="string">&quot;我是&#123;slef.name&#125;,&#123;str&#125;&quot;</span>) <span class="comment">//其中str因为是全局变量，所以不用加self.</span></span><br><span class="line">stu1 = stu()</span><br><span class="line">stu1.str(<span class="string">&quot;你好你好&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>因为一个个定义变量太麻烦，所以可以在函数中添加构造方法解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>:</span><br><span class="line">    name = <span class="type">None</span></span><br><span class="line">    <span class="variable">age</span> <span class="operator">=</span> None</span><br><span class="line">    def <span class="title function_">__init__</span><span class="params">(self,name,age)</span>:</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = <span class="type">age</span></span><br><span class="line"><span class="variable">student1</span> <span class="operator">=</span> student(<span class="string">&quot;日奈&quot;</span>,<span class="number">17</span>)</span><br></pre></td></tr></table></figure><p>因为构造方法里已经有属性了，所以name之类的可以不写了，直接写构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>:</span><br><span class="line">    def <span class="title function_">__init__</span><span class="params">(self,name,age)</span>:</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = <span class="type">age</span></span><br><span class="line"><span class="variable">student1</span> <span class="operator">=</span> student(<span class="string">&quot;日奈&quot;</span>,<span class="number">17</span>)</span><br></pre></td></tr></table></figure><h1 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h1><p>魔术方法也就是python的内置方法，__ init __就是其中一种</p><h2 id="str"><a href="#str" class="headerlink" title="__ str __"></a>__ str __</h2><p>当类对象需要转为字符串时，用print(str(xxx))的话，结果会输出内存地址，但我们并不需要这个，所以要用魔术方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>:</span><br><span class="line">    name = <span class="type">None</span></span><br><span class="line">    <span class="variable">age</span> <span class="operator">=</span> None</span><br><span class="line"> def <span class="title function_">__str__</span><span class="params">(self)</span>:</span><br><span class="line">        <span class="keyword">return</span> f<span class="string">&#x27;&#123;self.name&#125; is &#123;self.age&#125; years old&#x27;</span></span><br><span class="line">student1 = student(<span class="string">&quot;日奈&quot;</span>,<span class="number">17</span>)</span><br><span class="line">print(student1)</span><br></pre></td></tr></table></figure><p>print之后会按照__ str __的格式输出</p><h2 id="lt"><a href="#lt" class="headerlink" title="__ lt __"></a>__ lt __</h2><p>可同时完成<code>&lt;</code>,<code>&gt;</code>的比较</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>:</span><br><span class="line">    def <span class="title function_">__init__</span>(self,name,age):</span><br><span class="line">        self.<span class="property">name</span> = name</span><br><span class="line">        self.<span class="property">age</span> = age</span><br><span class="line">    def <span class="title function_">__lt__</span>(self,other):</span><br><span class="line">        <span class="keyword">return</span> self.<span class="property">age</span> &lt; other.<span class="property">age</span></span><br><span class="line"></span><br><span class="line">student1 = <span class="title function_">student</span>(<span class="string">&quot;日奈&quot;</span>,<span class="number">17</span>)</span><br><span class="line">student2 = <span class="title function_">student</span>(<span class="string">&quot;佳代子&quot;</span>,<span class="number">18</span>)</span><br><span class="line"><span class="title function_">print</span>(student1 &lt; student2)</span><br></pre></td></tr></table></figure><h2 id="le"><a href="#le" class="headerlink" title="__ le __"></a>__ le __</h2><p>可同时完成<code>&lt;=</code>,<code>&gt;=</code>的比较</p><p>逻辑跟lt一样</p><h2 id="eq"><a href="#eq" class="headerlink" title="__ eq __"></a>__ eq __</h2><p>可用于<code>==</code>的判断</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><h2 id="私有成员"><a href="#私有成员" class="headerlink" title="私有成员"></a>私有成员</h2><p>私有成员变量和方法只要在前面加上<code>__</code>即可</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">phone</span>:</span><br><span class="line">    __is_5g_enable = False</span><br><span class="line">    def <span class="title function_">__check_5g</span><span class="params">(self)</span>:</span><br><span class="line">        <span class="keyword">if</span> self.__is_5g_enable:</span><br><span class="line">            print(f<span class="string">&quot;5g开启&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(f<span class="string">&quot;5g关闭，用4g网络&quot;</span>)</span><br><span class="line">    def <span class="title function_">call_by_5g</span><span class="params">(self)</span>:</span><br><span class="line">        self.__check_5g()</span><br><span class="line">        print(<span class="string">&quot;正在通话中&quot;</span>)<span class="type">a</span></span><br><span class="line"></span><br><span class="line"><span class="variable">p</span> <span class="operator">=</span> phone()</span><br><span class="line">p.call_by_5g()</span><br></pre></td></tr></table></figure><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h2><p>格式：</p><p>class 类名(父类名):</p><p>​类内容体</p><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>格式：</p><p>class 类名(父类名1,父类名2,…):</p><p>​类内容体</p><p>如果继承后也不想在添加什么，那么可以写上pass来替代，保证语法不报错</p><h2 id="复写"><a href="#复写" class="headerlink" title="复写"></a>复写</h2><p>跟java的重写一样，继承之后def重写即可</p><p>变量和方法都能复写</p><h2 id="调用父类同名成员"><a href="#调用父类同名成员" class="headerlink" title="调用父类同名成员"></a>调用父类同名成员</h2><p>如果想调用被复写的父类的原有形式，有两种方法</p><ol><li><p>父类名.成员变量</p><p>父类名.成员方法(self)</p></li><li><p>super().成员变量</p></li></ol><p>​     super().成员方法()</p><h1 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h1><p>可以在写代码时理解某个变量的类型</p><p>格式：</p><p>变量名： 类型</p><p>如：  name: str &#x3D; “xxx”</p><p>​     stu: Student &#x3D; Student()</p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;wang&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;miao&quot;</span>)</span><br><span class="line"></span><br><span class="line">cat = Cat()</span><br><span class="line">cat.speak()</span><br><span class="line">dog = Dog()</span><br><span class="line">dog.speak()</span><br></pre></td></tr></table></figure><p>其中speak方法也叫做<code>抽象类</code>或<code>接口</code>，带有pass，子类必须重写接口才能使用</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pyecharts入门</title>
      <link href="/2025/07/03/Python/pyecharts/"/>
      <url>/2025/07/03/Python/pyecharts/</url>
      
        <content type="html"><![CDATA[<h1 id="pyecharts基础入门"><a href="#pyecharts基础入门" class="headerlink" title="pyecharts基础入门"></a>pyecharts基础入门</h1><h2 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h2><p>from pyecharts.charts import Line<br>from pyecharts.options import TitleOpts</p><h2 id="创建一个折线图对象"><a href="#创建一个折线图对象" class="headerlink" title="创建一个折线图对象"></a>创建一个折线图对象</h2><p>line &#x3D; Line()<br>#给折线图添加x轴数据<br>line.add_xaxis([“中国”,”美国”,”英国”])<br>#给折线图添加y轴数据<br>line.add_yaxis(“GDP”,[30,20,10])<br>#通过render方法，将代码变为图像<br>line.render()<br>#通过全局配置项set_global_opts来设置，TitleOpts导包<br>line.set_global_opts(<br>    title_opts&#x3D;TitleOpts(title&#x3D;”GDP展示”)<br>)</p><p>#通过render方法，将代码变为图像<br>line.render()</p><p>具体的设置可以到网站去寻找<a href="https://pyecharts.org/#/">pyecharts</a></p><h2 id="创建一个地图"><a href="#创建一个地图" class="headerlink" title="创建一个地图"></a>创建一个地图</h2><p>from pyecharts.charts import Map</p><h2 id="准备地图对象"><a href="#准备地图对象" class="headerlink" title="准备地图对象"></a>准备地图对象</h2><p>map &#x3D; Map()</p><h2 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h2><p>data &#x3D; [</p><p>​    (“湖南”,1),<br>​    (“吉林省”,3),<br>​    (“湖北省”,4),<br>​    (“广西壮族自治区”,5),<br>​    (“广东省”,6)<br>]</p><h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><p>map.add(“测试地图”,data,”china”)</p><h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><p>map.render()</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>异常 &amp; 模块</title>
      <link href="/2025/07/03/Python/%E5%BC%82%E5%B8%B8%20&amp;%20%E6%A8%A1%E5%9D%97/"/>
      <url>/2025/07/03/Python/%E5%BC%82%E5%B8%B8%20&amp;%20%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="基本捕获语法"><a href="#基本捕获语法" class="headerlink" title="基本捕获语法"></a>基本捕获语法</h2><p>try：</p><p>​    可能发生错误的代码</p><p>expect：</p><p>​    如果出现异常执行的代码</p><h2 id="捕获指定异常"><a href="#捕获指定异常" class="headerlink" title="捕获指定异常"></a>捕获指定异常</h2><p>try：</p><p>​    可能发生错误的代码</p><p>expect 异常名 as 变量名(任意，如a，c)：</p><p>​    如果出现异常执行的代码</p><h2 id="获取多个异常"><a href="#获取多个异常" class="headerlink" title="获取多个异常"></a>获取多个异常</h2><p>try：</p><p>​    可能发生错误的代码</p><p>expect (异常名1,异常名2) as 变量名(任意，如a，c)：</p><p>​    如果出现异常执行的代码</p><h2 id="获取全部异常"><a href="#获取全部异常" class="headerlink" title="获取全部异常"></a>获取全部异常</h2><p>try：</p><p>​    可能发生错误的代码</p><p>expect Exception as 变量名(任意，如a，c)：</p><p>​    如果出现异常执行的代码</p><h2 id="else-finally"><a href="#else-finally" class="headerlink" title="else &amp; finally"></a>else &amp; finally</h2><p><code>else</code>：如果没有异常时要执行的代码</p><p><code>finally</code>：有没有异常都会执行的代码</p><p>try：</p><p>​    可能发生错误的代码</p><p>expect Exception as 变量名(任意，如a，c)：</p><p>​    如果出现异常执行的代码</p><p>else:</p><p>​    ……</p><p>finally:</p><p>​    ……</p><h1 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h1><p><code>模块</code>就是一个python文件以.py结尾，里面有类，函数，变量等，可以直接拿过来用</p><p><code>格式</code>: </p><p>[from 模块名] import [模块 &#x2F; 类 &#x2F; 变量 &#x2F; 函数 &#x2F; *] [as 别名]  (“[]”为可写可不写)</p><h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p>如import time 可以引用time模块，其中有sleep可以让代码延时运行</p><p>如time.sleep(5)让代码睡5秒后在运行</p><h2 id="from-模块名-import-功能名"><a href="#from-模块名-import-功能名" class="headerlink" title="from 模块名 import 功能名"></a>from 模块名 import 功能名</h2><p>因为模块中不是所有的方法都会用到，所以用from来提取想要的功能</p><p>功能名()，这样即可使用</p><p>from 模块名 import *</p><p>意思是把模块中的所有功能都导进来</p><h2 id="import-功能名-as-别名"><a href="#import-功能名-as-别名" class="headerlink" title="import 功能名 as 别名"></a>import 功能名 as 别名</h2><p>给模块起别名的效果</p><p>如 import time as qq</p><p>qq.time(5)</p><h1 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h1><ol><li>新建一个.py文件，命个名，并定义方法</li><li>在另一个文件中import该文件即可使用</li></ol><p>不过当引用自定义模块的时候，会直接运行自定义模块，对于测试类是不需要的，但是又想测试自定义模块，那么可以在自定义模块中输入<code>main</code>加回车 生成“if __ name __ &#x3D;&#x3D; ‘__ main __ ’”:</p><p>再把需要测试的代码放在后面，这样既不影响自定义模块的测试，也不会干扰测试类</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250703100410459.png" alt="image-20250703100410459"></p><p><code>原理</code></p><p>__ name __其实是一个内置变量，当运行自定义模块时，name会变成main，满足if条件后运行后续代码</p><p>而在import自定义模块时，name不变，便运行不了</p><h2 id="all"><a href="#all" class="headerlink" title="__ all __"></a>__ all __</h2><p>如果模块中有__ all __变量，当使用from xxx import **</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>文件</title>
      <link href="/2025/07/03/Python/%E6%96%87%E4%BB%B6/"/>
      <url>/2025/07/03/Python/%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="open-函数"><a href="#open-函数" class="headerlink" title="open()函数"></a>open()函数</h1><p>open(name,mode,encoding)</p><p><code>name</code>：打开的目标文件名的字符串，也可以是具体路径</p><p><code>mode</code>：设置打开文件的模式</p><p><code>encoding</code>：编码格式(建议用UTF-8)</p><p>如：</p><p>f &#x3D; open(“D:&#x2F;测试.txt”,“r”,encoding&#x3D;“UTF-8”)</p><p><code>r</code>:以只读方式打开文件，文件的指针会放在文件的开头</p><p><code>w</code>:打开一个文件只用于写入</p><ul><li>如果该文件已存在则打开文件，并从开头开始编辑，原有内容会被删除</li><li>如果该文件不存在，创建新文件</li></ul><p><code>a</code>:打开一个文件用于追加</p><ul><li>如果该文件已存在，新的内容会写入已有文件之后</li><li>如果文件不存在，创建新文件写入</li></ul><h1 id="read-方法"><a href="#read-方法" class="headerlink" title="read()方法"></a>read()方法</h1><p>文件对象.read(num)</p><p>num表示要从文件中读取的数据的长度(单位是字节)，如果没传入num，那么表示读取文件中所有的数据</p><p>如果之前已经调用一次，下次调用的起点为上次调用的终点</p><h1 id="readlines-方法"><a href="#readlines-方法" class="headerlink" title="readlines()方法"></a>readlines()方法</h1><p>readlines可以按照行的方式把文件中的内容进行一次性的读取，并且返回的是一个列表，每一行的数据为一个元素</p><h1 id="readline-方法"><a href="#readline-方法" class="headerlink" title="readline()方法"></a>readline()方法</h1><p>一次只读取一行内容</p><h1 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h1><p>for line in open(“.txt”,”r):</p><p>​print(line)</p><h1 id="文件关闭"><a href="#文件关闭" class="headerlink" title="文件关闭"></a>文件关闭</h1><p>sleep()</p><p>让文件暂停执行，单位为秒</p><p>close()</p><p>关闭文件</p><h1 id="with-open"><a href="#with-open" class="headerlink" title="with open"></a>with open</h1><p>格式</p><p>with open() as 文件名</p><p>​行为</p><p>结尾会自动执行close来防止遗忘</p><h1 id="写出操作"><a href="#写出操作" class="headerlink" title="写出操作"></a>写出操作</h1><p>f &#x3D; open(“D:&#x2F;测试.txt”,“<code>w</code>”,encoding&#x3D;“UTF-8”)</p><h2 id="write"><a href="#write" class="headerlink" title="write()"></a>write()</h2><p>f.write()</p><p>这个并不算真正的写入，而是把要写入的内容放到一块内存中，下面的flush()才算真正写入</p><h2 id="flush"><a href="#flush" class="headerlink" title="flush()"></a>flush()</h2><p>f.flush()</p><h1 id="追加写入操作"><a href="#追加写入操作" class="headerlink" title="追加写入操作"></a>追加写入操作</h1><p>f &#x3D; open(“D:&#x2F;测试.txt”,“<code>a</code>”,encoding&#x3D;“UTF-8”)</p><p>操作同写出操作</p><p>s</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据容器</title>
      <link href="/2025/07/01/Python/%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8/"/>
      <url>/2025/07/01/Python/%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="list列表"><a href="#list列表" class="headerlink" title="list列表"></a>list列表</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>变量名 &#x3D; [ 元素 ]</p><p>也可以嵌套</p><p>[ [ 123 ] , [ 456 ] ]</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>跟java一样，从0开始</p><p>也可以反向索引：-5 -4 -3 -2 -1</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>列表.index(查找元素)，会返回其下标</p><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>列表[下标] &#x3D; 值</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>列表.insert(下标，元素)，在指定的下标插入指定的元素</p><h2 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h2><ol><li><p>列表.append(元素)，将指定元素追加到列表的尾部</p></li><li><p>列表.extend(其他数据容器)，将其他数据容器中的元素取出，依次追加到列表尾部</p></li></ol><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><ol><li>del 列表[下标]</li><li>列表.pop(下标)，可以返回被删除的元素</li><li>列表.remove(元素),删除某元素在列表中的第一个匹配项</li></ol><h2 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h2><p>列表.clear()</p><h2 id="统计某元素在列表中的数量"><a href="#统计某元素在列表中的数量" class="headerlink" title="统计某元素在列表中的数量"></a>统计某元素在列表中的数量</h2><p>列表.count(元素)</p><h2 id="统计列表中有多少个元素"><a href="#统计列表中有多少个元素" class="headerlink" title="统计列表中有多少个元素"></a>统计列表中有多少个元素</h2><p>len(列表)</p><h1 id="tuple元组"><a href="#tuple元组" class="headerlink" title="tuple元组"></a>tuple元组</h1><p>元组用<code>()</code>，用<code>,</code>隔开，可以收集不同类型的数据</p><p>也可以嵌套</p><p>方法 index(),len(),count()同list</p><p><code>注</code>：元组的元素无法修改，但嵌套一个list则可以修改</p><h1 id="str字符串"><a href="#str字符串" class="headerlink" title="str字符串"></a>str字符串</h1><h2 id="索引-同list"><a href="#索引-同list" class="headerlink" title="索引(同list)"></a>索引(同list)</h2><p>跟java一样，从0开始</p><p>也可以反向索引：-5 -4 -3 -2 -1</p><p><code>注</code>：字符串的元素无法修改</p><h2 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h2><p>字符串.index(查找的字符串)，会返回其起始下标</p><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>字符串.replace(字符串1，字符串2)</p><p>把<code>所有的</code>字符串1替换为字符串2(无论有多少个)</p><p><code>注</code>：不是修改字符串，而是创建了一个新的字符串</p><h2 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h2><p>字符串.split(分隔符字符串)</p><p>按照指定的分隔符字符串，将字符串分为多个字符串，并返回一个list</p><h2 id="规整"><a href="#规整" class="headerlink" title="规整"></a>规整</h2><ul><li>字符串.strip() 去前后空格</li><li>字符串.strip(字符串) 去前后指定字符串( 此字符串不按顺序，例如传入‘12’，会判定为1和2)</li></ul><h2 id="字符串出现的次数"><a href="#字符串出现的次数" class="headerlink" title="字符串出现的次数"></a>字符串出现的次数</h2><p>字符串.count()</p><h2 id="字符串的长度"><a href="#字符串的长度" class="headerlink" title="字符串的长度"></a>字符串的长度</h2><p>len(字符串)</p><h1 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h1><p>是指内容有序，连续，可使用下标索引的一类数据容器</p><p>如list，tuple，str都是</p><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>序列[起始下标：结束下标：步长]</p><p>从一个序列中，取出一个子序列</p><p><code>注</code>：序列本身不会受影响，而是生成新的序列</p><h1 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>用<code>&#123;&#125;</code>表示</p><p>不允许重复</p><h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><p>set.add()</p><h2 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h2><p>ser.remove()</p><h2 id="随机取出一个元素"><a href="#随机取出一个元素" class="headerlink" title="随机取出一个元素"></a>随机取出一个元素</h2><p>set.pop()</p><h2 id="清空集合"><a href="#清空集合" class="headerlink" title="清空集合"></a>清空集合</h2><p>set.clear()</p><h2 id="取两个集合的差集"><a href="#取两个集合的差集" class="headerlink" title="取两个集合的差集"></a>取两个集合的差集</h2><p>set1.difference(set2)</p><p>也就是set1有而set2没有的</p><h2 id="消除两个集合的差集"><a href="#消除两个集合的差集" class="headerlink" title="消除两个集合的差集"></a>消除两个集合的差集</h2><p>set1.difference_update(set2)</p><p>在set1内删除与set2相同的元素</p><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>set1.union(set2)</p><p><code>注</code>：有重复的元素会去重</p><h2 id="统计数量"><a href="#统计数量" class="headerlink" title="统计数量"></a>统计数量</h2><p>len(set)</p><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>就跟java中的双列集合差不多，由key和value组成，元素是一个个键值对</p><p><code>定义</code></p><ol><li>my_dict &#x3D; {}</li><li>my_dict &#x3D; dict()</li></ol><h2 id="基于key获得value"><a href="#基于key获得value" class="headerlink" title="基于key获得value"></a>基于key获得value</h2><p>mydict[“key”]</p><p>当然也可以嵌套，格式为：mydict【】【】…</p><h2 id="添加-更新"><a href="#添加-更新" class="headerlink" title="添加&#x2F;更新"></a>添加&#x2F;更新</h2><p>字典[key] &#x3D; value</p><h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><p>字典pop(key)</p><h2 id="清空-1"><a href="#清空-1" class="headerlink" title="清空"></a>清空</h2><p>mydict.clear()</p><h2 id="获取所有的key"><a href="#获取所有的key" class="headerlink" title="获取所有的key"></a>获取所有的key</h2><p>字典.keys()</p><h2 id="获取元素数量"><a href="#获取元素数量" class="headerlink" title="获取元素数量"></a>获取元素数量</h2><p>len(mydict)</p><h1 id="通用功能"><a href="#通用功能" class="headerlink" title="通用功能"></a>通用功能</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/picture%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8.png" alt="image-20250701172245025"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>函数</title>
      <link href="/2025/06/30/Python/%E5%87%BD%E6%95%B0/"/>
      <url>/2025/06/30/Python/%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>格式</p><p>def 函数名(传入参数):</p><p>​函数体</p><p>​return 返回值</p><p>若想把真假互换，可以用<code>not</code></p><h1 id="说明文档"><a href="#说明文档" class="headerlink" title="说明文档"></a>说明文档</h1><p>用“”“</p><p>  ”“”</p><p>可以显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def p(x,y):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    :param x:1111</span><br><span class="line">    :param y:1111</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    print(f&quot;&#123;x&#125;,&#123;y&#125;&quot;)</span><br></pre></td></tr></table></figure><h1 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h1><h2 id="多种返回值"><a href="#多种返回值" class="headerlink" title="多种返回值"></a>多种返回值</h2><p>def test():</p><p>​return 1,2,3</p><p>i,j,k &#x3D; test()</p><h2 id="关键字传参"><a href="#关键字传参" class="headerlink" title="关键字传参"></a>关键字传参</h2><p>def test(name,age,gender):</p><p>​……</p><p>test(name&#x3D;“…”,age&#x3D;…,gender&#x3D;“…”)</p><p>也可以打乱顺序</p><p>test(age&#x3D;…,name&#x3D;“…”,gender&#x3D;“…”)</p><h2 id="位置传递"><a href="#位置传递" class="headerlink" title="位置传递"></a>位置传递</h2><p>def test(*args):</p><p>​print(args)</p><p>传递的参数会被args收集，并合并为tuple </p><h2 id="关键字传递"><a href="#关键字传递" class="headerlink" title="关键字传递"></a>关键字传递</h2><p>def test(**kwargs):</p><p>​print(kwargs)</p><p>参数是<code>键=值</code>的情况下，会被kwargs接受，并合并为dict</p><h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><p>lambda 传入参数： 函数体(一行代码)</p><p>可以让只使用一次的函数写法更简便</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>循环</title>
      <link href="/2025/06/29/Python/%E5%BE%AA%E7%8E%AF/"/>
      <url>/2025/06/29/Python/%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h1><p>格式：</p><p>while 条件：</p><p>​条件满足时做的事情</p><h1 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h1><p>for 临时变量 in 待处理数据集：</p><p>​条件满足时做的事情</p><p>意思是：获取待处理数据集中的每个字符赋值给临时变量，由临时变量输出</p><h1 id="range语法"><a href="#range语法" class="headerlink" title="range语法"></a>range语法</h1><h2 id="range-num"><a href="#range-num" class="headerlink" title="range(num)"></a>range(num)</h2><p>获取从零开始，到num结束的数字序列(不包含num本身)</p><p>如：range(3) 输出 –[0，1,2]</p><h2 id="range-num1-num2"><a href="#range-num1-num2" class="headerlink" title="range(num1,num2)"></a>range(num1,num2)</h2><p>获取从num1开始，到num2结束的数字序列(不包含num2本身)</p><h2 id="range-num1-num2-step"><a href="#range-num1-num2-step" class="headerlink" title="range(num1,num2,step)"></a>range(num1,num2,step)</h2><p>获取从num1开始，到num2结束的数字序列(不包含num2本身)</p><p>数据的步长由step决定</p><p>如：range(5,10,2) 输出 –[5,7,9]</p><p>​</p><h1 id="comtinue-break"><a href="#comtinue-break" class="headerlink" title="comtinue &amp; break"></a>comtinue &amp; break</h1><p><code>continue</code>：中断本次循环，直接进入下一个循环</p><p><code>break</code>: 直接结束循环</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法讲解</title>
      <link href="/2025/06/23/Markdown/%E8%AF%AD%E6%B3%95%E8%AE%B2%E8%A7%A3/"/>
      <url>/2025/06/23/Markdown/%E8%AF%AD%E6%B3%95%E8%AE%B2%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><p><img src="https://github.com/XiDongWe/Picture/blob/5d842e80de17913ec81efa81b4df2fe509f7fdf3/picture%E9%A3%8E%E6%99%AF-%E4%BA%912.jpg"></p><h1 id="2-强调"><a href="#2-强调" class="headerlink" title="2.强调"></a>2.强调</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*斜体*  或   _斜体_</span><br><span class="line">**加粗**  或   __加粗__</span><br><span class="line">***斜体加加粗***  或   ___斜体加加粗___</span><br></pre></td></tr></table></figure><p>效果</p><p><em>斜体</em><br><strong>加粗</strong><br><em><strong>斜体加加粗</strong></em>  </p><h1 id="3-列表"><a href="#3-列表" class="headerlink" title="3.列表"></a>3.列表</h1><p><strong>无序列表</strong>：用 - * +作为标识符</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-标题一</span><br><span class="line"> -1</span><br><span class="line"> -2</span><br><span class="line">-标题二</span><br></pre></td></tr></table></figure><ul><li><p>标题一</p><ul><li>1<ul><li>2</li></ul></li></ul></li><li><p>标题二</p></li></ul><p><strong>有序列表</strong>:数字加.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. qqq</span><br><span class="line"> 1. eee</span><br><span class="line"> 2. fdg</span><br><span class="line">2. afd</span><br></pre></td></tr></table></figure><ol><li><p>qqq</p><ol><li>ee</li><li>fdg</li></ol></li><li><p>afd</p></li></ol><h1 id="4-链接"><a href="#4-链接" class="headerlink" title="4.链接"></a>4.链接</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[链接文本](链接地址)</span><br><span class="line">[bilbil](https://www.bilibili.com/)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果加提示词的话</span><br><span class="line">[链接文本](链接地址 &quot;提示词&quot;)</span><br><span class="line">[bilbil](https://www.bilibili.com/ &quot;哔哩哔哩&quot;) </span><br></pre></td></tr></table></figure><p>效果</p><p><a href="https://www.bilibili.com/">bilbil</a></p><p><a href="https://www.bilibili.com/" title="哔哩哔哩">bilbil</a> </p><h1 id="5-图片"><a href="#5-图片" class="headerlink" title="5.图片"></a>5.图片</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![图片描述](图片地址)</span><br><span class="line">或者直接粘贴也行  </span><br></pre></td></tr></table></figure><p><img src="/%E5%9B%BE%E7%89%87/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E6%97%A5%E5%A5%88.webp"></p><h1 id="6-引用"><a href="#6-引用" class="headerlink" title="6.引用"></a>6.引用</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是引用</span><br><span class="line">&gt;&gt;这是嵌套引用</span><br></pre></td></tr></table></figure><blockquote><p>这是引用</p><blockquote><p>这是嵌套引用</p></blockquote></blockquote><h1 id="7-代码块"><a href="#7-代码块" class="headerlink" title="7.代码块"></a>7.代码块</h1><p><strong>行内代码</strong>用(&#96;&#96;)表示</p><p>演示：<code>111</code></p><p><strong>代码块</strong>用(&#96;&#96;&#96;)表示</p><h1 id="8-表格-idea用不了"><a href="#8-表格-idea用不了" class="headerlink" title="8.表格(idea用不了)"></a>8.表格(idea用不了)</h1><p>用 <code>|</code> 和 <code>-</code> 表示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">| 1.1 | 1.2 | 1.3 |</span><br><span class="line">|————|————|————|</span><br><span class="line">| 1.1 | 1.2 | 1.3 |</span><br><span class="line">| 1.1 | 1.2 | 1.3 |</span><br><span class="line">或者直接右键创建</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="9-分割线-idea用不了"><a href="#9-分割线-idea用不了" class="headerlink" title="9.分割线(idea用不了)"></a>9.分割线(idea用不了)</h1><p>使用三个或更多的 <code>-</code> <code>*</code> <code>__</code></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>集合进阶</title>
      <link href="/2025/06/17/JAVASE/%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6/"/>
      <url>/2025/06/17/JAVASE/%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><ol><li>创建对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt; String &gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><ol start="2"><li>添加</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.add(<span class="string">&quot;   &quot;</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>删除</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.remove(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">此处可以填具体存在的值或者是索引</span><br></pre></td></tr></table></figure><ol start="4"><li>修改</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.set( 索引, 要修改的值)</span><br></pre></td></tr></table></figure><ol start="5"><li>查询</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.get(索引)</span><br></pre></td></tr></table></figure><p>其中，如果想让另一个ArrayList复制一份，可以用ArrayList<E> newlist &#x3D; new ArrayList&lt;&gt;(list)实现</p><p><img src="/%E5%9B%BE%E7%89%87/JAVA/%E5%8D%95%E5%88%97%E9%9B%86%E5%90%881.png"></p><p>List系列集合:添加的元素是有序，可重复，有索引<br>有序：输入的和输出的是一样(即输入1,2,3，就输出1,2,3)<br>可重复：元素可重复<br>有索引：可以通过索引获取每个元素</p><p>Set系列集合：无序，不重复，没索引<br>无序：存和取的顺序有可能不同</p><h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p>因为Collection是一个接口，所以不能直接创建它的对象，因此只能创建实现类的对象ArrayList<br>Collection&lt; String &gt; coll &#x3D; new ArrayList&lt;&gt;();</p><h2 id="1-添加元素"><a href="#1-添加元素" class="headerlink" title="1.添加元素"></a>1.添加元素</h2><p>coll.add(“aaa”);</p><h2 id="2-清空元素"><a href="#2-清空元素" class="headerlink" title="2.清空元素"></a>2.清空元素</h2><p>coll.clear();</p><h2 id="3-删除元素"><a href="#3-删除元素" class="headerlink" title="3.删除元素"></a>3.删除元素</h2><p>coll.remove(“aaa”);</p><h2 id="4-判断元素是否包含"><a href="#4-判断元素是否包含" class="headerlink" title="4.判断元素是否包含"></a>4.判断元素是否包含</h2><p>boolean result &#x3D; coll.contains(“bbb”);</p><h2 id="5-判断是否为空"><a href="#5-判断是否为空" class="headerlink" title="5.判断是否为空"></a>5.判断是否为空</h2><p>boolean result2 &#x3D; coll.isEmpty();</p><h2 id="6-获取集合长度"><a href="#6-获取集合长度" class="headerlink" title="6.获取集合长度"></a>6.获取集合长度</h2><p>int s &#x3D; coll.size();</p><h1 id="通用遍历方式"><a href="#通用遍历方式" class="headerlink" title="通用遍历方式"></a>通用遍历方式</h1><h2 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a>迭代器遍历</h2><p>Iterator&lt; String &gt; it &#x3D; list.iterator();&#x2F;&#x2F;获取集合的零索引<br>boolean flag &#x3D; it.hasNext();&#x2F;&#x2F;判断当前位置是否有元素<br>String str &#x3D; it.next();&#x2F;&#x2F;获取当前元素，并把指针移到下一个位置</p><p>可以做出一个循环<br>Iterator&lt; String &gt; it &#x3D; list.iterator();<br>while(it.hasNext()){<br>  String str &#x3D; it.next();<br>  System.out.println(str);<br>}</p><h2 id="List特有的列表迭代器"><a href="#List特有的列表迭代器" class="headerlink" title="List特有的列表迭代器"></a>List特有的列表迭代器</h2><p>就是在原有的基础上可以添加和删除元素<br>ListIterator&lt; String &gt; it &#x3D; list.ListIterator&lt;&gt;();<br>while(it.hasNext()){<br>  String str &#x3D; it.next();<br>  if(“bbb”.equals(str)){<br>    it.add(“qqq”);<br>  }<br>  System.out.println(str);<br>}</p><h2 id="增强for"><a href="#增强for" class="headerlink" title="增强for"></a>增强for</h2><p>只有单列集合和数组才能用<br>格式：<br>for(元素的数据类型 变量名 ：数组或集合){</p><p>}</p><p>例如<br>for(String s : list){<br>  System.out.println(s);<br>}</p><p>快捷键：coll.for</p><h2 id="lambda表达式遍历"><a href="#lambda表达式遍历" class="headerlink" title="lambda表达式遍历"></a>lambda表达式遍历</h2><p>格式(采用匿名内部类的方法)：<br> coll.forEach(new Consumer&lt; String &gt;() {<br>           @Override<br>           public void accept(String s) {<br>               System.out.println(s);<br>           }<br>       });</p><p>其中源码为：<br><img src="/%E5%9B%BE%E7%89%87/JAVA/%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF1.png"><br>也就是说foreach就是普通的for循环，而通过重写accept来规定循环的内容</p><p>而lambda表达式遍历为：<br>coll.foreach(s -&gt; System.out.println(s));</p><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>格式：<br>() -&gt; {</p><p>}</p><p>例如：<br>Integer[] a &#x3D; {2,1,4,6,7,8,56,4,3};</p><pre><code>    Arrays.sort(a, new Comparator&lt;Integer&gt;() &#123;        @Override        public int compare(Integer o1, Integer o2) &#123;            return o1 - o2;        &#125;    &#125;);</code></pre><p>其中的匿名内部类可以简化成<br>Arrays.sort(a, (Integer o1, Integer o2) -&gt; {<br>                return o1 - o2;<br>            }<br>        );</p><p>注意：<br>lambda表达式只能用于匿名内部类和函数式接口(有且仅有一个抽象方法的接口)</p><h1 id="List特有的方法"><a href="#List特有的方法" class="headerlink" title="List特有的方法"></a>List特有的方法</h1><h2 id="1-创建集合"><a href="#1-创建集合" class="headerlink" title="1.创建集合"></a>1.创建集合</h2><p>List&lt; String &gt; list &#x3D; new ArrayList&lt;&gt;();</p><h2 id="2-添加元素"><a href="#2-添加元素" class="headerlink" title="2.添加元素"></a>2.添加元素</h2><p>list.add(“aaa”);<br>list.add(“bbb”);<br>list.add(“ccc”);</p><h2 id="3-在指定索引处添加元素"><a href="#3-在指定索引处添加元素" class="headerlink" title="3.在指定索引处添加元素"></a>3.在指定索引处添加元素</h2><p>void add(int index, E element)</p><p>list.add( 1, “qqq”);<br>会输出  aaa , qqq , bbb , ccc<br>也就是说在指定位置添加元素不会覆盖掉原来的元素，而是会往后挪</p><h2 id="4-删除指定索引处的元素，返回被删除的元素"><a href="#4-删除指定索引处的元素，返回被删除的元素" class="headerlink" title="4.删除指定索引处的元素，返回被删除的元素"></a>4.删除指定索引处的元素，返回被删除的元素</h2><p>E remove(int index) </p><p>String s &#x3D; ist.remove(0);</p><p>如果是Integer类型的，如<br>List&lt; Integer &gt; list &#x3D; new ArrayList&lt;&gt;();<br>list.add(1);<br>list.add(2);<br>list.add(3);</p><p>此时想把’1’去掉，我们可以想到用 list.remove(1);<br>但这个’1’在此代码的作用是去掉索引为1的元素，也就是2<br>原因：<br>当方法发生重载时，会优先调用实参和形参类型相同的那个<br>1是int类型，而index也是int类型，所以此处的1是索引</p><p>所以应该：<br>Integer i &#x3D; Integer.valueOf(1);<br>list.remove(i);</p><p>也就是把’1’转化为Integer类型</p><h2 id="5-修改索引处的元素，返回被修改的元素"><a href="#5-修改索引处的元素，返回被修改的元素" class="headerlink" title="5.修改索引处的元素，返回被修改的元素"></a>5.修改索引处的元素，返回被修改的元素</h2><p>E set(int index, E element)</p><h2 id="6-返回索引处的元素"><a href="#6-返回索引处的元素" class="headerlink" title="6.返回索引处的元素"></a>6.返回索引处的元素</h2><p>E get(int index)</p><h1 id="ArrayList底层逻辑"><a href="#ArrayList底层逻辑" class="headerlink" title="ArrayList底层逻辑"></a>ArrayList底层逻辑</h1><p><img src="/%E5%9B%BE%E7%89%87/JAVA/ArrayList%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%911.png"></p><h1 id="泛型深入"><a href="#泛型深入" class="headerlink" title="泛型深入"></a>泛型深入</h1><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>修饰符 class 类名 &lt;类型&gt;{</p><p>}</p><p>如：<br>public class ArrayList<E>{</p><p>}<br>其中“E”为任意字母，但通常是E</p><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>修饰符 &lt;类型&gt; 返回值类型 方法名 (类型 变量名){</p><p>}<br>如<br>public &lt; T &gt; void move(T t){</p><p>}</p><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>修饰符 interfere 接口名 &lt; E &gt;{</p><p>}</p><h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p>就是？<br>其中包含:<br>？extends E  表示传递E或E所有的子类型<br>？super   E  表示传递E或E所有的父类型</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p><a href="https://xidongwe.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></p><h1 id="Set系列"><a href="#Set系列" class="headerlink" title="Set系列"></a>Set系列</h1><p><code>特点</code></p><p>Set系列集合：无序，不重复，无索引</p><p>无序：存和取的顺序有可能不同</p><p>不重复：元素不可重复</p><p>无索引：不可以通过索引获取每个元素</p><ul><li>创建一个Set集合的对象</li></ul><p>Set&lt; String &gt; s &#x3D; new HashSet&lt;&gt;();</p><ul><li>添加元素</li></ul><p>s.add(“sss”);  &#x2F;&#x2F;第一次添加的时候成功，返回true</p><p>s.add(“sss”);  &#x2F;&#x2F;第二次添加的时候失败（因为元素不可重复），返回false</p><ul><li>打印元素（同List）<ul><li>迭代器遍历</li><li>增强for</li><li>lambda</li></ul></li></ul><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p><code>特点</code></p><p>无序，不重复，无索引</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/picture%E5%93%88%E5%B8%8C%E5%80%BC" alt="image-20250624195148210"></p><ul><li>创建对象</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student s1 = new Student(&quot;1&quot;,1);</span><br><span class="line">Student s2 = new Student(&quot;1&quot;,1);</span><br></pre></td></tr></table></figure><ul><li>如果没有重写hashCode方法的话，不同对象计算出的哈希值就不一样</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(s1.hashCode());</span><br><span class="line">System.out.println(s2.hashCode());</span><br></pre></td></tr></table></figure><p>重写的话就在Student类中按<code>alt</code>+<code>ins</code>，选择图上所示，之后next即可</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/picture%E5%93%88%E5%B8%8C%E5%80%BC2" alt="image-20250624200410429"></p><p>哈希碰撞的话<code>abc</code>和<code>acD</code>会出现</p><ul><li>HashSet底层逻辑</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureHashSet4" alt="image-20250624202533085"></p><ol><li>第一点中的<code>0.75</code>意思是：当数组中有16X0.75&#x3D;12个元素时，数组将扩容为原来的两倍，即变为24</li><li>第二点中数据的位置的计算公式为<code>int index = (数组长度 - 1) &amp; 哈希值;</code></li></ol><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><ul><li>LinkedHashSet底层逻辑</li></ul><p><code>特点</code></p><p>有序，不重复，无索引</p><p>（有序是因为有双链表）</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/picture%E5%93%88%E5%B8%8C%E5%80%BC5" alt="image-20250624204322908"></p><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p><code>规则</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureRedBlack2" alt="image-20250625101732136"></p><p>默认节点是红色的（效率高，因为调整的地方要少）</p><p>具体讲解跳转<a href="https://www.bilibili.com/video/BV17F411T7Ao?spm_id_from=333.788.videopod.episodes&vd_source=b0dff9885c076f5f4c78c1f99505a0cf&p=196">黑马</a></p><h1 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h1><p><code>特点</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureTreeSet1" alt="image-20250625090223814"></p><ul><li>创建TreeSet对象</li></ul><p>TreeSet&lt; Integer &gt; st &#x3D; new TreeSet&lt;&gt;();</p><ul><li>添加元素</li></ul><p>ts.add(3);</p><p>ts.add(1);</p><p>ts.add(2);</p><p>最后还是会按大小排序输出</p><ul><li><code>规则</code></li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureTreeSet2" alt="image-20250625092252732"></p><h2 id="比较方法"><a href="#比较方法" class="headerlink" title="比较方法"></a>比较方法</h2><ol><li><p>自然排序</p><p>在类（比如Student）实现Comparable接口，重写里面的抽象方法，在指定比较规则</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int compareTo(Student o) &#123;</span><br><span class="line">    return this.getAge() - o.getAge();（举的例子）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>比较器排序</p><p>创建TreeSet对象时，传递Comparator制定规则</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;String&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;String&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(String o1, String o2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其中<code>o1</code>表示当前要添加的元素，<code>o2</code>表示红黑树中已经存在都在的元素</p><h1 id="单列集合总结"><a href="#单列集合总结" class="headerlink" title="单列集合总结"></a>单列集合总结</h1><p>(<img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureRedBlack6" alt="image-20250625135242615">)</p><h1 id="双列集合"><a href="#双列集合" class="headerlink" title="双列集合"></a>双列集合</h1><ul><li>特点</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/picture%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%881" alt="image-20250626105055472"></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/picture%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%882" alt="image-20250626105249137"></p><h2 id="Map的常见API"><a href="#Map的常见API" class="headerlink" title="Map的常见API"></a>Map的常见API</h2><p>Map是双列集合的顶层接口，他的功能是双列集合都可以继承使用的</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/picture%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%883" alt="image-20250626105738348"></p><ul><li>创建Map集合对象Map&lt;String,String&gt; m &#x3D; new HashMap&lt;&gt;();</li></ul><p>其中添加元素时</p><ol><li>如果键不存在,会直接把键值对对象添加到Map集合当中</li><li>如果键存在，会把原有的键值对对象覆盖，把被覆盖的键值对对象返回</li></ol><h1 id="Map的遍历方法"><a href="#Map的遍历方法" class="headerlink" title="Map的遍历方法"></a>Map的遍历方法</h1><h2 id="键找值"><a href="#键找值" class="headerlink" title="键找值"></a>键找值</h2><ul><li>获取所有的键，把这些键放到一个单列集合当中</li></ul><p>Set<String> keys &#x3D; m.keySet();</p><ul><li>遍历单列集合，获取每一个键</li></ul><p>for (String key : keys) {<br>    System.out.println(key);</p><p>​    &#x2F;&#x2F;利用Map集合的键获取对应的值</p><p>​    String value &#x3D; m.get(key);</p><p>​    System.out.println(key+”&#x3D;”+value);</p><p>}</p><h2 id="键值对对象遍历"><a href="#键值对对象遍历" class="headerlink" title="键值对对象遍历"></a>键值对对象遍历</h2><ul><li>通过一个方法获取所有的键值对对象，返回一个Set集合</li></ul><p>Set&lt;Map.Entry&lt;String, String&gt;&gt; e &#x3D; m.entrySet();</p><ul><li>遍历e这个集合，获取每一个键值对对象</li></ul><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><ul><li>匿名内部类为</li></ul><p>m.forEach(new BiConsumer&lt;String, String&gt;() {<br>    @Override<br>    public void accept(String s, String s2) {<br>        System.out.println(s+s2);<br>    }<br>})；</p><ul><li>Lambda表达式为</li></ul><p>m.forEach((s,s2) -&gt; System.out.println(s+s2));</p><p><code>foreach底层</code></p><p>其实就是调用第二种方法，获取每一个key和value，在调用accept方法</p><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p><code>特点</code></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/picture%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%884" alt="image-20250626140802961"></p><h1 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h1><ul><li>由键决定：有序，不重复，无索引</li><li><code>原理</code>：底层数据结构依然是哈希表，只是多了个双链表</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250707110520535.png" alt="image-20250707110520535"></p><h1 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h1><ul><li>与TreeSet一样，都是红黑树结构</li><li>对键进行排序，默认从小到大，也可以自己修改排序规则</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;Character,Integer&gt; tm = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Character&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Character o1, Character o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>或者</p><p>在类中传入接口Comparable</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250707145132266.png" alt="image-20250707145132266"></p><p>再alt+enter修改</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250707145327692.png" alt="image-20250707145327692"></p><h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><p>当执行某个函数的时候，因为不清楚所需参数的多少，所以可以用可变参数</p><p><code>格式</code>:</p><p>public static 类型 函数名(E…参数名(一般为args)){</p><p>}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">        System.out.println(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>...i)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum_</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : i) &#123;</span><br><span class="line">            sum_ += j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>细节</code>：</p><ol><li>方法中的形参中可变参数只能有一个</li><li>如果有其他的参数，可变参数要写在最后</li></ol><h1 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h1><p>Collections不是集合，而是集合的工具类</p><p>工具类的特点：直接<code>名称.</code>即可调用方法</p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/pictureimage-20250707173047469.png" alt="image-20250707173047469"></p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python初学</title>
      <link href="/2025/06/17/Python/%E8%87%AA%E5%8F%98%E9%87%8F/"/>
      <url>/2025/06/17/Python/%E8%87%AA%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="自变量"><a href="#自变量" class="headerlink" title="自变量"></a>自变量</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/picture%E8%87%AA%E5%8F%98%E9%87%8F1" alt="image-20250627092001380"></p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><ul><li>单行注释</li></ul><p>以<code>#</code>开头（建议#与注释的内容空一格）</p><ul><li>多行注释</li></ul><p>以<code>&quot;&quot;&quot;</code>开头和结尾</p><h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><p>print(“”,数字等自变量,“”)</p><p>(<code>不用引号居然</code>)</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>print(type(想要知道数据类型的数据))</p><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/picture%E8%87%AA%E5%8F%98%E9%87%8F2" alt="image-20250627100012737"></p><h1 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h1><ul><li>内容限定</li></ul><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/picture%E8%87%AA%E5%8F%98%E9%87%8F3" alt="image-20250627100731539"></p><ul><li>大小写敏感</li><li>不可使用关键字</li></ul><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/picture%E8%87%AA%E5%8F%98%E9%87%8F4.0" alt="image-20250627203436072"></p><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/picture%E8%87%AA%E5%8F%98%E9%87%8F5" alt="image-20250627204007157"></p><h1 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h1><p>我们输出print时候，可以用<code>+</code>把字符串连接起来输出，但是字符串不能跟其他类型的相连，并且当有很多变量时也很麻烦，所以可以用<code>字符串格式化</code>来解决</p><p>name &#x3D; “日奈”</p><p>teacher &#x3D; “永远喜欢 %s” % name</p><p>其中<code>%</code>表示我要占位，<code>S</code>表示将变量变成字符串放入占位的位置</p><p>这个方法可以将数字和其他类型的变量跟字符串一起连接</p><p>age &#x3D; 17</p><p>teacher &#x3D; “为师永远喜欢%s岁的 %s” % (age,name)&#x2F;&#x2F;顺序不能乱</p><p>当然也有其他类型的,例如<code>%d</code>对应整数,<code>%f</code>对应浮点型</p><h2 id="精度控制"><a href="#精度控制" class="headerlink" title="精度控制"></a>精度控制</h2><p><code>m</code>控制宽度,要求是数字，如%5d</p><p><code>.n</code>控制小数点精度，要求是数字，会对小数进行四舍五入，如%5.2d</p><h2 id="快速格式化"><a href="#快速格式化" class="headerlink" title="快速格式化"></a>快速格式化</h2><p>通过f“内容{变量}”实现</p><p>如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 4.572</span><br><span class="line">b = 8</span><br><span class="line">print(f&quot;&#123;a&#125;+&#123;b&#125; = &#123;a + b&#125;&quot;)</span><br></pre></td></tr></table></figure><h1 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h1><p>put &#x3D; input()</p><p>print(put)</p><p>其中在input的()中可以添加字符串，此字符串会出现在键盘输入的前面</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逻辑判断</title>
      <link href="/2025/06/17/Python/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/"/>
      <url>/2025/06/17/Python/%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="布尔bool"><a href="#布尔bool" class="headerlink" title="布尔bool"></a>布尔bool</h1><p>字面量</p><ul><li>True</li><li>Flase</li></ul><h1 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h1><p><img src="https://raw.githubusercontent.com/XiDongWe/Picture/main/picture95.png" alt="image-20250629161640995"></p><h1 id="if判断语句"><a href="#if判断语句" class="headerlink" title="if判断语句"></a>if判断语句</h1><p><code>格式</code></p><p>if 要判断的条件：</p><p>   条件成立时要做的事情</p><h2 id="if-lese语句"><a href="#if-lese语句" class="headerlink" title="if-lese语句"></a>if-lese语句</h2><p>if 要判断的条件：</p><p>   条件成立时要做的事情</p><p>else ：</p><p>   条件成立时要做的事情</p><h2 id="if-elif-else语句"><a href="#if-elif-else语句" class="headerlink" title="if-elif-else语句"></a>if-elif-else语句</h2><p>if 条件1：</p><p>   条件成立时要做的事情</p><p>elif 条件2：</p><p>   条件成立时要做的事情</p><p>else ：</p><p>   条件成立时要做的事情</p><h1 id="random"><a href="#random" class="headerlink" title="random"></a>random</h1><p>import random</p><p>num &#x3D; random.randint(e1,e2)</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2025/06/16/JAVASE/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2025/06/16/JAVASE/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="1-正则表达式"><a href="#1-正则表达式" class="headerlink" title="1.正则表达式"></a>1.正则表达式</h1><p>用.matches，返回boolean<br><img src="/%E5%9B%BE%E7%89%87/JAVA/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F1.png"><br><img src="/%E5%9B%BE%E7%89%87/JAVA/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F2.png"><br><img src="/%E5%9B%BE%E7%89%87/JAVA/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F3.png"></p><p>正则表达式是从左往右检查的，且一个[]只对应一个字符<br>如:   “a”.matches(“[abc]”)   为 true, 但”ab”.matches(“[abc]”)为false，因为”b”无法判断</p><h1 id="2-爬虫"><a href="#2-爬虫" class="headerlink" title="2.爬虫"></a>2.爬虫</h1><p>假如有一段字符串<br>String str &#x3D; “ Java自从95年问世以来，经历了很多版本，目前企业中用的最多的是Java8和Java11, “ +<br>“因为这两个是长期支持版本，下一个长期支持版本是Java17，相信在未来不久Java17也会逐渐登上历史舞台“；”<br>要找出里面所有的JAVAXX</p><p>方法:<br>&#x2F;&#x2F;获取正则表达式的对象<br>Pattern p &#x3D; Pattern.compile(“JAVA\d{0,2}”);</p><p>&#x2F;&#x2F;再获取文本匹配器的对象<br>Matcher m &#x3D; p.matcher(str);</p><p>&#x2F;&#x2F;之后文本匹配器会从头开始检查时候符合，符合的话返回true，反之返回false】<br>boolean b &#x3D; m.find();</p><p>&#x2F;&#x2F;find会把符合的字符串进行截取<br>String s &#x3D; m.group();</p><p>&#x2F;&#x2F;但这样只能返回一次，所以我们可以用循环<br>while(m.fine()) {<br>    String s &#x3D; m.group();<br>    System.out.println(s);<br>}</p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/2025/05/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/"/>
      <url>/2025/05/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>冒泡排序<br><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span> </span>&#123;  <span class="comment">// 冒泡排序法，添加数组长度参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j - <span class="number">1</span>] &gt; a[j]) &#123;</span><br><span class="line">                <span class="type">int</span> t = a[j - <span class="number">1</span>];</span><br><span class="line">                a[j - <span class="number">1</span>] = a[j];</span><br><span class="line">                a[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArr</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span> </span>&#123;    <span class="comment">// 添加数组长度参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)   <span class="comment">// 修正循环条件</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123; <span class="number">23</span>,<span class="number">54</span>,<span class="number">12</span>,<span class="number">67</span>,<span class="number">879</span>,<span class="number">567</span>,<span class="number">435</span>,<span class="number">45</span>,<span class="number">32</span>,<span class="number">4</span>,<span class="number">54</span>,<span class="number">345</span> &#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(a[<span class="number">0</span>]);  <span class="comment">// 计算数组长度</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">BubbleSort</span>(a, n);      <span class="comment">// 传递数组和长度</span></span><br><span class="line">    <span class="built_in">printArr</span>(a, n);        <span class="comment">// 传递数组和长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>快速排序<br>定义开头的[0]为left,定义[n]为right,定义[0]为标准<br>原理:<br>通过left和right与标准的不断对比和移动，最后使得标准的左侧都比标准小，右侧都比标准大<br><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FastSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> boss = a[left];       <span class="comment">// 选择基准值</span></span><br><span class="line">        <span class="type">int</span> hole = left;          <span class="comment">// 孔位初始指向第一个元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 从右向左查找小于基准值的元素</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt;= boss) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            a[hole] = a[right];</span><br><span class="line">            hole = right;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从左向右查找大于基准值的元素</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt;= boss) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            a[hole] = a[left];</span><br><span class="line">            hole = left;</span><br><span class="line">        &#125;</span><br><span class="line">        a[hole] = boss; <span class="comment">// 将基准值放到中间位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归对左右两部分排序</span></span><br><span class="line">        <span class="built_in">FastSort</span>(a, <span class="number">0</span>, hole - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">FastSort</span>(a, hole + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">p</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123; <span class="number">4</span>, <span class="number">3</span>, <span class="number">30</span>, <span class="number">45</span>, <span class="number">54</span>, <span class="number">54</span>, <span class="number">67</span>, <span class="number">213</span>, <span class="number">435</span>, <span class="number">567</span>, <span class="number">879</span>, <span class="number">345</span> &#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">FastSort</span>(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">p</span>(a, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接插入排序<br>循环开始：从数组的第二个元素（索引为1）开始，因为单个元素本身就是有序的。<br>保存当前元素：将当前元素arr[i]保存到key中。<br>比较和移动：将key与前面已排序部分的元素进行比较，如果前面的元素大于key，则将该元素向后移动一位。<br>插入位置：找到第一个小于等于key的元素位置，将key插入到该位置。<br><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%9B%B4%E6%8E%A5%E6%8E%92%E5%BA%8F.gif"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123; <span class="comment">// 从数组的第二个元素开始循环</span></span><br><span class="line">        <span class="type">int</span> key = arr[i]; <span class="comment">// 将当前元素赋值给key</span></span><br><span class="line">        j = i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将比key大的元素都依次向后移动一位</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = key; <span class="comment">// 将key插入到正确的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123; <span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span> &#125;; <span class="comment">// 定义一个数组</span></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]); <span class="comment">// 计算数组的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">insertionSort</span>(arr, n); <span class="comment">// 调用排序函数对数组进行排序</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的数组: \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printArray</span>(arr, n); <span class="comment">// 打印排序后的数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>希尔排序<br><video src="/图片/数据结构/希尔排序.mp4" controls="controls" width="100%"></video></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> gap = n / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (gap &gt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; n; i++) &#123;</span><br><span class="line"><span class="type">int</span> temp = a[i];</span><br><span class="line"><span class="type">int</span> j = i;</span><br><span class="line"><span class="keyword">while</span>(j&gt;=gap &amp;&amp; a[j - gap] &gt; temp) &#123;</span><br><span class="line">a[j] = a[j - gap];</span><br><span class="line">j -= gap;</span><br><span class="line">&#125;</span><br><span class="line">a[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">gap /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">234</span>,<span class="number">5</span>,<span class="number">5678</span>,<span class="number">54</span>,<span class="number">68</span>,<span class="number">7</span>,<span class="number">546</span>,<span class="number">3</span>,<span class="number">42</span>,<span class="number">5</span>,<span class="number">789</span>,<span class="number">0</span> &#125;; <span class="comment">// 定义一个数组</span></span><br><span class="line"><span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]); <span class="comment">// 计算数组的长度</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">insert</span>(arr, n); <span class="comment">// 调用排序函数对数组进行排序</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;排序后的数组: \n&quot;</span>);</span><br><span class="line"><span class="built_in">printArray</span>(arr, n); <span class="comment">// 打印排序后的数组</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接选择排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> temp, min;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">min = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[j] &lt; a[min]) &#123;</span><br><span class="line">min = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">temp = a[i];</span><br><span class="line">a[i] = a[min];</span><br><span class="line">a[min] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">234</span>,<span class="number">5</span>,<span class="number">5678</span>,<span class="number">54</span>,<span class="number">68</span>,<span class="number">7</span>,<span class="number">546</span>,<span class="number">3</span>,<span class="number">42</span>,<span class="number">5</span>,<span class="number">789</span>,<span class="number">0</span> &#125;; <span class="comment">// 定义一个数组</span></span><br><span class="line"><span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]); <span class="comment">// 计算数组的长度</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">insert</span>(arr, n); <span class="comment">// 调用排序函数对数组进行排序</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;排序后的数组: \n&quot;</span>);</span><br><span class="line"><span class="built_in">printArray</span>(arr, n); <span class="comment">// 打印排序后的数组</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插帽龟，他很稳（插入，冒泡，归并）<br>插帽龟喜欢选帽插，插完就慌了（慌了&#x3D;方了，n的平方）<br>快龟堆，见到n老（nlog n）</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象进阶</title>
      <link href="/2025/05/09/JAVASE/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/"/>
      <url>/2025/05/09/JAVASE/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-static"><a href="#1-static" class="headerlink" title="1.static"></a>1.static</h1><p>在main中调用类名的方法时，其方法的对象可能是多个对象的共同对象<br>比如说创建了s1,s2两个学生对象，他们有共同的老师t，调用方法时老师是同一个<br>但如果不加static，t就需要被定义两次<br><img src="/%E5%9B%BE%E7%89%87/JAVA/static.png"><br>所以要用static<br><img src="/%E5%9B%BE%E7%89%87/JAVA/static1.png"><br>被static修饰的变量叫做 静态变量</p><h1 id="2-继承extends"><a href="#2-继承extends" class="headerlink" title="2.继承extends"></a>2.继承extends</h1><p>啥时候用继承？<br>当类与类之间，存在共性的的内容，并满足子类是父类的一种，就可以用继承</p><h1 id="3-多态"><a href="#3-多态" class="headerlink" title="3.多态"></a>3.多态</h1><p><img src="/%E5%9B%BE%E7%89%87/JAVA/%E5%A4%9A%E6%80%81.png"><br><img src="/%E5%9B%BE%E7%89%87/JAVA/%E5%A4%9A%E6%80%812.png"><br><img src="/%E5%9B%BE%E7%89%87/JAVA/%E5%A4%9A%E6%80%813.png"><br>创建完对象之后用:register(s)  register(t)   register(admin)调用即可</p><h1 id="4-包"><a href="#4-包" class="headerlink" title="4.包"></a>4.包</h1><p><img src="/%E5%9B%BE%E7%89%87/JAVA/%E5%8C%851.png"><br><img src="/%E5%9B%BE%E7%89%87/JAVA/%E5%8C%852.png"></p><h1 id="5-final"><a href="#5-final" class="headerlink" title="5.final"></a>5.final</h1><p><img src="/%E5%9B%BE%E7%89%87/JAVA/final1.png"><br>例子：<br>class Fu{<br>  public final void show(){<br>    ……<br>  }<br>}</p><h1 id="6-权限修饰符"><a href="#6-权限修饰符" class="headerlink" title="6.权限修饰符"></a>6.权限修饰符</h1><p><img src="/%E5%9B%BE%E7%89%87/JAVA/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A61.png"><br>(protected如同私生子)</p><h1 id="7-抽象类"><a href="#7-抽象类" class="headerlink" title="7.抽象类"></a>7.抽象类</h1><p>使用abstract后，必须重写</p><p>继承抽象类的解决方案：</p><ol><li>重写里面所有的方法</li><li>其子类也需要时抽象的，子类重写所有方法</li></ol><p><img src="/%E5%9B%BE%E7%89%87/JAVA/%E6%8A%BD%E8%B1%A1%E7%B1%BB1%C2%B7.png"></p><h1 id="8-接口"><a href="#8-接口" class="headerlink" title="8.接口"></a>8.接口</h1><p><img src="/%E5%9B%BE%E7%89%87/JAVA/%E6%8E%A5%E5%8F%A3.png"></p><h1 id="9-匿名内部类"><a href="#9-匿名内部类" class="headerlink" title="9.匿名内部类"></a>9.匿名内部类</h1><p>比如有个方法<br>public static void method(Animal a){<br>  a.eat;<br>}<br>按之前的方法，首先要创建一个Dog类，再在测试类中创建一个新的dog对象，再method(d)<br>但是如果只是用一次的话，中间的过程太过麻烦，所以可以用匿名内部类</p><p>method(<br>      new Animal() {<br>        public void eat() {<br>          System.out.println(“狗吃骨头”);<br>        }<br>      }</p><p>);</p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>String</title>
      <link href="/2025/05/08/JAVASE/String/"/>
      <url>/2025/05/08/JAVASE/String/</url>
      
        <content type="html"><![CDATA[<h1 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h1><ol><li><p>创建对象<br>StringBuilder sb &#x3D; new StringBuilder();</p></li><li><p>添加元素append()<br>sb.append(1);<br>sb.append(dkjfak);</p></li><li><p>反转reverse()<br>sb.reverse();</p></li><li><p>获取长度length()<br>int len &#x3D; sb.length();</p></li><li><p>变回字符串toString()<br>(因为sb是StringBuilder类型的，并不是字符串)<br>String str &#x3D; sb.toString();</p></li></ol><h1 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a>StringJoiner</h1><p>可以拼接字符串<br>StringJoiner sj &#x3D; new StringJoiner(中间部分，起始部分，结尾部分);<br>sj.add(对象)</p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>循环列表</title>
      <link href="/2025/05/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/"/>
      <url>/2025/05/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>#include&lt;stdio.h&gt;<br>#include&lt;stdlib.h&gt;<br>#define max 100<br>typedef int ElemType;</p><p>typedef struct QueueNode{<br>ElemType data;<br>struct QueueNode *next;<br>}QueueNode;</p><p>typedef struct{<br>QueueNode* front;<br>QueueNode* rear;<br>}Queue;</p><p>&#x2F;&#x2F;初始化<br>Queue* initQueueNode() {<br>QueueNode* node &#x3D; (QueueNode*)malloc(sizeof(QueueNode));&#x2F;&#x2F;node是头结点<br>Queue* q &#x3D; (Queue*)malloc(sizeof(Queue));<br>node-&gt;data &#x3D; 0;<br>node-&gt;next &#x3D; NULL;<br>q-&gt;front &#x3D; node;<br>q-&gt;rear &#x3D; node;<br>return q;<br>}</p><p>&#x2F;&#x2F;判断是否为空<br>int isEmpty(Queue* q) {<br>if (q-&gt;front &#x3D;&#x3D; q-&gt;rear) {<br>return 1;<br>}<br>else {<br>return 0;<br>}<br>}</p><p>&#x2F;&#x2F;入队<br>void inQueue(Queue *q, ElemType e) {<br>QueueNode <em>node &#x3D; (QueueNode</em>)malloc(sizeof(QueueNode));<br>node-&gt;data &#x3D; e;<br>node-&gt;next &#x3D; NULL;<br>q-&gt;rear-&gt;next &#x3D; node;&#x2F;&#x2F;把node赋给尾巴的下一个<br>q-&gt;rear &#x3D; node;&#x2F;&#x2F;      之后再让尾巴变成node<br>}</p><p>&#x2F;&#x2F;出队<br>int outQueue(Queue *q, ElemType *e) {<br>if (isEmpty(q)) {<br>printf(“空的”);<br>return 0;<br>}<br>QueueNode *node &#x3D; q-&gt;front-&gt;next;&#x2F;&#x2F;q-&gt;front指向头结点，node就是头结点的下一个节点<br>*e &#x3D; node-&gt;data;<br>q-&gt;front-&gt;next &#x3D; node-&gt;next;<br>if (q-&gt;rear &#x3D;&#x3D; node) {<br>q-&gt;rear &#x3D; q-&gt;front;<br>}<br>free(node);<br>return 1;<br>}</p><p>int main() {<br>Queue* q &#x3D; initQueueNode();<br>inQueue(q, 10);<br>inQueue(q, 20);<br>inQueue(q, 30);<br>ElemType e;<br>outQueue(q, &amp;e);<br>printf(“%d”, e);<br>return 0;<br>}</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>链队列</title>
      <link href="/2025/05/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E9%98%9F%E5%88%97/"/>
      <url>/2025/05/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E9%98%9F%E5%88%97.png"><br>#include&lt;stdio.h&gt;<br>#include&lt;stdlib.h&gt;<br>#define max 100<br>typedef int ElemType;</p><p>typedef struct QueueNode{<br>ElemType data;<br>struct QueueNode *next;<br>}QueueNode;</p><p>typedef struct{<br>QueueNode* front;<br>QueueNode* rear;<br>}Queue;</p><p>&#x2F;&#x2F;初始化<br>Queue* initQueueNode() {<br>QueueNode* node &#x3D; (QueueNode*)malloc(sizeof(QueueNode));&#x2F;&#x2F;node是头结点<br>Queue* q &#x3D; (Queue*)malloc(sizeof(Queue));<br>node-&gt;data &#x3D; 0;<br>node-&gt;next &#x3D; NULL;<br>q-&gt;front &#x3D; node;<br>q-&gt;rear &#x3D; node;<br>return q;<br>}</p><p>&#x2F;&#x2F;判断是否为空<br>int isEmpty(Queue* q) {<br>if (q-&gt;front &#x3D;&#x3D; q-&gt;rear) {<br>return 1;<br>}<br>else {<br>return 0;<br>}<br>}</p><p>&#x2F;&#x2F;入队<br>void inQueue(Queue *q, ElemType e) {<br>QueueNode <em>node &#x3D; (QueueNode</em>)malloc(sizeof(QueueNode));<br>node-&gt;data &#x3D; e;<br>node-&gt;next &#x3D; NULL;<br>q-&gt;rear-&gt;next &#x3D; node;&#x2F;&#x2F;把node赋给尾巴的下一个<br>q-&gt;rear &#x3D; node;&#x2F;&#x2F;      之后再让尾巴变成node<br>}</p><p>&#x2F;&#x2F;出队<br>int outQueue(Queue *q, ElemType *e) {<br>if (isEmpty(q)) {<br>printf(“空的”);<br>return 0;<br>}<br>QueueNode *node &#x3D; q-&gt;front-&gt;next;&#x2F;&#x2F;q-&gt;front指向头结点，node就是头结点的下一个节点<br>*e &#x3D; node-&gt;data;<br>q-&gt;front-&gt;next &#x3D; node-&gt;next;<br>if (q-&gt;rear &#x3D;&#x3D; node) {<br>q-&gt;rear &#x3D; q-&gt;front;<br>}<br>free(node);<br>return 1;<br>}</p><p>int main() {<br>Queue* q &#x3D; initQueueNode();<br>inQueue(q, 10);<br>inQueue(q, 20);<br>inQueue(q, 30);<br>ElemType e;<br>outQueue(q, &amp;e);<br>printf(“%d”, e);<br>return 0;<br>}</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>队列</title>
      <link href="/2025/05/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/"/>
      <url>/2025/05/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97.png"><br>队列是先进先出,像排队一样</p><p>#include&lt;stdio.h&gt;<br>#include&lt;stdlib.h&gt;<br>#define max 100<br>typedef int ElemType;</p><p>typedef struct {<br>ElemType* data;<br>int front;<br>int rear;<br>}Queue;</p><p>&#x2F;&#x2F;初始化<br>Queue* initQueue() {<br>Queue* q &#x3D; (Queue*)malloc(sizeof(Queue));<br>q-&gt;data &#x3D; (ElemType*)malloc(sizeof(ElemType));<br>q-&gt;front &#x3D; 0;<br>q-&gt;rear &#x3D; 0;<br>return q;<br>}</p><p>&#x2F;&#x2F;出队<br>ElemType outQueue(Queue* q) {<br>if (q-&gt;front &#x3D;&#x3D; q-&gt;rear) {<br>printf(“空的”);<br>return 0;<br>}<br>ElemType e &#x3D; q-&gt;data[q-&gt;front];<br>q-&gt;front++;<br>return e;<br>}</p><p>&#x2F;&#x2F;判断是否为满<br>int queueFull(Queue* q) {<br>if (q-&gt;front &gt; 0) {<br>int step &#x3D; q-&gt;front;<br>for (int i &#x3D; q-&gt;front; i &lt; q-&gt;rear; i++)<br>{<br>q-&gt;data[i - step] &#x3D; q-&gt;data[i];<br>}<br>q-&gt;front &#x3D; 0;<br>q-&gt;rear &#x3D; q-&gt;rear - step;<br>return 1;<br>}<br><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%85%A5%E9%98%9F.png"><br>else {<br>printf(“真的满了”);<br>return 0;<br>}<br>}</p><p>&#x2F;&#x2F;入队<br>int inQueue(Queue* q, ElemType e) {<br>if (q-&gt;rear &gt;&#x3D; max) {<br>if (!(queueFull))&#x2F;&#x2F;这时候判断是否真的满了<br>{<br>return 0;<br>}<br>}<br>q-&gt;data[q-&gt;rear] &#x3D; e;<br>q-&gt;rear++;<br>return 1;<br>}</p><p>&#x2F;&#x2F;循环队列-入队<br>int cycleIn(Queue* q, ElemType e) {<br>if ((q-&gt;rear + 1) % max &#x3D;&#x3D; q-&gt;front) {<br>printf(“满了”);<br>return 0;<br>}<br>q-&gt;rear &#x3D; (q-&gt;rear + 1) % max;<br>return 1;<br>}</p><p>int main() {<br>Queue* q &#x3D; initQueue();<br>inQueue(q, 10);<br>inQueue(q, 20);<br>inQueue(q, 30);<br>printf(“%d”, outQueue(q));<br>printf(“%d”, outQueue(q));</p><pre><code>return 0;</code></pre><p>}</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>栈</title>
      <link href="/2025/05/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/"/>
      <url>/2025/05/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88.png"><br>栈是后进先出，像弹夹一样</p><p>#include&lt;stdio.h&gt;<br>#include&lt;stdlib.h&gt;<br>#define max 100<br>typedef int ElemType;</p><p>typedef struct {<br>ElemType data[max];<br>int top;<br>}Stack;</p><p>&#x2F;&#x2F;初始化<br>void initStack(Stack* s) {<br>s-&gt;top &#x3D; -1;<br>}</p><p>&#x2F;&#x2F;压栈&#x2F;进栈<br>int push(Stack* s, ElemType e) {<br>if (s-&gt;top &gt;&#x3D; max - 1) {<br>printf(“满了\n”);<br>return 0;<br>}<br>s-&gt;top++;<br>s-&gt;data[s-&gt;top] &#x3D; e;<br>return 1;<br>}</p><p>&#x2F;&#x2F;出栈<br>int pop(Stack <em>s, ElemType</em> e){<br>if (s-&gt;top &#x3D;&#x3D; -1) {<br>printf(“空的”);<br>return 0;<br>}<br>*e &#x3D; s-&gt;data[s-&gt;top];<br>s-&gt;top–;<br>return 1;<br>}</p><p>int main() {<br>Stack s;<br>initStack(&amp;s);<br>push(&amp;s, 10);<br>push(&amp;s, 20);<br>push(&amp;s, 30);<br>ElemType e;<br>pop(&amp;s, &amp;e);<br>printf(“%d\n”, e);<br>return 0;<br>}</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>韩语基础篇</title>
      <link href="/2025/05/06/%E9%9F%A9%E8%AF%AD/%E9%9F%A9%E8%AF%AD%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
      <url>/2025/05/06/%E9%9F%A9%E8%AF%AD/%E9%9F%A9%E8%AF%AD%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>日常生活<br>单词:</p>]]></content>
      
      
      <categories>
          
          <category> 韩语 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>双向链表</title>
      <link href="/2025/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
      <url>/2025/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>#include&lt;stdio.h&gt;<br>#include&lt;stdlib.h&gt;<br>typedef int ElemType;</p><p>typedef struct node{<br>ElemType data;<br>struct node *prev, *next;</p><p>}Node;</p><p>&#x2F;&#x2F;初始化双向链表<br>Node* initNode() {<br>Node* head &#x3D; (Node*)malloc(sizeof(Node));<br>head-&gt;data &#x3D; 0;<br>head-&gt;prev &#x3D; NULL;<br>head-&gt;next &#x3D; NULL;<br>return head;<br>}</p><p>&#x2F;&#x2F;头插法<br>int insertHead(Node* L, ElemType e) {<br>Node* p &#x3D; (Node*)malloc(sizeof(Node));<br>p-&gt;data &#x3D; e;<br>p-&gt;prev &#x3D; L;<br>p-&gt;next &#x3D; L-&gt;next;<br>if (L-&gt;next !&#x3D; NULL) {<br>L-&gt;next-&gt;prev &#x3D; p;<br>}<br>L-&gt;next &#x3D; p;<br>return 1;<br>}</p><p>&#x2F;&#x2F;遍历<br>int listNode(Node* L) {<br>Node* p &#x3D; L-&gt;next;<br>while (p !&#x3D; NULL) {<br>printf(“%d  “, p-&gt;data);<br>p &#x3D; p-&gt;next;<br>}<br>printf(“\n”);<br>return 1;<br>}</p><p>&#x2F;&#x2F;获取尾部节点<br>Node* getTail(Node* L) {<br>Node* p &#x3D; L;<br>while (p-&gt;next !&#x3D; NULL) {<br>p &#x3D; p-&gt;next;<br>}<br>return p;<br>}</p><p>&#x2F;&#x2F;尾插法<br>Node* insertTail(Node* tail, ElemType e) {<br>Node* p &#x3D; (Node*)malloc(sizeof(Node));<br>p-&gt;data &#x3D; e;<br>p-&gt;prev &#x3D; tail;<br>tail-&gt;next &#x3D; p;<br>p-&gt;next &#x3D; NULL;<br>return p;<br>}</p><p>&#x2F;&#x2F;指定位置插入<br>void insertNode(Node* L, int pos, ElemType e) {<br>Node* p &#x3D; L;<br>int i &#x3D; 0;<br>while (i &lt; pos - 1) {<br>p &#x3D; p-&gt;next;<br>i++;<br>}<br>Node* q &#x3D; (Node*)malloc(sizeof(Node));<br>q-&gt;data &#x3D; e;<br>q-&gt;prev &#x3D; p;<br>q-&gt;next &#x3D; p-&gt;next;<br>p-&gt;next &#x3D; q;<br>p-&gt;next-&gt;prev &#x3D; q;<br>}</p><p>&#x2F;&#x2F;删除节点<br>int deleteNode(Node* L, int pos) {<br>Node* p &#x3D; L;<br>int i &#x3D; 0;<br>while (i &lt; pos - 1) {<br>p &#x3D; p-&gt;next;<br>i++;<br>if (p &#x3D;&#x3D; NULL){<br>return 0;<br>}<br>}<br>Node* q &#x3D; p-&gt;next;<br>p-&gt;next &#x3D; q-&gt;next;<br>q-&gt;next-&gt;prev &#x3D; p;<br>free(q);<br>return 1;<br>}</p><p>int main() {<br>Node* list &#x3D; initNode();<br>&#x2F;<em>insertHead(list, 1);<br>insertHead(list, 2);<br>insertHead(list, 3);</em>&#x2F;<br>Node* tail &#x3D; getTail(list);<br>tail &#x3D; insertTail(tail, 1);<br>tail &#x3D; insertTail(tail, 2);<br>tail &#x3D; insertTail(tail, 3);<br>listNode(list);<br>insertNode(list, 2, 6);<br>listNode(list);<br>deleteNode(list, 3);<br>listNode(list);<br>return 0;<br>}</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2025/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/"/>
      <url>/2025/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>#include&lt;stdio.h&gt;<br>#include&lt;stdlib.h&gt;<br>typedef int ElemType;<br>typedef struct node {<br>ElemType data;<br>struct node* next;<br>}Node;</p><p>Node* initList() {<br>Node* head &#x3D; (Node*)malloc(sizeof(Node));<br>head-&gt;data &#x3D; 0;<br>head-&gt;next &#x3D; NULL;<br>return head;<br>}</p><p>&#x2F;&#x2F;头插法<br>int insertHead(Node* L, ElemType e)&#x2F;&#x2F;L为头结点<br>{<br>Node* p &#x3D; (Node*)malloc(sizeof(Node));<br>p-&gt;data &#x3D; e;<br>p-&gt;next &#x3D; L-&gt;next;<br>L-&gt;next &#x3D; p;<br>return 1;<br>}</p><p>&#x2F;&#x2F;遍历<br>int listNode(Node* L) {<br>Node* p &#x3D; L-&gt;next;<br>while (p !&#x3D; NULL) {<br>printf(“%d  “, p-&gt;data);<br>p &#x3D; p-&gt;next;<br>}<br>printf(“\n”);<br>return 1;<br>}</p><p>&#x2F;&#x2F;获取尾部节点<br>Node* getTail(Node* L) {<br>Node* p &#x3D; L;<br>while (p-&gt;next !&#x3D; NULL) {<br>p &#x3D; p-&gt;next;<br>}<br>return p;<br>}</p><p>&#x2F;&#x2F;尾插法<br>Node* insertTail(Node* tail, ElemType e) {<br>Node* p &#x3D; (Node*)malloc(sizeof(Node));<br>p-&gt;data &#x3D; e;<br>tail-&gt;next &#x3D; p;<br>p-&gt;next &#x3D; NULL;<br>return p;<br>}</p><p>&#x2F;&#x2F;在指定位置插入<br>int insertNode(Node* L, int pos, ElemType e) {<br>Node* p &#x3D; L;<br>int i &#x3D; 0;<br>while (i &lt; pos - 1) {<br>p &#x3D; p-&gt;next;<br>i++;<br>if (p &#x3D;&#x3D; NULL) {<br>return 0;<br>}<br>}&#x2F;&#x2F;此时p为指定位置的前一个位置<br>Node* q &#x3D; (Node*)malloc(sizeof(Node));<br>q-&gt;data &#x3D; e;<br>q-&gt;next &#x3D; p-&gt;next;<br>p-&gt;next &#x3D; q;<br>return 1;<br>}</p><p>&#x2F;&#x2F;删除节点<br>int deleteNode(Node* L, int pos) {<br>Node* p &#x3D; L;<br>int i &#x3D; 0;<br>while (i &lt; pos - 1) {<br>p &#x3D; p-&gt;next;<br>i++;<br>if (p &#x3D;&#x3D; NULL) {<br>return 0;<br>}<br>}<br>Node* q &#x3D; p-&gt;next;<br>p-&gt;next &#x3D; q-&gt;next;<br>free(q);<br>return 1;<br>}</p><p>int main() {<br>Node* list &#x3D; initList();<br>Node* tail &#x3D; getTail(list);&#x2F;&#x2F;先找到尾结点<br>&#x2F;<em>insertHead(list, 10);<br>insertHead(list, 20);<br>insertHead(list, 30);</em>&#x2F;<br>tail &#x3D; insertTail(tail, 10);&#x2F;&#x2F;通过更新尾结点来持续进行尾插法<br>tail &#x3D; insertTail(tail, 20);<br>tail &#x3D; insertTail(tail, 30);<br>listNode(list);<br>insertNode(list, 2, 100);<br>listNode(list);<br>deleteNode(list, 3);<br>listNode(list);<br>return 0;<br>}</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>顺序表</title>
      <link href="/2025/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
      <url>/2025/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>#include&lt;stdio.h&gt;<br>#include&lt;stdlib.h&gt;<br>#define max 100<br>typedef int ElemType;</p><p>typedef struct {<br>    ElemType <em>data;<br>    int length;<br>}SeqList<br>;<br>&#x2F;&#x2F;初始化<br>SeqList</em> initList()<br>{<br>    SeqList* L &#x3D; (SeqList*)malloc(sizeof(SeqList));<br>    L-&gt;data &#x3D; (ElemType*)malloc(sizeof(ElemType) * max);<br>    L-&gt;length &#x3D; 0;<br>    return L;<br>}</p><p>&#x2F;&#x2F;在尾部添加数据<br>int appendElem(SeqList* L, ElemType e) {<br>    if (L-&gt;length &gt;&#x3D; max) {<br>        printf(“顺序表已满”);<br>        return 0;<br>    }<br>    L-&gt;data[L-&gt;length] &#x3D; e;<br>    L-&gt;length++;<br>    return 1;<br>}</p><p>&#x2F;&#x2F;遍历<br>void listElem(SeqList* L) {<br>    for (int i &#x3D; 0; i &lt; L-&gt;length; i++)<br>    {<br>        printf(“%d\t”, L-&gt;data[i]);<br>    }<br>    printf(“\n”);</p><p>}</p><p>&#x2F;&#x2F;插入数据<br>int insertElem(SeqList* L, int pos, ElemType e) {<br>    if (pos &lt;&#x3D; L-&gt;length - 1) {<br>        for (int i &#x3D; L-&gt;length - 1; i &gt;&#x3D; pos - 1; i–) {&#x2F;&#x2F;pos-1 就是要插入的位置<br>            L-&gt;data[i + 1] &#x3D; L-&gt;data[i];&#x2F;&#x2F;pos-1之后的数都往后挪一个位置，把pos-1的位置空出来<br>        }<br>        L-&gt;data[pos - 1] &#x3D; e;<br>        L-&gt;length++;<br>    }<br>    return 1;<br>}</p><p>&#x2F;&#x2F;删除数据<br>int deleteElem(SeqList* L, int pos, ElemType* e) {<br>    *e &#x3D; L-&gt;data[pos - 1];<br>    if (pos &lt; L-&gt;length) {<br>        for (int i &#x3D; pos; i &lt; L-&gt;length; i++)<br>        {<br>            L-&gt;data[i - 1] &#x3D; L-&gt;data[i];&#x2F;&#x2F;把要删除的位置后的数往前挪<br>        }<br>    }<br>    L-&gt;length–;<br>    return 1;<br>}</p><p>int main() {</p><pre><code>SeqList *list = initList();appendElem(list, 1);appendElem(list, 2);appendElem(list, 3);appendElem(list, 4);insertElem(list, 2, 6);listElem(list);ElemType delData;deleteElem(list, 2, &amp;delData);listElem(list);return 0;</code></pre><p>}</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>时间复杂度</title>
      <link href="/2025/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2025/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png"><br><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.png"><br>2的(t-1)次方 &gt; n  是因为只有这时候循环结束(即这是判定条件)</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/2025/05/01/JAVASE/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2025/05/01/JAVASE/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>一.对象代表什么,就得封装对应的数据，并提供数据对应的行为<br>比如“画圆”的对象是“圆”本身，因为画圆需要半径等等，并不是人画的<br>再比如“关门”是门自己关的，人不过是给了个作用力</p><p>二.private<br><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/JAVA%5Cprivate.png"><br>(忘了的时候看一眼吧)<br>直接用javabean插件就可以了嘻嘻<br>当然也可以用快捷键 alt+insert</p><p>三.this<br><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/JAVA/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F.png"><br>这是成员变量和局部变量</p><p><img src="/%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/JAVA/%E5%B0%B1%E8%BF%91%E5%8E%9F%E5%88%99.png"><br>此为就近原则，如果不加this，谁离age近值就是谁，加上this，则会调用成员变量</p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>像素画</title>
      <link href="/2025/05/01/%E5%83%8F%E7%B4%A0%E7%94%BB/%E5%83%8F%E7%B4%A0%E7%94%BB/"/>
      <url>/2025/05/01/%E5%83%8F%E7%B4%A0%E7%94%BB/%E5%83%8F%E7%B4%A0%E7%94%BB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 像素画 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>碎碎念</title>
      <link href="/2025/05/01/%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
      <url>/2025/05/01/%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>无语啦，累死我了&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</p><p>想要跳转文章的话就用 <a href="%E6%96%87%E7%AB%A0%E9%93%BE%E6%8E%A5">文章名</a></p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
